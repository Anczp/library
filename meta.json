[
  {
    "dir_name": "algorithm",
    "name": "算法",
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 235,
          "average": "9.6",
          "min": 0
        },
        "subtitle": "计算机科学基础（第2版）",
        "author": [
          "Ronald L.Graham",
          "Oren Patashnik",
          "Donald E.Knuth"
        ],
        "pubdate": "2013-4-1",
        "tags": [
          {
            "count": 1160,
            "name": "数学",
            "title": "数学"
          },
          {
            "count": 727,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 412,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 354,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 199,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 94,
            "name": "计算机技术",
            "title": "计算机技术"
          },
          {
            "count": 93,
            "name": "具体数学",
            "title": "具体数学"
          },
          {
            "count": 93,
            "name": "Math",
            "title": "Math"
          }
        ],
        "origin_title": "Concrete Mathematics: A Foundation for Computer Science",
        "image": "https://img3.doubanio.com/view/subject/m/public/s26372180.jpg",
        "binding": "平装",
        "translator": [
          "张凡",
          "张明尧"
        ],
        "catalog": "中文版致辞\n前言\n记号注释\n第1章 递归问题\n1.1 河内塔\n1.2 平面上的直线\n1.3 若瑟夫问题\n习题\n第2章 和式\n2.1 记号\n2.2 和式和递归式\n2.3 和式的处理\n2.4 多重和式\n2.5 一般性的方法\n2.6 有限微积分和无限微积分\n2.7 无限和式\n习题\n第3章 整值函数\n3.1　底和顶\n3.2　底和顶的应用\n3.3　底和顶的递归式\n3.4　mod：二元运算\n3.5　底和顶的和式\n习题\n第4章 数论\n4.1　整除性\n4.2　素数\n4.3　素数的例子\n4.4　阶乘的因子\n4.5　互素\n4.6　mod：同余关系\n4.7　独立剩余\n4.8　进一步的应用\n4.9　 函数和 函数\n习题\n第5章 二项式系数\n5.1　基本恒等式\n5.2　基本练习\n5.3　处理的技巧\n5.4　生成函数\n5.5　超几何函数\n5.6　超几何变换\n5.7　部分超几何和式\n5.8　机械求和法\n习题\n第6章 特殊的数\n6.1　斯特林数\n6.2　欧拉数\n6.3　调和数\n6.4　调和求和法\n6.5　伯努利数\n6.6　斐波那契数\n6.7　觭夹行列式\n习题\n第7章 生成函数\n7.1　多米诺理论与换零钱\n7.2　基本策略\n7.3　解递归式\n7.4　特殊的生成函数\n7.5　卷积\n7.6　指数生成函数\n7.7　狄利克雷生成函数\n习题\n第8章 离散概率\n8.1　定义\n8.2　均值和方差\n8.3　概率生成函数\n8.4　抛掷硬币\n8.5　散列法\n习题\n第9章 渐近式\n9.1　量的等级\n9.2　大O记号\n9.3　O运算规则\n9.4　两个渐近技巧\n9.5　欧拉求和公式\n9.6　最后的求和法\n习题\n附录A 习题答案\n附录B 参考文献\n附录C 习题贡献者\n译后记\n索引",
        "pages": "562",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s26372180.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s26372180.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s26372180.jpg"
        },
        "alt": "https://book.douban.com/subject/21323941/",
        "id": "21323941",
        "publisher": "人民邮电出版社",
        "isbn10": "7115308101",
        "isbn13": "9787115308108",
        "title": "具体数学 - 第2版",
        "url": "https://api.douban.com/v2/book/21323941",
        "alt_title": "Concrete Mathematics: A Foundation for Computer Science",
        "author_intro": "Ronald L. Graham（葛立恒）著名数学家，美国加州大学圣迭戈分校计算机与信息科学专业教席（Jacobs Endowed Chair），AT&T实验室研究中心荣誉首席科学家，美国数学学会前任主席。Graham于1999年成为美国计算机学会会士，200 3年获得美国数学学会的斯蒂尔终身成就奖，2012年成为美国数学学会会士。他还曾获得美国数学学会颁发的Lester R. Ford奖和Carl Allendoerfer奖以及其他众多奖项。\nDonald E. Knuth（高德纳）著名计算机科学家，算法与程序设计技术的先驱者、斯坦福大学计算机系荣休教授、计算机排版系统TEX和METAFONT字体系统的发明人，因诸多成就以及大量富于创造力和具有深远影响的著作（19部书，160篇论文）而誉满全球。近些年，他将精力全部投入到《计算机程序设计艺术》七卷集的史诗般创作中。Knuth教授获得过许多奖项和荣誉，包括美国计算机协会图灵奖、美国国家科学奖章、美国数学学会的斯蒂尔奖，以及因发明先进技术于1996年荣获的京都奖。1996年，设立了以其名字命名的Donald E. Knuth奖，授予那些为计算机科学基础做出杰出贡献的人。\nOren Patashnik 著名计算机科学家，BibTeX的创始人之一，是位于拉荷亚的通信研究中心的研究员。他1976年毕业于耶鲁大学，后来在斯坦福大学师从Knuth，1980年就职于贝尔实验室。1985年与Leslie Lamport合作创建了BibTeX（LaTeX的一种工具，用于管理文献、产生文献目录）。\n译者简介\n张明尧：1945年12月出生，安徽大学数学系毕业并获得中国科学院数学研究所博士学位。长期从事解析数论、代数数论以及计算数论方面的研究工作，参与翻译的著作有《数论中未解决的问题（第2版）》（R. K. Guy著）、《纯数学教程（纪念版）》（G. H. Hardy著）、《哈代数论（第6版）》（G. H. Hardy著）和《算术探索》（C. F. Gauss著）等。\n张凡：1982年7月出生，加拿大Concordia大学数学系毕业，并获得统计专业硕士学位。参与翻译的著作有《数论导引（第5版）》（G. H. Hardy著）和《哈代数论（第6版）》（G. H. Hardy著）等。",
        "summary": "本书介绍了计算机的数学基础，内容涉及求和、取整函数、数论、二项式系数、特殊数、母函数（发生函数）、离散概率、渐近等等，面向从事计算机科学、计算数学、计算技术诸方面工作的人员，以及高等院校相关专业的师生。",
        "series": {
          "id": "18507",
          "title": "图灵计算机科学丛书"
        },
        "price": "99.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "67c76e2a2882133afd2e5c2840766c53fa73f62e3d2aace3443cb5823f335a0c",
        "file": "具体数学 - 第2版.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 130,
          "average": "8.7",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[日]涌井良幸",
          "[日]涌井贞美"
        ],
        "pubdate": "2019-4",
        "tags": [
          {
            "count": 181,
            "name": "深度学习",
            "title": "深度学习"
          },
          {
            "count": 155,
            "name": "数学",
            "title": "数学"
          },
          {
            "count": 71,
            "name": "机器学习",
            "title": "机器学习"
          },
          {
            "count": 59,
            "name": "神经网络",
            "title": "神经网络"
          },
          {
            "count": 49,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 32,
            "name": "很详尽的入门书",
            "title": "很详尽的入门书"
          },
          {
            "count": 30,
            "name": "数据分析",
            "title": "数据分析"
          },
          {
            "count": 26,
            "name": "计算科学",
            "title": "计算科学"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/view/subject/m/public/s32295077.jpg",
        "binding": "平装",
        "translator": [
          "杨瑞龙"
        ],
        "catalog": "第1章　神经网络的思想\n1 - 1　神经网络和深度学习　　2\n1 - 2　神经元工作的数学表示　　6\n1 - 3　激活函数：将神经元的工作一般化　　12\n1 - 4　什么是神经网络　　18\n1 - 5　用恶魔来讲解神经网络的结构　　23\n1 - 6　将恶魔的工作翻译为神经网络的语言　　31\n1 - 7　网络自学习的神经网络　　36\n第2章　神经网络的数学基础\n2 - 1　神经网络所需的函数　　40\n2 - 2　有助于理解神经网络的数列和递推关系式　　46\n2 - 3　神经网络中经常用到的Σ符号　　51\n2 - 4　有助于理解神经网络的向量基础　　53\n2 - 5　有助于理解神经网络的矩阵基础　　61\n2 - 6　神经网络的导数基础　　65\n2 - 7　神经网络的偏导数基础　　72\n2 - 8　误差反向传播法必需的链式法则　　76\n2 - 9　梯度下降法的基础：多变量函数的近似公式　　80\n2 - 10　梯度下降法的含义与公式　　83\n2 - 11　用Excel 体验梯度下降法　　91\n2 - 12　最优化问题和回归分析　　94\n第3章　神经网络的最优化\n3 - 1　神经网络的参数和变量　　102\n3 - 2　神经网络的变量的关系式　　111\n3 - 3　学习数据和正解　　114\n3 - 4　神经网络的代价函数　　119\n3 - 5　用Excel体验神经网络　　127\n第4章　神经网络和误差反向传播法\n4 - 1　梯度下降法的回顾　　134\n4 - 2　神经单元误差　　141\n4 - 3　神经网络和误差反向传播法　　146\n4 - 4　用Excel体验神经网络的误差反向传播法　　153\n第5章　深度学习和卷积神经网络\n5 - 1　小恶魔来讲解卷积神经网络的结构　　168\n5 - 2　将小恶魔的工作翻译为卷积神经网络的语言　　174\n5 - 3　卷积神经网络的变量关系式　　180\n5 - 4　用Excel体验卷积神经网络　　193\n5 - 5　卷积神经网络和误差反向传播法　　200\n5 - 6　用Excel体验卷积神经网络的误差反向传播法　　212\n附录\nA　训练数据（1）　　222\nB　训练数据（2）　　223\nC　用数学式表示模式的相似度　　225",
        "pages": "236",
        "images": {
          "small": "https://img1.doubanio.com/view/subject/s/public/s32295077.jpg",
          "large": "https://img1.doubanio.com/view/subject/l/public/s32295077.jpg",
          "medium": "https://img1.doubanio.com/view/subject/m/public/s32295077.jpg"
        },
        "alt": "https://book.douban.com/subject/33414479/",
        "id": "33414479",
        "publisher": "人民邮电出版社",
        "isbn10": "7115509344",
        "isbn13": "9787115509345",
        "title": "深度学习的数学",
        "url": "https://api.douban.com/v2/book/33414479",
        "alt_title": "",
        "author_intro": "作者简介：\n涌井良幸\n1950年生于东京，毕业于东京教育大学（现筑波大学）数学系，现为自由职业者。著有《用Excel学深度学习》（合著）、《统计学有什么用？》等。\n涌井贞美\n1952年生于东京，完成东京大学理学系研究科硕士课程，现为自由职业者。著有《用Excel学深度学习》（合著）、《图解贝叶斯统计入门》等。\n译者简介：\n杨瑞龙（\n1982年生，2008年北京大学数学科学学院硕士毕业，软件开发者，从事软件行业10年。2013年～2016年赴日工作3年，从2016年开始在哆嗒数学网公众号发表《数学上下三万年》等多篇翻译作品。",
        "summary": "《深度学习的数学》基于丰富的图示和具体示例，通俗易懂地介绍了深度学习相关的数学知识。第1章介绍神经网络的概况；第2章介绍理解神经网络所需的数学基础知识；第3章介绍神经网络的最优化；第4章介绍神经网络和误差反向传播法；第5章介绍深度学习和卷积神经网络。书中使用Excel进行理论验证，帮助读者直观地体验深度学习的原理。",
        "price": "69.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "377a43dfdf2d590a1a77f11aabf120e3a0ab7bb4b823dea20e21a6f40772b1e8",
        "file": "深度学习的数学.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 169,
          "average": "8.4",
          "min": 0
        },
        "subtitle": "线性代数",
        "author": [
          "[日] 平冈和幸",
          "[日] 堀玄"
        ],
        "pubdate": "2016-3",
        "tags": [
          {
            "count": 344,
            "name": "数学",
            "title": "数学"
          },
          {
            "count": 170,
            "name": "线性代数",
            "title": "线性代数"
          },
          {
            "count": 114,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 87,
            "name": "程序员的数学",
            "title": "程序员的数学"
          },
          {
            "count": 86,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 81,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 73,
            "name": "计算机数学",
            "title": "计算机数学"
          },
          {
            "count": 40,
            "name": "程序员",
            "title": "程序员"
          }
        ],
        "origin_title": "",
        "image": "https://img9.doubanio.com/view/subject/m/public/s28487645.jpg",
        "binding": "平装",
        "translator": [
          "卢晓南"
        ],
        "catalog": "第0章　动机　　1\n0.1　空间想象给我们带来的直观感受　　1\n0.2　有效利用线性近似的手段　　2\n第1章　用空间的语言表达向量、矩阵和行列式　　5\n1.1　向量与空间　　5\n1.1.1　最直接的定义：把数值罗列起来就是向量　　6\n1.1.2　“空间”的形象　　9\n1.1.3　基底　　11\n1.1.4　构成基底的条件　　16\n1.1.5　维数　　18\n1.1.6　坐标　　19\n1.2　矩阵和映射　　19\n1.2.1　暂时的定义　　19\n1.2.2　用矩阵来表达各种关系（1）　　24\n1.2.3　矩阵就是映射！ 　　25\n1.2.4　矩阵的乘积=映射的合成　　28\n1.2.5　矩阵运算的性质　　31\n1.2.6　矩阵的乘方=映射的迭代　　35\n1.2.7　零矩阵、单位矩阵、对角矩阵　　37\n1.2.8　逆矩阵=逆映射　　44\n1.2.9　分块矩阵　　47\n1.2.10　用矩阵表示各种关系（2）　　53\n1.2.11　坐标变换与矩阵　　55\n1.2.12　转置矩阵=??? 　　63\n1.2.13　补充（1）：时刻注意矩阵规模　　64\n1.2.14　补充（2）：从矩阵的元素的角度看　　67\n1.3　行列式与扩大率　　68\n1.3.1　行列式=体积扩大率　　68\n1.3.2　行列式的性质　　73\n1.3.3　行列式的计算方法（1）：计算公式▽　　80\n1.3.4　行列式的计算方法（2）：笔算法▽　　87\n1.3.5　补充：行列式按行（列）展开与逆矩阵▽　　91\n第2章　秩、逆矩阵、线性方程组——溯因推理　　95\n2.1　问题设定：逆问题　　95\n2.2　良性问题（可逆矩阵） 　　97\n2.2.1　可逆性与逆矩阵　　97\n2.2.2　线性方程组的解法（系数矩阵可逆的情况）▽　　97\n2.2.3　逆矩阵的计算方法▽ 　　107\n2.2.4　初等变换▽ 　　110\n2.3　恶性问题　　115\n2.3.1　恶性问题示例　　115\n2.3.2　问题的恶劣程度——核与像　　120\n2.3.3　维数定理　　122\n2.3.4　用式子表示“压缩扁平化”变换（线性无关、线性相关）　　126\n2.3.5　线索的实际个数（秩） 　　130\n2.3.6　秩的求解方法（1）——悉心观察　　137\n2.3.7　秩的求解方法（2）——笔算　　142\n2.4　良性恶性的判定（逆矩阵存在的条件）　　149\n2.4.1　重点是“是不是压缩扁平化映射”　　149\n2.4.2　与可逆性等价的条件　　150\n2.4.3　关于可逆性的小结　　151\n2.5　针对恶性问题的对策　　152\n2.5.1　求出所有能求的结果（1）理论篇　　152\n2.5.2　求出所有能求的结果（2）实践篇　　155\n2.5.3　最小二乘法　　166\n2.6　现实中的恶性问题（接近奇异的矩阵）　　167\n2.6.1　问题源于哪里　　167\n2.6.2　对策示例——提克洛夫规范化　　170\n第3章　计算机上的计算（1）——LU 分解　　173\n3.1　引言　　173\n3.1.1　切莫小看数值计算　　173\n3.1.2　关于本书中的程序　　174\n3.2　热身：加减乘运算　　174\n3.3　LU分解　　176\n3.3.1　定义　　176\n3.3.2　分解能带来什么好处　　178\n3.3.3　LU分解真的可以做到吗　　178\n3.3.4　LU分解的运算量如何　　180\n3.4　LU分解的步骤（1）一般情况　　182\n3.5　利用LU分解求行列式值　　186\n3.6　利用LU分解求解线性方程组　　187\n3.7　利用LU分解求逆矩阵　　191\n3.8　LU分解的步骤（2）意外发生的情况　　192\n3.8.1　需要整理顺序的情况　　192\n3.8.2　重新整理顺序也无济于事的状况　　196\n第4章　特征值、对角化、Jordan标准型——判断是否有失控的危险　　197\n4.1　问题的提出：稳定性　　197\n4.2　一维的情况　　202\n4.3　对角矩阵的情况　　203\n4.4　可对角化的情况　　205\n4.4.1　变量替换　　205\n4.4.2　变量替换的求法　　213\n4.4.3　从坐标变换的角度来解释　　215\n4.4.4　从乘方的角度来解释　　219\n4.4.5　结论：关键取决于特征值的绝对值　　220\n4.5　特征值、特征向量　　220\n4.5.1　几何学意义　　220\n4.5.2　特征值、特征向量的性质　　225\n4.5.3　特征值的计算：特征方程　　232\n4.5.4　特征向量的计算▽ 　　240\n4.6　连续时间系统　　246\n4.6.1　微分方程　　247\n4.6.2　一阶情况　　250\n4.6.3　对角矩阵的情况　　250\n4.6.4　可对角化的情况　　252\n4.6.5　结论：特征值（的实部）的符号是关键　　252\n4.7　不可对角化的情况　　255\n4.7.1　首先给出结论　　255\n4.7.2　就算不能对角化——Jordan标准型　　256\n4.7.3　Jordan标准型的性质　　257\n4.7.4　利用Jordan标准型解决初始值问题（失控判定的最终结论）　　264\n4.7.5　化Jordan标准型的方法　　271\n4.7.6　任何方阵均可化为Jordan标准型的证明　　279\n第5章　计算机上的计算（2）——特征值算法　　299\n5.1　概要　　299\n5.1.1　和笔算的不同之处　　299\n5.1.2　伽罗华理论　　300\n5.1.3　5×5以上的矩阵的特征值不存在通用的求解步骤！　　302\n5.1.4　有代表性的特征值数值算法　　303\n5.2　Jacobi方法　　303\n5.2.1　平面旋转　　304\n5.2.2　通过平面旋转进行相似变换　　306\n5.2.3　计算过程的优化　　309\n5.3　幂法原理　　310\n5.3.1　求绝对值最大的特征值　　310\n5.3.2　求绝对值最小的特征值　　311\n5.3.3　QR分解　　312\n5.3.4　求所有特征值　　316\n5.4　QR方法　　318\n5.4.1　QR方法的原理　　319\n5.4.2　Hessenberg矩阵　　321\n5.4.3　Householder方法　　322\n5.4.4　Hessenberg矩阵的QR迭代　　325\n5.4.5　原点位移、降阶　　327\n5.4.6　对称矩阵的情况　　327\n5.5　反幂法　　328\n附录A　希腊字母表　　330\n附录B　复数　　331\n附录C　关于基底的补充说明　　336\n附录D　微分方程的解法　　341\nD.1　dx/dt = f(x) 型　　341\nD.2　dx/dt = ax + g(t) 型　　342\n附录E　内积、对称矩阵、正交矩阵　　346\nE.1　内积空间　　346\nE.1.1　模长　　346\nE.1.2　正交　　347\nE.1.3　内积　　347\nE.1.4　标准正交基　　349\nE.1.5　转置矩阵　　351\nE.1.6　复内积空间　　351\nE.2　对称矩阵与正交矩阵——实矩阵的情况　　352\nE.3　埃尔米特矩阵与酉矩阵——复矩阵的情况　　353\n附录F　动画演示程序的使用方法　　354\nF.1　执行结果　　354\nF.2　准备工作　　354\nF.3　使用方法　　355\n参考文献　　357",
        "pages": "384",
        "images": {
          "small": "https://img9.doubanio.com/view/subject/s/public/s28487645.jpg",
          "large": "https://img9.doubanio.com/view/subject/l/public/s28487645.jpg",
          "medium": "https://img9.doubanio.com/view/subject/m/public/s28487645.jpg"
        },
        "alt": "https://book.douban.com/subject/26740548/",
        "id": "26740548",
        "publisher": "人民邮电出版社",
        "isbn10": "7115417741",
        "isbn13": "9787115417749",
        "title": "程序员的数学3",
        "url": "https://api.douban.com/v2/book/26740548",
        "alt_title": "",
        "author_intro": "堀玄\n专攻应用数学和物理,主要从事脑科学与信号处理领域的研究。喜欢Ruby、JavaScript、PostScript等语言。最近正在研究基于统计学理论的语言处理。工学博士。\n\n平冈和幸\n专攻应用数学和物理，对机器学习兴趣浓厚。喜欢Ruby，热爱Scheme。最近被Common Lisp吸引，正在潜心研究。工学博士。",
        "summary": "本书沿袭“程序员的数学”系列平易近人的风格，用通俗的语言和具象的图表深入讲解了编程中所需的线性代数知识。内容包括向量、矩阵、行列式、秩、逆矩阵、线性方程、LU分解、特征值、对角化、Jordan标准型、特征值算法等。",
        "series": {
          "id": "34821",
          "title": "图灵程序设计丛书·程序员的数学"
        },
        "price": "79.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "99c219aa24c4c2dca73b186baa00e7f35e0eefe9113b608695d7ab1f56e479e6",
        "file": "程序员的数学_3_线性代数.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 885,
          "average": "9.4",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "塞奇威克 (Robert Sedgewick)",
          "韦恩 (Kevin Wayne)"
        ],
        "pubdate": "2012-10-1",
        "tags": [
          {
            "count": 2080,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 856,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 730,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 437,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 405,
            "name": "Algorithms",
            "title": "Algorithms"
          },
          {
            "count": 393,
            "name": "计算机-算法",
            "title": "计算机-算法"
          },
          {
            "count": 271,
            "name": "经典",
            "title": "经典"
          },
          {
            "count": 262,
            "name": "Java",
            "title": "Java"
          }
        ],
        "origin_title": "Algorithms 4th edition",
        "image": "https://img3.doubanio.com/view/subject/m/public/s28322244.jpg",
        "binding": "平装",
        "translator": [
          "谢路云"
        ],
        "catalog": "目录\n第1章　 基础　　1\n1.1　基础编程模型　　4\n1.1.1　Java程序的基本结构　　4\n1.1.2　原始数据类型与表达式　　6\n1.1.3　 语句　　8\n1.1.4　 简便记法　　9\n1.1.5　 数组　　10\n1.1.6　 静态方法　　12\n1.1.7　 API　　16\n1.1.8　 字符串　　20\n1.1.9　 输入输出　　21\n1.1.10　 二分查找　　28\n1.1.11　 展望　　30\n1.2　 数据抽象　　38\n1.2.1　 使用抽象数据类型　　38\n1.2.2　 抽象数据类型举例　　45\n1.2.3　 抽象数据类型的实现　　52\n1.2.4　 更多抽象数据类型的实现　　55\n1.2.5　 数据类型的设计　　60\n1.3　 背包、队列和栈　　74\n1.3.1　 API　　74\n1.3.2　 集合类数据类型的实现　　81\n1.3.3　 链表　　89\n1.3.4　 综述　　98\n1.4　 算法分析　　108\n1.4.1　 科学方法　　108\n1.4.2　 观察　　108\n1.4.3　 数学模型　　112\n1.4.4　 增长数量级的分类　　117\n1.4.5　 设计更快的算法　　118\n1.4.6　 倍率实验　　121\n1.4.7　 注意事项　　123\n1.4.8　 处理对于输入的依赖　　124\n1.4.9　 内存　　126\n1.4.10　 展望　　129\n1.5　 案例研究：union-find算法　　136\n1.5.1　 动态连通性　　136\n1.5.2　 实现　　140\n1.5.3　 展望　　148\n第2章　 排序　　152\n2.1　 初级排序算法　　153\n2.1.1　 游戏规则　　153\n2.1.2　 选择排序　　155\n2.1.3　 插入排序　　157\n2.1.4　 排序算法的可视化　　159\n2.1.5　 比较两种排序算法　　159\n2.1.6　 希尔排序　　162\n2.2　 归并排序　　170\n2.2.1　 原地归并的抽象方法　　170\n2.2.2　 自顶向下的归并排序　　171\n2.2.3　 自底向上的归并排序　　175\n2.2.4　 排序算法的复杂度　　177\n2.3　 快速排序　　182\n2.3.1　 基本算法　　182\n2.3.2　 性能特点　　185\n2.3.3　 算法改进　　187\n2.4　 优先队列　　195\n2.4.1　 API　　195\n2.4.2　 初级实现　　197\n2.4.3　 堆的定义　　198\n2.4.4　 堆的算法　　199\n2.4.5　 堆排序　　205\n2.5　 应用　　214\n2.5.1　 将各种数据排序　　214\n2.5.2　 我应该使用哪种排序算法　　218\n2.5.3　 问题的归约　　219\n2.5.4　 排序应用一览　　221\n第3章　查找　　227\n3.1　符号表　　228\n3.1.1　API　　228\n3.1.2　有序符号表　　230\n3.1.3　用例举例　　233\n3.1.4　无序链表中的顺序查找　　235\n3.1.5　有序数组中的二分查找　　238\n3.1.6　对二分查找的分析　　242\n3.1.7　预览　　244\n3.2　二叉查找树　　250\n3.2.1　基本实现　　250\n3.2.2　分析　　255\n3.2.3　有序性相关的方法与删除操作　　257\n3.3　平衡查找树　　269\n3.3.1　2-3查找树　　269\n3.3.2　红黑二叉查找树　　275\n3.3.3　实现　　280\n3.3.4　删除操作　　282\n3.3.5　红黑树的性质　　284\n3.4　散列表　　293\n3.4.1　散列函数　　293\n3.4.2　基于拉链法的散列表　　297\n3.4.3　基于线性探测法的散列表　　300\n3.4.4　调整数组大小　　304\n3.4.5　内存使用　　306\n3.5　应用　　312\n3.5.1　我应该使用符号表的哪种实现　　312\n3.5.2　集合的API　　313\n3.5.3　字典类用例　　315\n3.5.4　索引类用例　　318\n3.5.5　稀疏向量　　322\n第4章　 图　　329\n4.1　 无向图　　331\n4.1.1　 术语表　　331\n4.1.2　 表示无向图的数据类型　　333\n4.1.3　 深度优先搜索　　338\n4.1.4　 寻找路径　　342\n4.1.5　 广度优先搜索　　344\n4.1.6　 连通分量　　349\n4.1.7　 符号图　　352\n4.1.8　 总结　　358\n4.2　 有向图　　364\n4.2.1　 术语　　364\n4.2.2　 有向图的数据类型　　365\n4.2.3　 有向图中的可达性　　367\n4.2.4　 环和有向无环图　　369\n4.2.5　 有向图中的强连通性　　378\n4.2.6　 总结　　385\n4.3　 最小生成树　　390\n4.3.1　 原理　　391\n4.3.2　 加权无向图的数据类型　　393\n4.3.3　 最小生成树的API和测试用例　　396\n4.3.4　 Prim算法　　398\n4.3.5　 Prim算法的即时实现　　401\n4.3.6　 Kruskal算法　　404\n4.3.7　 展望　　407\n4.4　 最短路径　　412\n4.4.1　 最短路径的性质　　413\n4.4.2　 加权有向图的数据结构　　414\n4.4.3　 最短路径算法的理论基础　　420\n4.4.4　 Dijkstra算法　　421\n4.4.5　 无环加权有向图中的最短路径算法　　425\n4.4.6　 一般加权有向图中的最短路径问题　　433\n4.4.7　 展望　　445\n第5章　 字符串　　451\n5.1　 字符串排序　　455\n5.1.1　 键索引计数法　　455\n5.1.2　 低位优先的字符串排序　　458\n5.1.3　 高位优先的字符串排序　　461\n5.1.4　 三向字符串快速排序　　467\n5.1.5　 字符串排序算法的选择　　470\n5.2　 单词查找树　　474\n5.2.1　 单词查找树　　475\n5.2.2　 单词查找树的性质　　483\n5.2.3　 三向单词查找树　　485\n5.2.4　 三向单词查找树的性质　　487\n5.2.5　 应该使用字符串符号表的哪种实现　　489\n5.3　 子字符串查找　　493\n5.3.1　 历史简介　　493\n5.3.2　 暴力子字符串查找算法　　494\n5.3.3　 Knuth-Morris-Pratt子字符串查找算法　　496\n5.3.4　 Boyer-Moore字符串查找算法　　502\n5.3.5　 Rabin-Karp指纹字符串查找算法　　505\n5.3.6　 总结　　509\n5.4　 正则表达式　　514\n5.4.1　 使用正则表达式描述模式　　514\n5.4.2　 缩略写法　　516\n5.4.3　 正则表达式的实际应用　　517\n5.4.4　 非确定有限状态自动机　　518\n5.4.5　 模拟NFA的运行　　520\n5.4.6　 构造与正则表达式对应的\n5.5　 数据压缩　　529\n5.5.1　 游戏规则　　529\n5.5.2　 读写二进制数据　　530\n5.5.3　 局限　　533\n5.5.4　 热身运动：基因组　　534\n5.5.5　 游程编码　　537\n5.5.6　 霍夫曼压缩　　540\n第6章　 背景　　558\n索引　　611",
        "pages": "636",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s28322244.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s28322244.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s28322244.jpg"
        },
        "alt": "https://book.douban.com/subject/19952400/",
        "id": "19952400",
        "publisher": "人民邮电出版社",
        "isbn10": "7115293805",
        "isbn13": "9787115293800",
        "title": "算法（第4版）图灵",
        "url": "https://api.douban.com/v2/book/19952400",
        "alt_title": "Algorithms 4th edition",
        "author_intro": "Robert Sedgewick  斯坦福大学博士，导师为Donald E. Knuth，从1985年开始一直担任普林斯顿大学计算机科学系教授，曾任该系主任，也是Adobe Systems公司董事会成员，曾在Xerox PARC、国防分析研究所（Institute for Defense Analyses）和法国国家信息与自动化研究所（INRIA）从事研究工作。他的研究方向包括解析组合学、数据结构和算法的分析与设计、程序可视化等。\nKevin Wayne  康奈尔大学博士，普林斯顿大学计算机科学系高级讲师，研究方向包括算法的设计、分析和实现，特别是图和离散优化。",
        "summary": "本书全面讲述算法和数据结构的必备知识，具有以下几大特色。\n     算法领域的经典参考书\nSedgewick畅销著作的最新版，反映了经过几十年演化而成的算法核心知识体系\n 内容全面\n全面论述排序、搜索、图处理和字符串处理的算法和数据结构，涵盖每位程序员应知应会的50种算法\n 全新修订的代码\n全新的Java实现代码，采用模块化的编程风格，所有代码均可供读者使用\n 与实际应用相结合\n在重要的科学、工程和商业应用环境下探讨算法，给出了算法的实际代码，而非同类著作常用的伪代码\n 富于智力趣味性\n简明扼要的内容，用丰富的视觉元素展示的示例，精心设计的代码，详尽的历史和科学背景知识，各种难度的练习，这一切都将使读者手不释卷\n       科学的方法\n用合适的数学模型精确地讨论算法性能，这些模型是在真实环境中得到验证的\n 与网络相结合\n配套网站algs4.cs.princeton.edu提供了本书内容的摘要及相关的代码、测试数据、编程练习、教学课件等资源",
        "series": {
          "id": "660",
          "title": "图灵程序设计丛书"
        },
        "price": "99.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "456a3cdf987502671e5564a13559fc1fda94c73239e693b937b2d68a27f5e069",
        "file": "算法 - 第4版(图灵文字版).pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 615,
          "average": "9.4",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "塞奇威克 (Robert Sedgewick)",
          "韦恩 (Kevin Wayne)"
        ],
        "pubdate": "2012-10-1",
        "tags": [
          {
            "count": 1663,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 676,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 592,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 314,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 309,
            "name": "Algorithms",
            "title": "Algorithms"
          },
          {
            "count": 284,
            "name": "计算机-算法",
            "title": "计算机-算法"
          },
          {
            "count": 198,
            "name": "经典",
            "title": "经典"
          },
          {
            "count": 165,
            "name": "图灵程序设计丛书",
            "title": "图灵程序设计丛书"
          }
        ],
        "origin_title": "Algorithms 4th edition",
        "image": "https://img3.doubanio.com/mpic/s28322244.jpg",
        "binding": "平装",
        "translator": [
          "谢路云"
        ],
        "catalog": "目录\n第1章　 基础　　1\n1.1　基础编程模型　　4\n1.1.1　Java程序的基本结构　　4\n1.1.2　原始数据类型与表达式　　6\n1.1.3　 语句　　8\n1.1.4　 简便记法　　9\n1.1.5　 数组　　10\n1.1.6　 静态方法　　12\n1.1.7　 API　　16\n1.1.8　 字符串　　20\n1.1.9　 输入输出　　21\n1.1.10　 二分查找　　28\n1.1.11　 展望　　30\n1.2　 数据抽象　　38\n1.2.1　 使用抽象数据类型　　38\n1.2.2　 抽象数据类型举例　　45\n1.2.3　 抽象数据类型的实现　　52\n1.2.4　 更多抽象数据类型的实现　　55\n1.2.5　 数据类型的设计　　60\n1.3　 背包、队列和栈　　74\n1.3.1　 API　　74\n1.3.2　 集合类数据类型的实现　　81\n1.3.3　 链表　　89\n1.3.4　 综述　　98\n1.4　 算法分析　　108\n1.4.1　 科学方法　　108\n1.4.2　 观察　　108\n1.4.3　 数学模型　　112\n1.4.4　 增长数量级的分类　　117\n1.4.5　 设计更快的算法　　118\n1.4.6　 倍率实验　　121\n1.4.7　 注意事项　　123\n1.4.8　 处理对于输入的依赖　　124\n1.4.9　 内存　　126\n1.4.10　 展望　　129\n1.5　 案例研究：union-find算法　　136\n1.5.1　 动态连通性　　136\n1.5.2　 实现　　140\n1.5.3　 展望　　148\n第2章　 排序　　152\n2.1　 初级排序算法　　153\n2.1.1　 游戏规则　　153\n2.1.2　 选择排序　　155\n2.1.3　 插入排序　　157\n2.1.4　 排序算法的可视化　　159\n2.1.5　 比较两种排序算法　　159\n2.1.6　 希尔排序　　162\n2.2　 归并排序　　170\n2.2.1　 原地归并的抽象方法　　170\n2.2.2　 自顶向下的归并排序　　171\n2.2.3　 自底向上的归并排序　　175\n2.2.4　 排序算法的复杂度　　177\n2.3　 快速排序　　182\n2.3.1　 基本算法　　182\n2.3.2　 性能特点　　185\n2.3.3　 算法改进　　187\n2.4　 优先队列　　195\n2.4.1　 API　　195\n2.4.2　 初级实现　　197\n2.4.3　 堆的定义　　198\n2.4.4　 堆的算法　　199\n2.4.5　 堆排序　　205\n2.5　 应用　　214\n2.5.1　 将各种数据排序　　214\n2.5.2　 我应该使用哪种排序算法　　218\n2.5.3　 问题的归约　　219\n2.5.4　 排序应用一览　　221\n第3章　查找　　227\n3.1　符号表　　228\n3.1.1　API　　228\n3.1.2　有序符号表　　230\n3.1.3　用例举例　　233\n3.1.4　无序链表中的顺序查找　　235\n3.1.5　有序数组中的二分查找　　238\n3.1.6　对二分查找的分析　　242\n3.1.7　预览　　244\n3.2　二叉查找树　　250\n3.2.1　基本实现　　250\n3.2.2　分析　　255\n3.2.3　有序性相关的方法与删除操作　　257\n3.3　平衡查找树　　269\n3.3.1　2-3查找树　　269\n3.3.2　红黑二叉查找树　　275\n3.3.3　实现　　280\n3.3.4　删除操作　　282\n3.3.5　红黑树的性质　　284\n3.4　散列表　　293\n3.4.1　散列函数　　293\n3.4.2　基于拉链法的散列表　　297\n3.4.3　基于线性探测法的散列表　　300\n3.4.4　调整数组大小　　304\n3.4.5　内存使用　　306\n3.5　应用　　312\n3.5.1　我应该使用符号表的哪种实现　　312\n3.5.2　集合的API　　313\n3.5.3　字典类用例　　315\n3.5.4　索引类用例　　318\n3.5.5　稀疏向量　　322\n第4章　 图　　329\n4.1　 无向图　　331\n4.1.1　 术语表　　331\n4.1.2　 表示无向图的数据类型　　333\n4.1.3　 深度优先搜索　　338\n4.1.4　 寻找路径　　342\n4.1.5　 广度优先搜索　　344\n4.1.6　 连通分量　　349\n4.1.7　 符号图　　352\n4.1.8　 总结　　358\n4.2　 有向图　　364\n4.2.1　 术语　　364\n4.2.2　 有向图的数据类型　　365\n4.2.3　 有向图中的可达性　　367\n4.2.4　 环和有向无环图　　369\n4.2.5　 有向图中的强连通性　　378\n4.2.6　 总结　　385\n4.3　 最小生成树　　390\n4.3.1　 原理　　391\n4.3.2　 加权无向图的数据类型　　393\n4.3.3　 最小生成树的API和测试用例　　396\n4.3.4　 Prim算法　　398\n4.3.5　 Prim算法的即时实现　　401\n4.3.6　 Kruskal算法　　404\n4.3.7　 展望　　407\n4.4　 最短路径　　412\n4.4.1　 最短路径的性质　　413\n4.4.2　 加权有向图的数据结构　　414\n4.4.3　 最短路径算法的理论基础　　420\n4.4.4　 Dijkstra算法　　421\n4.4.5　 无环加权有向图中的最短路径算法　　425\n4.4.6　 一般加权有向图中的最短路径问题　　433\n4.4.7　 展望　　445\n第5章　 字符串　　451\n5.1　 字符串排序　　455\n5.1.1　 键索引计数法　　455\n5.1.2　 低位优先的字符串排序　　458\n5.1.3　 高位优先的字符串排序　　461\n5.1.4　 三向字符串快速排序　　467\n5.1.5　 字符串排序算法的选择　　470\n5.2　 单词查找树　　474\n5.2.1　 单词查找树　　475\n5.2.2　 单词查找树的性质　　483\n5.2.3　 三向单词查找树　　485\n5.2.4　 三向单词查找树的性质　　487\n5.2.5　 应该使用字符串符号表的哪种实现　　489\n5.3　 子字符串查找　　493\n5.3.1　 历史简介　　493\n5.3.2　 暴力子字符串查找算法　　494\n5.3.3　 Knuth-Morris-Pratt子字符串查找算法　　496\n5.3.4　 Boyer-Moore字符串查找算法　　502\n5.3.5　 Rabin-Karp指纹字符串查找算法　　505\n5.3.6　 总结　　509\n5.4　 正则表达式　　514\n5.4.1　 使用正则表达式描述模式　　514\n5.4.2　 缩略写法　　516\n5.4.3　 正则表达式的实际应用　　517\n5.4.4　 非确定有限状态自动机　　518\n5.4.5　 模拟NFA的运行　　520\n5.4.6　 构造与正则表达式对应的\n5.5　 数据压缩　　529\n5.5.1　 游戏规则　　529\n5.5.2　 读写二进制数据　　530\n5.5.3　 局限　　533\n5.5.4　 热身运动：基因组　　534\n5.5.5　 游程编码　　537\n5.5.6　 霍夫曼压缩　　540\n第6章　 背景　　558\n索引　　611",
        "pages": "636",
        "images": {
          "small": "https://img3.doubanio.com/spic/s28322244.jpg",
          "large": "https://img3.doubanio.com/lpic/s28322244.jpg",
          "medium": "https://img3.doubanio.com/mpic/s28322244.jpg"
        },
        "alt": "https://book.douban.com/subject/19952400/",
        "id": "19952400",
        "publisher": "人民邮电出版社",
        "isbn10": "7115293805",
        "isbn13": "9787115293800",
        "title": "算法（第4版）",
        "url": "https://api.douban.com/v2/book/19952400",
        "alt_title": "Algorithms 4th edition",
        "author_intro": "Robert Sedgewick  斯坦福大学博士，导师为Donald E. Knuth，从1985年开始一直担任普林斯顿大学计算机科学系教授，曾任该系主任，也是Adobe Systems公司董事会成员，曾在Xerox PARC、国防分析研究所（Institute for Defense Analyses）和法国国家信息与自动化研究所（INRIA）从事研究工作。他的研究方向包括解析组合学、数据结构和算法的分析与设计、程序可视化等。\nKevin Wayne  康奈尔大学博士，普林斯顿大学计算机科学系高级讲师，研究方向包括算法的设计、分析和实现，特别是图和离散优化。",
        "summary": "本书全面讲述算法和数据结构的必备知识，具有以下几大特色。\n     算法领域的经典参考书\nSedgewick畅销著作的最新版，反映了经过几十年演化而成的算法核心知识体系\n 内容全面\n全面论述排序、搜索、图处理和字符串处理的算法和数据结构，涵盖每位程序员应知应会的50种算法\n 全新修订的代码\n全新的Java实现代码，采用模块化的编程风格，所有代码均可供读者使用\n 与实际应用相结合\n在重要的科学、工程和商业应用环境下探讨算法，给出了算法的实际代码，而非同类著作常用的伪代码\n 富于智力趣味性\n简明扼要的内容，用丰富的视觉元素展示的示例，精心设计的代码，详尽的历史和科学背景知识，各种难度的练习，这一切都将使读者手不释卷\n       科学的方法\n用合适的数学模型精确地讨论算法性能，这些模型是在真实环境中得到验证的\n 与网络相结合\n配套网站algs4.cs.princeton.edu提供了本书内容的摘要及相关的代码、测试数据、编程练习、教学课件等资源",
        "series": {
          "id": "660",
          "title": "图灵程序设计丛书"
        },
        "price": "99.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "1a966e64144fb29daefee648ea37835ed5ea8fed800dc20472a7fd78784428d4",
        "file": "算法-第4版.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 153,
          "average": "8.0",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[美] Aditya Bhargava"
        ],
        "pubdate": "2017-3",
        "tags": [
          {
            "count": 160,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 78,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 65,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 46,
            "name": "Python",
            "title": "Python"
          },
          {
            "count": 36,
            "name": "初级",
            "title": "初级"
          },
          {
            "count": 24,
            "name": "Programming",
            "title": "Programming"
          },
          {
            "count": 18,
            "name": "IT",
            "title": "IT"
          },
          {
            "count": 14,
            "name": "IT类",
            "title": "IT类"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s29358625.jpg",
        "binding": "平装",
        "translator": [
          "袁国忠"
        ],
        "catalog": "第1章　算法简介　　1\n1.1　引言　　1\n1.1.1　性能方面　　1\n1.1.2　问题解决技巧　　2\n1.2　二分查找　　2\n1.2.1　更佳的查找方式　　4\n1.2.2　运行时间　　8\n1.3　大O表示法　　8\n1.3.1　算法的运行时间以不同的速度增加　　9\n1.3.2　理解不同的大O运行时间　　10\n1.3.3　大O表示法指出了最糟情况下的运行时间　　12\n1.3.4　一些常见的大O运行时间　　12\n1.3.5　旅行商　　13\n1.4　小结　　15\n第2章　选择排序　　16\n2.1　内存的工作原理　　16\n2.2　数组和链表　　18\n2.2.1　链表　　19\n2.2.2　数组　　20\n2.2.3　术语　　21\n2.2.4　在中间插入　　22\n2.2.5　删除　　23\n2.3　选择排序　　25\n2.4　小结　　28\n第3章　递归　　29\n3.1　递归　　29\n3.2　基线条件和递归条件　　32\n3.3　栈　　33\n3.3.1　调用栈　　34\n3.3.2　递归调用栈　　36\n3.4　小结　　40\n第4章　快速排序　　41\n4.1　分而治之　　41\n4.2　快速排序　　47\n4.3　再谈大O表示法　　52\n4.3.1　比较合并排序和快速排序　　53\n4.3.2　平均情况和最糟情况　　54\n4.4　小结　　57\n第5章　散列表　　58\n5.1　散列函数　　60\n5.2　应用案例　　63\n5.2.1　将散列表用于查找　　63\n5.2.2　防止重复　　64\n5.2.3　将散列表用作缓存　　66\n5.2.4　小结　　 68\n5.3　冲突　　69\n5.4　性能　　71\n5.4.1　填装因子　　72\n5.4.2　良好的散列函数　　74\n5.5　小结　　75\n第6章　广度优先搜索　　76\n6.1　图简介　　77\n6.2　图是什么　　79\n6.3　广度优先搜索　　79\n6.3.1　查找最短路径　　82\n6.3.2　队列　　 83\n6.4　实现图　　84\n6.5　实现算法　　86\n6.6　小结　　93\n第7章　狄克斯特拉算法　　94\n7.1　使用狄克斯特拉算法　　95\n7.2　术语　　98\n7.3　换钢琴　　100\n7.4　负权边　　105\n7.5　实现　　108\n7.6　小结　　116\n第8章　贪婪算法　　117\n8.1　教室调度问题　　117\n8.2　背包问题　　119\n8.3　集合覆盖问题　　121\n8.4　NP 完全问题　　127\n8.4.1　旅行商问题详解　　127\n8.4.2　如何识别NP完全问题　　131\n8.5　小结　　133\n第9章　动态规划　　134\n9.1　背包问题　　134\n9.1.1　简单算法　　135\n9.1.2　动态规划　　136\n9.2　背包问题FAQ　　143\n9.2.1　再增加一件商品将如何呢　　143\n9.2.2　行的排列顺序发生变化时结果将如何　　145\n9.2.3　可以逐列而不是逐行填充网格吗　　146\n9.2.4　增加一件更小的商品将如何呢　　146\n9.2.5　可以偷商品的一部分吗　　146\n9.2.6　旅游行程最优化　　147\n9.2.7　处理相互依赖的情况　　148\n9.2.8　计算最终的解时会涉及两\n个以上的子背包吗　　148\n9.2.9　最优解可能导致背包没装满吗　　149\n9.3　最长公共子串　　149\n9.3.1　绘制网格　　150\n9.3.2　填充网格　　151\n9.3.3　揭晓答案　　152\n9.3.4　最长公共子序列　　153\n9.3.5　最长公共子序列之解决方案　　154\n9.4　小结　　155\n第10章　K最近邻算法　　156\n10.1　橙子还是柚子　　156\n10.2　创建推荐系统　　158\n10.2.1　特征抽取　　159\n10.2.2　回归　　162\n10.2.3　挑选合适的特征　　164\n10.3　机器学习简介　　165\n10.3.1　OCR　　165\n10.3.2　创建垃圾邮件过滤器　　166\n10.3.3　预测股票市场　　167\n10.4　小结　　167\n第11章　接下来如何做　　168\n11.1　树　　168\n11.2　反向索引　　171\n11.3　傅里叶变换　　 171\n11.4　并行算法　　172\n11.5　MapReduce　　173\n11.5.1　分布式算法为何很有用　　173\n11.5.2　映射函数　　173\n11.5.3　归并函数　　174\n11.6　布隆过滤器和HyperLogLog　　174\n11.6.1　布隆过滤器　　175\n11.6.2　HyperLogLog　　176\n11.7　SHA算法　　176\n11.7.1　比较文件　　177\n11.7.2　检查密码　　178\n11.8　局部敏感的散列算法　　178\n11.9　Diffie-Hellman密钥交换　　179\n11.10　线性规划　　180\n11.11　结语　　180\n练习答案　　 181",
        "pages": "196",
        "images": {
          "small": "https://img3.doubanio.com/spic/s29358625.jpg",
          "large": "https://img3.doubanio.com/lpic/s29358625.jpg",
          "medium": "https://img3.doubanio.com/mpic/s29358625.jpg"
        },
        "alt": "https://book.douban.com/subject/26979890/",
        "id": "26979890",
        "publisher": "人民邮电出版社",
        "isbn10": "7115447632",
        "isbn13": "9787115447630",
        "title": "算法图解",
        "url": "https://api.douban.com/v2/book/26979890",
        "alt_title": "",
        "author_intro": "Aditya Bhargava\n软件工程师，兼具计算机科学和美术方面的教育背景，在adit.io撰写编程方面的博客。",
        "summary": "本书示例丰富，图文并茂，以让人容易理解的方式阐释了算法，旨在帮助程序员在日常项目中更好地发挥算法的能量。书中的前三章将帮助你打下基础，带你学习二分查找、大O表示法、两种基本的数据结构以及递归等。余下的篇幅将主要介绍应用广泛的算法，具体内容包括：面对具体问题时的解决技巧，比如，何时采用贪婪算法或动态规划；散列表的应用；图算法；K最近邻算法。",
        "series": {
          "id": "660",
          "title": "图灵程序设计丛书"
        },
        "price": "49.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "eda64163203e61ab7d77538b0021484edf20e9a5904ac39fb5a1f7ef2985d980",
        "file": "算法图解.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 178,
          "average": "8.9",
          "min": 0
        },
        "subtitle": "一种创造性方法",
        "author": [
          "[美]Udi Manber"
        ],
        "pubdate": "2005-9-1",
        "tags": [
          {
            "count": 451,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 156,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 101,
            "name": "algorithm",
            "title": "algorithm"
          },
          {
            "count": 78,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 71,
            "name": "算法设计",
            "title": "算法设计"
          },
          {
            "count": 63,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 59,
            "name": "算法、数据结构",
            "title": "算法、数据结构"
          },
          {
            "count": 41,
            "name": "数学",
            "title": "数学"
          }
        ],
        "origin_title": "Introduction to Algorithms:A Creative Approach",
        "image": "https://img3.doubanio.com/mpic/s1755236.jpg",
        "binding": "平装",
        "translator": [
          "黄林鹏",
          "谢瑾奎",
          "陆首博",
          "等"
        ],
        "catalog": "第1章 引论\n第2章　数学归纳法\n2.1 引言\n2.2　三个简单的例子\n2.3　平面内区域的计数\n2.4　简单的着色问题\n2.5　复杂一些的加法题\n2.6　一个简单的不等式\n2.7　欧拉公式\n2.8　图论中的一个问题\n2.9　格雷码\n2.10　在图上寻找无重边的路\n2.11　数学平均数和几何平均数定理\n2.12　循环不变量：将十进制数转换为二进制数\n2.13　常见的错误\n2.14　小结\n第3章　算法分析\n3.1　引言\n3.2　符号O\n3.3　时间与空间复杂度\n3.4　习之和\n3.5　递推关系\n3.5.1　巧妙地猜测\n3.5.2　分治关系\n3.5.3　涉及全部历史的递推关系\n3.6　一些有用的证明论据\n3.7　小结\n第4章　数据结构简介\n4.1 引言\n4.2　基本数据结构\n4.2.1　元素\n4.2.2　数组\n4.2.3　记录\n4.2.4　链表\n4.3　树\n4.3.1 树的表示\n4.3.2　堆\n4.3.3　二叉搜索树\n4.3.4　AVL树\n4.4　散列\n4.5　合并碴找问题\n4.6 图\n4.7　小结\n第5章　基于归纳的算法设计\n5.1 引言\n5.2　多项式求值\n5.3　最大导出子图\n5.4　寻找一对一映射\n5.5　社会名流问题\n5.6　分治算法：轮廓问题\n5.7　在二叉树中计算平衡因子\n5.8　寻找最大连续子序列\n5.9　增强归纳假设\n5.10　动态规划：背包问题\n5.11　常见的错误\n5.12　小结\n第6章　序列和集合的算法\n6.1 引言\n6.2　二叉搜索的几种形式\n6.2.1 纯二叉搜索\n6.2.2　循环序列的二叉搜索\n6.2.3　二叉搜索特殊下标\n6.2.4　二叉搜索长度未知的序列\n6.2.5　重叠子序列问题\n6.2.6　解方程\n6.3 内插搜索\n6.4　排序\n6.4.1　桶排序和基数排序\n6.4.2　插入排序和选择排序\n6.4.3　归并排序\n6.4.4　快速排序\n6.4.5　堆排序\n……\n第7章　图算法\n第8章　几何算法\n第9章　代数和数值算法\n第10章　归约\n第11章　NP完全问题\n第12章　并行算法\n部分习题答案\n参考文献",
        "pages": "334",
        "images": {
          "small": "https://img3.doubanio.com/spic/s1755236.jpg",
          "large": "https://img3.doubanio.com/lpic/s1755236.jpg",
          "medium": "https://img3.doubanio.com/mpic/s1755236.jpg"
        },
        "alt": "https://book.douban.com/subject/1436134/",
        "id": "1436134",
        "publisher": "电子工业出版社",
        "isbn10": "7121016656",
        "isbn13": "9787121016653",
        "title": "算法引论",
        "url": "https://api.douban.com/v2/book/1436134",
        "alt_title": "Introduction to Algorithms:A Creative Approach",
        "author_intro": "Udi Manber\n美国著名的计算机科学家，国际公认的算法大师，在线信息搜索引擎的先驱。1982年于华盛顿大学获得计算机科学博士学位，曾是美国亚利桑那大学计算机专业教授。离开学校后在雅虎公司担任执行官，闫前是亚马逊（Amazon.com）的副总裁和首席算法师（CAO），也是亚马逊旗下搜索网站A9.corn的首席执行官。他提出的UDI测试已经成为衡量搜索引擎质量的评估标准。",
        "summary": "本书是国际算法大师乌迪·曼博（Udi Manber）博士撰写的一本享有盛誉的著作。全书共分12章：第1章到第4章为介绍性内容，涉及数学归纳法、算法分析、数据结构等内容；第5章提出了与归纳证明进行类比的算法设计思想；第6章到第9章分别给出了4个领域的算法，如序列和集合的算法、图算法、几何算法、代数和数值算法；第10章涉及归约，也是第11章的序幕，而后者涉及NP完全问题；第12章则介绍了并行算法；最后是部分习题的答案及参考文献。本书的特色有二，旨在提高读者的问题求解能力，使读者能够理解算法设计的过程和思想：一是强调算法设计的创造性过程，注重算法设计背后的创造性思想，而不拘泥于某个具体算法的详细讨论；二是将算法设计类比于定理归纳证明，揭示了算法设计的基本思想和本质。\n本书的组织结构清晰且易于理解，强调了创造性，具有浓郁特色，时至今日仍有其巨大的价值，并且适合作为计算机及相关专业算法和高级算法课程的教材。",
        "series": {
          "id": "35164",
          "title": "国外计算机科学教材系列"
        },
        "price": "35.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "cc6f545b84ec6999dbe9b88445a8cd7f20c36b19b13b18e30bbd48f2a9fb7d44",
        "file": "算法引论：一种创造性方法(扫描,无书签).pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 40,
          "average": "9.2",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "刘新宇"
        ],
        "pubdate": "2016-12-1",
        "tags": [
          {
            "count": 268,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 77,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 67,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 37,
            "name": "函数式编程",
            "title": "函数式编程"
          },
          {
            "count": 35,
            "name": "Algorithm",
            "title": "Algorithm"
          },
          {
            "count": 31,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 30,
            "name": "algorithm",
            "title": "algorithm"
          },
          {
            "count": 24,
            "name": "程序设计",
            "title": "程序设计"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/view/subject/m/public/s29205454.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "第一部分　　树\n第1章　二叉搜索树：数据结构中的“hello world”　　3\n1.1 　定义　　3\n1.2 　数据组织　　5\n1.3 　插入　　6\n1.4 　遍历　　8\n1.5 　搜索　　10\n1.5.1 　lookup　　10\n1.5.2 　最小元素和最大元素　　11\n1.5.3 　前驱和后继　　12\n1.6 　删除　　14\n1.7 　随机构建二叉搜索树　　18\n第2章　插入排序的进化　　19\n2.1 　简介　　19\n2.2 　插入　　20\n2.3 　改进一：二分查找　　20\n2.4 　改进二：使用链表　　22\n2.5 　使用二叉搜索树的最终改进　　26\n2.6 　小结　　27\n第3章　并不复杂的红黑树　　28\n3.1 　红黑树的定义　　32\n3.2 　插入　　33\n3.3 　删除　　36\n3.4 　命令式的红黑树算法?*　　44\n3.5 　小结　　47\n第4章　AVL树　　48\n4.1 　AVL树的定义　　48\n4.2 　插入　　51\n4.2.1 　平衡调整　　53\n4.2.2 　模式匹配　　57\n4.3 　删除　　59\n4.4 　AVL树的命令式算法?*　　59\n4.5 　小结　　63\n第5章　基数树：Trie和Patricia　　65\n5.1 　整数Trie　　65\n5.1.1 　整数Trie的定义　　67\n5.1.2 　插入　　67\n5.1.3 　查找　　69\n5.2 　整数Patricia　　70\n5.2.1 　定义　　71\n5.2.2 　插入　　72\n5.2.3 　查找　　78\n5.3 　字符Trie　　80\n5.3.1 　定义　　80\n5.3.2 　插入　　81\n5.3.3 　查找　　83\n5.4 　字符Patricia　　84\n5.4.1 　定义　　84\n5.4.2 　插入　　85\n5.4.3 　查找　　90\n5.5 　Trie和Patricia的应用　　92\n5.5.1 　电子词典和单词自动补齐　　92\n5.5.2 　T9输入法　　97\n5.6 　小结　　102\n第6章　后缀树　　103\n6.1 　后缀Trie　　104\n6.1.1 　节点转移和后缀链接　　105\n6.1.2 　on-line构造　　107\n6.2 　后缀树　　111\n6.3 　后缀树的应用　　121\n6.3.1 　字符串搜索和模式匹配　　121\n6.3.2 　查找最长重复子串　　123\n6.3.3 　查找最长公共子串　　125\n6.3.4 　查找最长回文　　127\n6.3.5 　其他　　128\n6.4 　小结　　128\n第7章　B树　　129\n7.1 　插入　　131\n7.2 　删除　　139\n7.2.1 　删除前预合并　　139\n7.2.2 　先删除再修复　　139\n7.3 　搜索　　153\n7.4 　小结　　155\n第二部分 堆\n第8章　二叉堆　　159\n8.1 　用数组实现隐式二叉堆　　159\n8.1.1 　定义　　159\n8.1.2 　Heapify　　160\n8.1.3 　构造堆　　163\n8.1.4 　堆的基本操作　　164\n8.1.5 　堆排序　　168\n8.2 　左偏堆和skew堆:显式的二叉堆　　169\n8.2.1 　定义　　170\n8.2.2 　合并　　172\n8.2.3 　基本堆操作　　173\n8.2.4 　使用左偏堆实现堆排序　　174\n8.2.5 　skew堆　　174\n8.3 　伸展堆　　177\n8.3.1 　定义　　177\n8.3.2 　堆排序　　183\n8.4 　小结　　183\n第9章　从吃葡萄到世界杯：选择排序的进化　　184\n9.1 　查找最小元素　　186\n9.1.1 　标记　　186\n9.1.2 　分组　　188\n9.1.3 　选择排序的性能　　189\n9.2 　细微改进　　190\n9.2.1 　比较方法参数化　　190\n9.2.2 　细微调整　　191\n9.2.3 　鸡尾酒排序　　192\n9.3 　本质改进　　196\n9.3.1 　锦标赛淘汰法　　196\n9.3.2 　使用堆排序进行最后的改进　　204\n9.4 　小结　　204\n第10章　二项式堆、斐波那契堆和配对堆　　205\n10.1 　二项式堆　　205\n10.1.1 　定义　　205\n10.1.2 　基本的堆操作　　209\n10.2 　斐波那契堆　　220\n10.2.1 　定义　　220\n10.2.2 　基本堆操作　　221\n10.2.3 　弹出操作的性能分析　　230\n10.2.4 　减小key　　232\n10.2.5 　“斐波那契堆”名字的由来　　234\n10.3 　配对堆　　237\n10.3.1 　定义　　237\n10.3.2 　基本堆操作　　238\n10.4 　小结　　244\n第三部分 队列和序列\n第11章　并不简单的队列　　247\n11.1 　单向链表和循环缓冲区实现的队列　　247\n11.1.1 　单向链表实现　　247\n11.1.2 　循环缓冲区实现　　251\n11.2 　纯函数式实现　　253\n11.2.1 　双列表队列　　254\n11.2.2 　双数组队列：一种对称实现　　255\n11.3 　小改进：平衡队列　　257\n11.4 　进一步改进：实时队列　　259\n11.5 　惰性实时队列　　266\n11.6 　小结　　269\n第12章　序列：最后一块砖　　271\n12.1 　二叉随机访问列表　　271\n12.1.1 　普通数组和列表　　271\n12.1.2 　使用森林表示序列　　272\n12.1.3 　在序列的头部插入　　273\n12.2 　二叉随机访问列表的数值表示　　279\n12.3 　命令式双数组列表　　285\n12.3.1 　定义　　285\n12.3.2 　插入和添加　　286\n12.3.3 　随机访问　　286\n12.3.4 　删除和平衡　　287\n12.4 　可连接列表　　289\n12.5 　手指树　　293\n12.5.1 　定义　　293\n12.5.2 　向序列的头部插入元素　　295\n12.5.3 　从头部删除元素　　298\n12.5.4 　删除时处理不规则的手指树　　300\n12.5.5 　在序列的尾部添加元素　　304\n12.5.6 　从尾部删除元素　　306\n12.5.7 　连接　　307\n12.5.8 　手指树的随机访问　　312\n12.6 　小结　　325\n第四部分 排序和搜索\n第13章　分而治之：快速排序和归并排序　　329\n13.1 　快速排序　　329\n13.1.1 　基本形式　　330\n13.1.2 　严格弱序　　331\n13.1.3 　划分　　331\n13.1.4 　函数式划分算法的小改进　　335\n13.2 　快速排序的性能分析　　337\n13.3 　工程实践中的改进　　340\n13.4 　针对最差情况的工程实践　　348\n13.5 　其他工程实践　　351\n13.6 　其他　　351\n13.7 　归并排序　　352\n13.8 　原地归并排序　　360\n13.8.1 　死板原地归并　　360\n13.8.2 　原地工作区　　362\n13.8.3 　原地归并排序与链表归并排序　　366\n13.9 　自然归并排序　　368\n13.10 　自底向上归并排序　　374\n13.11 　并行处理　　377\n13.12 　小结　　377\n第14章　搜索　　379\n14.1 　序列搜索　　379\n14.1.1 　分而治之的搜索　　379\n14.1.2 　信息复用　　400\n14.2 　解的搜索　　428\n14.2.1 　深度优先搜索和广度优先搜索　　428\n14.2.2 　搜索最优解　　468\n14.3 　小结　　498\n附录 列表　　500\n列表的定义　　500\n列表的基本操作　　502\n变换　　527\n提取子列表　　536\nfold　　543\n搜索和匹配　　549\nzip和unzip　　555\n小结　　558\n参考文献　　559\n索引　　563",
        "pages": "566",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s29205454.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s29205454.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s29205454.jpg"
        },
        "alt": "https://book.douban.com/subject/26931430/",
        "id": "26931430",
        "publisher": "人民邮电出版社",
        "isbn10": "7115440352",
        "isbn13": "9787115440358",
        "title": "算法新解",
        "url": "https://api.douban.com/v2/book/26931430",
        "alt_title": "",
        "author_intro": "刘新宇\n1999年和2001年分别获得清华大学自动化系学士和硕士学位，之后长期从事软件研发工作。他关注基本算法和数据结构，尤其是函数式算法，目前就职于亚马逊中国仓储和物流技术团队。",
        "summary": "本书分4 部分，同时用函数式和传统方法介绍主要的基本算法和数据结构。数据结构部分包括二叉树、红黑树、AVL 树、Trie、Patricia、后缀树、B 树、二叉堆、二项式堆、斐波那契堆、配对堆、队列、序列等；基本算法部分包括各种排序算法、序列搜索算法、字符串匹配算法（KMP 等）、深度优先与广度优先搜索算法、贪心算法以及动态规划。\n本书适合软件开发人员、编程和算法爱好者，以及高校学生阅读参考。",
        "series": {
          "id": "13000",
          "title": "图灵原创"
        },
        "price": "CNY 99.00",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "fce19f62e67fde7f7cadefed71f3dd5f261a328120ee8341a0795843d650defe",
        "file": "算法新解.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 32,
          "average": "8.8",
          "min": 0
        },
        "subtitle": "第3版",
        "author": [
          "Anany Levitin"
        ],
        "pubdate": "2015-2-1",
        "tags": [
          {
            "count": 102,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 24,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 23,
            "name": "数据结构与算法",
            "title": "数据结构与算法"
          },
          {
            "count": 15,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 15,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 9,
            "name": "算法及数据结构",
            "title": "算法及数据结构"
          },
          {
            "count": 8,
            "name": "algorithms",
            "title": "algorithms"
          },
          {
            "count": 6,
            "name": "大学",
            "title": "大学"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s28019832.jpg",
        "binding": "平装",
        "translator": [
          "潘彦"
        ],
        "catalog": "目录\n第1章绪论\n1.1什么是算法\n习题1.1\n1.2算法问题求解基础\n1.2.1理解问题\n1.2.2了解计算设备的性能\n1.2.3在精确解法和近似解法之间做出选择\n1.2.4算法的设计技术\n1.2.5确定适当的数据结构\n1.2.6算法的描述\n1.2.7算法的正确性证明\n1.2.8算法的分析\n1.2.9为算法写代码\n习题1.2\n1.3重要的问题类型\n1.3.1排序\n1.3.2查找\n1.3.3字符串处理\n1.3.4图问题\n1.3.5组合问题\n1.3.6几何问题\n1.3.7数值问题\n习题1.3\n1.4基本数据结构\n1.4.1线性数据结构\n1.4.2图\n1.4.3树\n1.4.4集合与字典\n习题1.4\n小结\n第2章算法效率分析基础\n2.1分析框架\n2.1.1输入规模的度量\n2.1.2运行时间的度量单位\n2.1.3增长次数\n2.1.4算法的最优、最差和平均效率\n2.1.5分析框架概要\n习题2.1\n2.2渐近符号和基本效率类型\n2.2.1非正式的介绍\n2.2.2符号O\n2.2.3符号Q\n2.2.4符号θ\n2.2.5渐近符号的有用特性\n2.2.6利用极限比较增长次数\n2.2.7基本的效率类型\n习题2.2\n2.3非递归算法的数学分析\n习题2.3\n2.4递归算法的数学分析\n习题2.4\n2.5例题：计算第n个斐波那契数\n习题2.5\n2.6算法的经验分析\n习题2.6\n2.7算法可视法\n小结\n第3章蛮力法\n3.1选择排序和冒泡排序\n3.1.1选择排序\n3.1.2冒泡排序\n习题3.1\n3.2顺序查找和蛮力字符串匹配\n3.2.1顺序查找\n3.2.2蛮力字符串匹配\n习题3.2\n3.3最近对和凸包问题的蛮力算法\n3.3.1最近对问题\n3.3.2凸包问题\n习题3.3\n3.4穷举查找\n3.4.1旅行商问题\n3.4.2背包问题\n3.4.3分配问题\n习题3.4\n3.5深度优先查找和广度优先查找\n3.5.1深度优先查找\n3.5.2广度优先查找\n习题3.5\n小结\n第4章减治法\n4.1插入排序\n习题4.1\n4.2拓扑排序\n习题4.2\n4.3生成组合对象的算法\n4.3.1生成排列\n4.3.2生成子集\n习题4.3\n4.4减常因子算法\n4.4.1折半查找\n4.4.2假币问题\n4.4.3俄式乘法\n4.4.4约瑟夫斯问题\n习题4.4\n4.5减可变规模算法\n4.5.1计算中值和选择问题\n4.5.2插值查找\n4.5.3二叉查找树的查找和插入\n4.5.4拈游戏\n习题4.5\n小结\n第5章分治法\n5.1合并排序\n习题5.1\n5.2快速排序\n习题5.2\n5.3二叉树遍历及其相关特性\n习题5.3\n5.4大整数乘法和Strassen矩阵乘法\n5.4.1大整数乘法\n5.4.2Strassen矩阵乘法\n习题5.4\n5.5用分治法解最近对问题和凸包问题\n5.5.1最近对问题\n5.5.2凸包问题\n习题5.5\n小结\n第6章变治法\n6.1预排序\n习题6.1\n6.2高斯消去法\n6.2.1LU分解\n6.2.2计算矩阵的逆\n6.2.3计算矩阵的行列式\n习题6.2\n6.3平衡查找树\n6.3.1AVL树\n6.3.22—3树\n习题6.3\n6.4堆和堆排序\n6.4.1堆的概念\n6.4.2堆排序\n习题6.4\n6.5霍纳法则和二进制幂\n6.5.1霍纳法则\n6.5.2二进制幂\n习题6.5\n6.6问题化简\n6.6.1求最小公倍数\n6.6.2计算图中的路径数量\n6.6.3优化问题的化简\n6.6.4线性规划\n6.6.5简化为图问题\n习题6.6\n小结\n第7章时空权衡\n7.1计数排序\n习题7.1\n7.2字符串匹配中的输入增强技术\n7.2.1Horspool算法\n7.2.2Boyer—Moore算法\n习题7.2\n7.3散列法\n7.3.1开散列（分离链）\n7.3.2闭散列（开式寻址）\n习题7.3\n7.4B树\n习题7.4\n小结\n第8章动态规划\n8.1三个基本例子\n习题8.1\n8.2背包问题和记忆功能\n8.2.1背包问题\n8.2.2记忆化\n习题8_2\n8.3最优二叉查找树\n习题8.3\n8.4Warshall算法和Floyd算法\n8.4.1Warshall算法\n8.4.2计算完全最短路径的Floyd算法\n习题8.4\n小结\n第9章贪婪技术\n9.1Prim算法\n习题9.1\n9.2Kruskal算法\n习题9.2\n9.3Diikstra算法\n习题9.3\n9.4哈夫曼树及编码\n习题9.4\n小结\n第10章迭代改进\n10.1单纯形法\n10.1.1线性规划的几何解释\n10.1.2单纯形法概述\n10.1.3单纯形法其他要点\n习题10.1\n10.2最大流量问题\n习题10.2\n10.3二分图的虽大匹配\n习题10.3\n10.4稳定婚姻问题\n习题10.4\n小结\n第11章算法能力的极限\n11.1如何求下界\n11.1.1平凡下界\n11.1.2信息论下界\n11.1.3敌手下界\n11.1.4问题化简\n习题11.1\n11.2决策树\n11.2.1排序的决策树\n11.2.2查找有序数组的决策树\n习题11.2\n11.3P、NP和NP完全问题\n11.3.1P和NP问题\n11.3.2NP完全问题\n习题11.3\n11.4数值算法的挑战\n习题11.4\n小结\n第12章超越算法能力的极限\n12.1回溯法\n12.1.1n皇后问题\n12.1.2哈密顿回路问题\n12.1.3子集和问题\n12.1.4一般性说明\n习题12.1\n12.2分支界限法\n12.2.1分配问题\n12.2.2背包问题\n12.2.3旅行商问题\n习题12.2\n12.3NP困难问题的近似算法\n12.3.1旅行商问题的近似算法\n12.3.2背包问题的近似算法\n习题12.3\n12.4解非线性方程的算法\n12.4.1平分法\n12.4.2试位法\n12.4.3牛顿法\n习题12.4\n小结\n跋\n附录A算法分析的实用公式\n附录B递推关系简明指南\n习题提示\n参考文献",
        "pages": "423",
        "images": {
          "small": "https://img3.doubanio.com/spic/s28019832.jpg",
          "large": "https://img3.doubanio.com/lpic/s28019832.jpg",
          "medium": "https://img3.doubanio.com/mpic/s28019832.jpg"
        },
        "alt": "https://book.douban.com/subject/26337727/",
        "id": "26337727",
        "publisher": "清华大学出版社",
        "isbn10": "730238634X",
        "isbn13": "9787302386346",
        "title": "算法设计与分析基础(第3版)",
        "url": "https://api.douban.com/v2/book/26337727",
        "alt_title": "",
        "author_intro": "作者：（美国）莱维汀（Anany Levitin） 译者：潘彦",
        "summary": "作者基于丰富的教学经验，开发了一套全新的算法分类方法。该分类法站在通用问题求解策略的高度，对现有大多数算法准确分类，从而引领读者沿着一条清晰、一致、连贯的思路来探索算法设计与分析这一迷人领域。《算法设计与分析基础(第3版)》作为第3版，相对前版调整了多个章节的内容和顺序，同时增加了一些算法，并扩展了算法的应用，使得具体算法和通用算法设计技术的对应更加清晰有序；各章累计增加了70道习题，其中包括一些有趣的谜题和面试问题。《算法设计与分析基础(第3版)》十分适合用作算法设计和分析的基础教材，也适合任何有兴趣探究算法奥秘的读者使用，只要读者具备数据结构和离散数学的知识即可。",
        "price": "69.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "8b2aee04a5d58ca47274f5695d6ca0e92fe1e431f0953d0e147f1ec44bf05dec",
        "file": "算法设计与分析基础.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 13,
          "average": "7.8",
          "min": 0
        },
        "subtitle": "本科教学版 第2版",
        "author": [
          "Alfred V. Aho",
          "Monica S. Lam",
          "Ravi Sethi",
          "Jeffrey D. Ullman"
        ],
        "pubdate": "2009-5",
        "tags": [
          {
            "count": 7,
            "name": "编译原理",
            "title": "编译原理"
          },
          {
            "count": 5,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 2,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 2,
            "name": "CS",
            "title": "CS"
          },
          {
            "count": 1,
            "name": "教科书",
            "title": "教科书"
          },
          {
            "count": 1,
            "name": "教材",
            "title": "教材"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/mpic/s24398698.jpg",
        "binding": "",
        "translator": [
          "赵建华",
          "郑涛",
          "戴新宇"
        ],
        "catalog": "出版者的话\n改编者序\n前言\n第1章 引论\n1．1 语言处理器\n1．2 一个编译器的结构\n1．2．1 词法分析\n1．2．2 语法分析\n1．2．3 语义分析\n1．2．4 中间代码生成\n1．2．5 代码优化\n1．2．6 代码生成\n1．2．7 符号表管理\n1．2．8 将多个步骤组合成趟\n1．2．9 编译器构造工具\n1．3 程序设计语言的发展历程\n1．3．1 走向高级程序设计语言\n1．3．2 对编译器的影响\n1．3．3 1．3节的练习\n1．4 构建一个编译器的相关科学\n1．4．1 编译器设计和实现中的建模\n1．4．2 代码优化的科学\n1．5 编译技术的应用\n1．5．1 高级程序设计语言的实现\n1．5．2 针对计算机体系结构的优化\n1．5．3 新计算机体系结构的设计\n1．5．4 程序翻译\n1．5．5 软件生产率工具\n1．6 程序设计语言基础\n1．6．1 静态和动态的区别\n1．6．2 环境与状态\n1．6．3 静态作用域和块结构\n1．6．4 显式访问控制\n1．6．5 动态作用域\n1．6．6 参数传递机制\n1．6．7 别名\n1．6．8 1．6节的练习\n1．7 第1章总结\n1．8 第1章参考文献\n第2章 一个简单的语法制导翻译器\n2．1 引言\n2．2 语法定义\n2．2．1 文法定义\n2．2．2 推导\n2．2．3 语法分析树\n2．2．4 二义性\n2．2．5 运算符的结合性\n2．2．6 运算符的优先级\n2．2．7 2．2节的练习\n2．3 语法制导翻译\n2．3．1 后缀表示\n2．3．2 综合属性\n2．3．3 简单语法制导定义\n2．3．4 树的遍历\n2．3．5 翻译方案\n2．3．6 2．3节的练习\n2．4 语法分析\n2．4．1 自顶向下分析方法\n2．4．2 预测分析法\n2．4．3 何时使用产生式\n2．4．4 设计一个预测分析器\n2．4．5 左递归\n2．4．6 2．4节的练习\n2．5 简单表达式的翻译器\n2．5．1 抽象语法和具体语法\n2．5．2 调整翻译方案\n2．5．3 非终结符号的过程\n2．5．4 翻译器的简化\n2．5．5 完整的程序\n2．6 词法分析\n2．6．1 剔除空白和注释\n2．6．2 预读\n2．6．3 常量\n2．6．4 识别关键字和标识符\n2．6．5 词法分析器\n2．6．6 2．6节的练习\n2．7 符号表\n2．7．1 为每个作用域设置一个符号表\n2．7．2 符号表的使用\n2．8 生成中间代码\n2．8．1 两种中间表示形式\n2．8．2 语法树的构造\n2．8．3 静态检查\n2．8．4 三地址码\n2．8．5 2．8节的练习\n2．9 第2章总结\n2．5．5 完整的程序\n2．6 词法分析\n2．6．1 剔除空白和注释\n2．6．2 预读\n2．6．3 常量\n2．6．4 识别关键字和标识符\n2．6．5 词法分析器\n2．6．6 2．6节的练习\n2．7 符号表\n2．7．1 为每个作用域设置—个符号表\n2．7．2 符号表的使用\n2．8 生成中间代码\n2．8．1 两种中间表示形式\n2．8．2 语法树的构造\n2．8．3 静态检查\n2．8．4 三地址码\n2．8．5 2．8节的练习\n2．9 第2章总结\n第3章 词法分析\n3．1 词法分析器的作用\n3．1．1 词法分析及语法分析\n3．1．2 词法单元、模式和词素\n3．1．3 词法单元的属性\n3．1．4 词法错误\n3．1．5 3．1节的练习\n3．2 词法单元的规约\n3．2．1 串和语言\n3．2．2 语言上的运算\n3．2．3 正则表达式\n3．2．4 正则定义\n3．2．5 正则表达式的扩展\n3．2．6 3．2 节的练习\n3．3 词法单元的识别\n3．3．1 状态转换图\n3．3．2 保留字和标识符的识别\n3．3．3 完成我们的例子\n3．3．4 基于状态转换图的词法分析器的体系结构\n3．3．5 3．3 节的练习\n3．4 词法分析器生成工具Lex\n3．4．1 Lex的使用\n3．4．2 Lex程序的结构\n3．4．3 Lex中的冲突解决\n3．4．4 向前看运算符\n3．4．5 3．4节的练习\n3．5 有穷自动机\n3．5．1 不确定的有穷自动机\n3．5．2 转换表\n3．5．3 自动机中输入字符串的接受\n3．5．4 确定的有穷自动机\n3．5．5 3．5节的练习\n3．6 从正则表达式到自动机\n3．6．1 从NFA到DFA的转换\n3．6．2 最小化一个DFA的状态数\n3．6．3 从正则表达式构造NFA\n3．6．4 字符串处理算法的效率\n3．6．5 3．6节的练习\n3．7 词法分析器生成工具的设计\n3．7．1 生成的词法分析器的结构\n3．7．2 词法分析器使用的DFA\n3．7．3 词法分析器的状态最小化\n3．7．4 实现向前看运算符\n3．7．5 3．7节的练习\n3．8 第3章总结\n3．9 第3章参考文献\n夥4章 语法分析\n4．1 引论\n4．1．1 语法分析器的作用\n4．1．2 代表性的文法\n4．1．3 语法错误的处理\n4．1．4 错误恢复策略\n4．2 上下文无关文法\n4．2．1 上下文无关文法的正式定义\n4．2．2 符号表示的约定\n4．2．3 推导\n4．2．4 语法分析树和推导\n4．2．5 二义性\n4．2．6 验证文法生成的语言\n4．2．7 上下文无关文法和正则表达式\n4．2．8 4．2节的练习\n4．3 设计文法\n4．3．1 词法分析和语法分析\n4．3．2 消除二义性\n4．3．3 左递归的消除\n4．3．4 提取左公因子\n4．3．5 非上下文无关语言的构造\n4．3．6 4．3节的练习\n4．4 自顶向下的语法分析\n4．4．1 递归下降的语法分析\n4．4．2 FIRST和FOLLOW\n4．4．3 LL(1)文法\n4．4．4 非递归的预测分析\n4．4．5 预测分析中的错误恢复\n4．4．6 4．4节的练习\n4．5 自底向上的语法分析\n4．5．1 归约\n4．5．2 句柄剪枝\n4．5．3 移人一归约语法分析技术\n4．5．4 移入一归约语法分析中的冲突\n4．5．5 4．5节的练习\n4．6 LR语法分析技术介绍：简单LR技术\n4．6．1 为什么使用LR语法分析器\n4．6．2 项和LR(0)自动机\n4．6．3 LR语法分析算法\n4．6．4 构造SLR语法分析表\n4．6．5 可行前缀\n4．6．6 4．6节的练习\n4．7 更强大的LR语法分析器\n4．7．1 规范LR(1)项\n4．7．2 构造LR(1)项集\n4．7．3 规范LR(1)语法分析表\n4．7．4 构造LALR语法分析表\n4．7．5 高效构造LALR语法分析表的方法\n4．7．6 4．7节的练习\n4．8 使用二义性文法\n4．8．1 用优先级和结合性解决冲突\n4．8．2 “悬空=else”的二义性\n4．8．3 LR语法分析中的错误恢复\n4．8．4 4．8节的练习\n4．9 语法分析器生成工具\n4．9．1 语法分析器生成工具Yacc\n4．9．2 使用带有二义性文法的Yacc规约\n4．9．3 用Lex创建Yacc的词法分析器\n4．9．4 Yacc中的错误恢复\n4．9．5 4．9节的练习\n4．10 第4章总结\n4．11 第4章参考文献\n第5章 语法制导的翻译\n第6章 中间代码生成\n第7章 运行时刻环境\n第8章 代码生成\n第9章 机器无关优化\n附录 一个完整的编译器前端",
        "pages": "412",
        "images": {
          "small": "https://img1.doubanio.com/spic/s24398698.jpg",
          "large": "https://img1.doubanio.com/lpic/s24398698.jpg",
          "medium": "https://img1.doubanio.com/mpic/s24398698.jpg"
        },
        "alt": "https://book.douban.com/subject/3774682/",
        "id": "3774682",
        "publisher": "机械工业",
        "isbn10": "7111269292",
        "isbn13": "9787111269298",
        "title": "编译原理",
        "url": "https://api.douban.com/v2/book/3774682",
        "alt_title": "",
        "author_intro": "作者：(美国) 阿霍 (Aho.A.V.)等 等 译者：赵建华 郑滔 戴新宇\nAlfred V．Aho，博士是哥伦比亚大学计算机科学系主管本科生教学的副主任，tEEEFe，10w，美国科学与艺术学院及国家工程学院院士，曾获得IEEE的冯·诺伊曼奖。他是《编译原理》(Compiler：Principles，Techniques，andTools)的第一作者。他目前的研究方向为量子计算、程式设计语言．编译器和算法等。\nRavi Sethi，Avaya实验室总裁，曾任贝尔实验室高级副总裁和Lucent Technologies通信软件的CTO。他曾在宾夕法尼亚州立大学，亚利桑那州立大学和普林斯顿大学任教，是ACM会士。\nMonica S．Lam，斯坦福大学计算机科学系教授，曾任Tensilica的首席科学家，也是Moka5的首任CEO。曾经主持SUIF项目，该项目产生了最流行的研究用编译器之一。",
        "summary": "《编译原理(本科教学版第2版)》基于该书第2版进行改编，内容更加精练和实用，体系更加符合国内教学情况，适合作为高等院校计算机及相关专业本科生的编译原理课程的教材，也是广大研究人员和技术人员的极佳参考读物。\n《编译原理(本科教学版第2版)》是编译领域无可替代的经典著作，被广大计算机专业人士誉为“龙书”。《编译原理(本科教学版第2版)》上一版自1986年出版以来，被世界各地的著名高等院校和研究机构(包括美国哥伦比亚大学。斯坦福大学、哈佛大学、普林斯顿大学。贝尔实验室)作为本科生和研究生的编译原理课程的教材。该书对我国高等计算机教育领域也产生了重大影响。\n第2版对每一章都进行了全面的修订，以反映自上一版出版20多年来软件工程、程序设计语言和计算机体系结构方面的发展对编译技术的影响。第2版全面介绍了编译器的设计，并强调编译技术在软件设计和开发中的广泛应用。每章中都包含大量的习题和丰富的参考文献。\n《编译原理(本科教学版第2版)》基于该书第2版进行改编，保留其中的基本内容，压缩或删除了一些高级内容，更适合作为国内高校计算机及相关专业本科生编译原理课程教材。",
        "series": {
          "id": "1163",
          "title": "计算机科学丛书"
        },
        "price": "55.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "820c0ec5c9fd0d2a368e5c642fa9110907d51f798eb6215ccd0819d097fc0690",
        "file": "编译原理-第二版.pdf"
      }
    ]
  },
  {
    "dir_name": "android",
    "name": "安卓",
    "books": [
      {
        "title_sort": "更上一层楼－Android研发工程师高级进阶",
        "timestamp": "2017-08-29T14:34:52.974955+00:00",
        "publisher": "GitBook",
        "description": "原文链接：http://www.bignerdranch.com/blog/what-is-functional-reactive-programming/",
        "language": "zh",
        "creator": "asce1885",
        "title": "更上一层楼－Android研发工程师高级进阶",
        "date": "2015-04-29T12:07:16.232986+00:00",
        "contributor": "calibre (3.7.0) [https://calibre-ebook.com]",
        "identifier": {
          "mobi-asin": "67c1ea7c-7f50-439f-9c8d-645b26ba1f16",
          "uuid": "5532a7f0-fab3-457b-9ac3-adea053ce8ce",
          "calibre": "5532a7f0-fab3-457b-9ac3-adea053ce8ce"
        },
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "8a61158889a94d3c98249f5cc349ae0d43b95f90d59f9bc73a467a60facfee48",
        "file": "Android研发工程师高级进阶.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 10,
          "average": "6.9",
          "min": 0
        },
        "subtitle": "Android程序员面试宝典",
        "author": [
          "李宁"
        ],
        "pubdate": "2012-5",
        "tags": [
          {
            "count": 13,
            "name": "Android",
            "title": "Android"
          },
          {
            "count": 8,
            "name": "面试",
            "title": "面试"
          },
          {
            "count": 2,
            "name": "程序员",
            "title": "程序员"
          },
          {
            "count": 2,
            "name": "移动开发",
            "title": "移动开发"
          },
          {
            "count": 2,
            "name": "android",
            "title": "android"
          },
          {
            "count": 2,
            "name": "Android高薪之路",
            "title": "Android高薪之路"
          },
          {
            "count": 1,
            "name": "高薪之路",
            "title": "高薪之路"
          },
          {
            "count": 1,
            "name": "计算机技术",
            "title": "计算机技术"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/mpic/s24401108.jpg",
        "binding": "",
        "translator": [],
        "catalog": "",
        "ebook_url": "https://read.douban.com/ebook/13056173/",
        "pages": "294",
        "images": {
          "small": "https://img1.doubanio.com/spic/s24401108.jpg",
          "large": "https://img1.doubanio.com/lpic/s24401108.jpg",
          "medium": "https://img1.doubanio.com/mpic/s24401108.jpg"
        },
        "alt": "https://book.douban.com/subject/10582508/",
        "id": "10582508",
        "publisher": "",
        "isbn10": "7115275114",
        "isbn13": "9787115275110",
        "title": "Android高薪之路",
        "url": "https://api.douban.com/v2/book/10582508",
        "alt_title": "",
        "author_intro": "",
        "summary": "《Android高薪之路:Android程序员面试宝典》取材于各大IT公司面试真题，所给出的试题尽可能地覆盖了Android应用开发的各个方面，而且大多数试题都有解析部分，读者可以通过这部分更深入地理解试题中所包含的技术内容，希望真正做到由点成线，举一反三。《Android高薪之路:Android程序员面试宝典》中还将Android中涉及的各个常用技术问题进行筛选、分类。这样读者可以有的放矢，对自己还没有掌握的Android技术进行重点攻破，从而起到事半功倍的效果。除了对每道题目都有详细的解析和回答外，对相关知识点还有扩展说明。《Android高薪之路:Android程序员面试宝典》对面试中Android常见的题型和常用解答技巧进行了介绍，它不仅能帮助求职者快速复习相关知识点，也对现代职业人如何有效求职做了详细解说。《Android高薪之路:Android程序员面试宝典》对于读者从求职就业到提升计算机专业知识都有显著的帮助。",
        "ebook_price": "27.00",
        "price": "45.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "6880a693734ebd927be1519b6f9f7e3d12369d122aa5069e6cf4e97473019fa4",
        "file": "Android高薪之路：Android程序员面试宝典.pdf"
      },
      {
        "timestamp": "2015-06-30T03:41:30.578000+00:00",
        "title_sort": "深入理解Android：卷I",
        "language": "zh",
        "contributor": "calibre (2.16.0) [http://calibre-ebook.com]",
        "date": "2011-09-07T16:00:00+00:00",
        "creator": "邓凡平",
        "identifier": {
          "mobi-asin": "B00BTCM8Q2",
          "uuid": "c10dc969-2603-481b-bc96-bf991ebbc2d0",
          "calibre": "c10dc969-2603-481b-bc96-bf991ebbc2d0"
        },
        "title": "深入理解Android：卷I",
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "7f49de4e256161e439af824db0c5cc36566faef5fb25f48ad0cecb2ff7e97448",
        "file": "深入理解Android卷I.epub"
      },
      {
        "title_sort": "深入理解Android:卷II",
        "timestamp": "2015-06-30T03:47:42.264000+00:00",
        "publisher": "机械工业出版社",
        "contributor": "calibre (2.16.0) [http://calibre-ebook.com]",
        "identifier": {
          "mobi-asin": "ad62c7de-b880-41a7-8c59-1fa7b202658d",
          "uuid": "b7519c0f-003d-4b9b-b209-b5e700a91276",
          "calibre": "b7519c0f-003d-4b9b-b209-b5e700a91276"
        },
        "language": "zh",
        "title": "深入理解Android:卷II",
        "date": "2012-08-09T16:00:00+00:00",
        "creator": "邓凡平",
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "2dddd418f390a66b02b22fe47903407d9b920b7a5de9e8a3c725a95acf54a103",
        "file": "深入理解Android卷II.epub"
      }
    ]
  },
  {
    "dir_name": "c",
    "name": "C语言",
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 301,
          "average": "9.4",
          "min": 0
        },
        "subtitle": "第六版",
        "author": [
          "普拉达 (Stephen Prata)"
        ],
        "pubdate": "2016-4-1",
        "tags": [
          {
            "count": 196,
            "name": "C语言",
            "title": "C语言"
          },
          {
            "count": 133,
            "name": "C",
            "title": "C"
          },
          {
            "count": 124,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 87,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 66,
            "name": "经典",
            "title": "经典"
          },
          {
            "count": 50,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 40,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 31,
            "name": "C++",
            "title": "C++"
          }
        ],
        "origin_title": "C Primer Plus : 6th",
        "image": "https://img1.doubanio.com/view/subject/m/public/s29438897.jpg",
        "binding": "平装",
        "translator": [
          "姜佑"
        ],
        "catalog": "第1章　初识C语言\t1\n1．1　C语言的起源\t1\n1．2 选择C语言的理由\t1\n1．2．1 设计特性\t1\n1．2．2 高效性\t1\n1．2．3 可移植性\t2\n1．2．4 强大而灵活\t3\n1．2．5 面向程序员\t3\n1．2．6 缺点\t3\n1．3 C语言的应用范围\t3\n1．4 计算机能做什么\t4\n1．5 高级计算机语言和编译器\t5\n1．6 语言标准\t6\n1．6．1 第1个ANSI/ISO C标准\t6\n1．6．2 C99标准\t6\n1．6．3 C11标准\t7\n1．7 使用C语言的7个步骤\t7\n1．7．1 第1步：定义程序的目标\t8\n1．7．2 第2步：设计程序\t8\n1．7．3 第3步：编写代码\t8\n1．7．4 第4步：编译\t8\n1．7．5 第5步：运行程序\t9\n1．7．6 第6步：测试和调试程序\t9\n1．7．7 第7步：维护和修改代码\t9\n1．7．8 说明\t9\n1．8 编程机制\t10\n1．8．1 目标代码文件、可执行文件和库\t10\n1．8．2 UNIX系统\t11\n1．8．3 GNU编译器集合和LLVM项目\t13\n1．8．4 Linux系统\t13\n1．8．5 PC的命令行编译器\t14\n1．8．6 集成开发环境（Windows）\t14\n1．8．7 Windows/Linux\t15\n1．8．8 Macintosh中的C\t15\n1．9 本书的组织结构\t15\n1．10 本书的约定\t16\n1．10．1 字体\t16\n1．10．2 程序输出\t16\n1．10．3 特殊元素\t17\n1．11 本章小结\t17\n1．12 复习题\t18\n1．13 编程练习\t18\n第2章　C语言概述\t19\n2．1 简单的C程序示例\t19\n2．2 示例解释\t20\n2．2．1 第1遍：快速概要\t21\n2．2．2 第2遍：程序细节\t21\n2．3 简单程序的结构\t28\n2．4 提高程序可读性的技巧\t28\n2．5 进一步使用C\t29\n2．5．1 程序说明\t30\n2．5．2 多条声明\t30\n2．5．3 乘法\t30\n2．5．4 打印多个值\t30\n2．6 多个函数\t30\n2．7 调试程序\t32\n2．7．1 语法错误\t32\n2．7．2 语义错误\t33\n2．7．3 程序状态\t34\n2．8 关键字和保留标识符\t34\n2．9 关键概念\t35\n2．10 本章小结\t35\n2．11 复习题\t36\n2．12 编程练习\t37\n第3章　数据和C\t39\n3．1 示例程序\t39\n3．2 变量与常量数据\t42\n3．3 数据：数据类型关键字\t42\n3．3．1 整数和浮点数\t43\n3．3．2 整数\t43\n3．3．3 浮点数\t43\n3．4 C语言基本数据类型\t44\n3．4．1 int类型\t44\n3．4．2 其他整数类型\t47\n3．4．3 使用字符：char类型\t50\n3．4．4 _Bool类型\t54\n3．4．5 可移植类型：stdint．h和inttypes．h\t55\n3．4．6 float、double和long double\t56\n3．4．7 复数和虚数类型\t60\n3．4．8 其他类型\t60\n3．4．9 类型大小\t62\n3．5 使用数据类型\t63\n3．6 参数和陷阱\t63\n3．7 转义序列示例\t64\n3．7．1 程序运行情况\t65\n3．7．2 刷新输出\t65\n3．8 关键概念\t66\n3．9 本章小结\t66\n3．10 复习题\t67\n3．11 编程练习\t68\n第4章　字符串和格式化输入/输出\t71\n4．1 前导程序\t71\n4．2 字符串简介\t72\n4．2．1 char类型数组和null字符\t72\n4．2．2 使用字符串\t73\n4．2．3 strlen()函数\t74\n4．3 常量和C预处理器\t76\n4．3．1 const限定符\t78\n4．3．2 明示常量\t78\n4．4 printf()和scanf()\t80\n4．4．1 printf()函数\t80\n4．4．2 使用printf()\t81\n4．4．3 printf()的转换说明修饰符\t83\n4．4．4 转换说明的意义\t87\n4．4．5 使用scanf()\t92\n4．4．6 printf()和scanf()的*修饰符\t95\n4．4．7 printf()的用法提示\t97\n4．5 关键概念\t98\n4．6 本章小结\t98\n4．7 复习题\t99\n4．8 编程练习\t100\n第5章　运算符、表达式和语句\t103\n5．1 循环简介\t103\n5．2 基本运算符\t105\n5．2．1 赋值运算符：=\t105\n5．2．2 加法运算符：+\t107\n5．2．3 减法运算符：-\t107\n5．2．4 符号运算符：-和+\t107\n5．2．5 乘法运算符：*\t108\n5．2．6 除法运算符：/\t110\n5．2．7 运算符优先级\t110\n5．2．8 优先级和求值顺序\t112\n5．3 其他运算符\t113\n5．3．1 sizeof运算符和size_t类型\t113\n5．3．2 求模运算符：%\t114\n5．3．3 递增运算符：++\t115\n5．3．4 递减运算符：--\t118\n5．3．5 优先级\t118\n5．3．6 不要自作聪明\t119\n5．4 表达式和语句\t120\n5．4．1 表达式\t120\n5．4．2 语句\t120\n5．4．3 复合语句（块）\t123\n5．5 类型转换\t124\n5．6 带参数的函数\t127\n5．7 示例程序\t129\n5．8 关键概念\t130\n5．9 本章小结\t130\n5．10 复习题\t131\n5．11 编程练习\t134\n第6章　C控制语句：循环\t137\n6．1 再探while循环\t137\n6．1．1 程序注释\t138\n6．1．2 C风格读取循环\t139\n6．2 while语句\t140\n6．2．1 终止while循环\t140\n6．2．2 何时终止循环\t141\n6．2．3 while：入口条件循环\t141\n6．2．4 语法要点\t141\n6．3 用关系运算符和表达式比较大小\t143\n6．3．1 什么是真\t144\n6．3．2 其他真值\t145\n6．3．3 真值的问题\t146\n6．3．4 新的_Bool类型\t147\n6．3．5 优先级和关系运算符\t148\n6．4 不确定循环和计数循环\t150\n6．5 for循环\t151\n6．6 其他赋值运算符：+=、-=、*=、/=、%=\t155\n6．7 逗号运算符\t156\n6．8 出口条件循环：do while\t159\n6．9 如何选择循环\t161\n6．10 嵌套循环\t162\n6．10．1 程序分析\t163\n6．10．2 嵌套变式\t163\n6．11 数组简介\t164\n6．12 使用函数返回值的循环示例\t166\n6．12．1 程序分析\t168\n6．12．2 使用带返回值的函数\t169\n6．13 关键概念\t169\n6．14 本章小结\t170\n6．15 复习题\t170\n6．16 编程练习\t174\n第7章　C控制语句：分支和跳转\t177\n7．1 if语句\t177\n7．2 if else语句\t179\n7．2．1 另一个示例：介绍getchar()和putchar()\t180\n7．2．2 ctype．h系列的字符函数\t182\n7．2．3 多重选择else if\t184\n7．2．4 else与if配对\t186\n7．2．5 多层嵌套的if语句\t187\n7．3 逻辑运算符\t190\n7．3．1 备选拼写：iso646．h头文件\t191\n7．3．2 优先级\t192\n7．3．3 求值顺序\t192\n7．3．4 范围\t193\n7．4 一个统计单词的程序\t194\n7．5 条件运算符：?：\t196\n7．6 循环辅助：continue和break\t198\n7．6．1 continue语句\t198\n7．6．2 break语句\t200\n7．7 多重选择：switch和break\t202\n7．7．1 switch语句\t204\n7．7．2 只读每行的首字符\t205\n7．7．3 多重标签\t206\n7．7．4 switch和if else\t208\n7．8 goto语句\t208\n7．9 关键概念\t211\n7．10 本章小结\t211\n7．11 复习题\t212\n7．12 编程练习\t214\n第8章　字符输入/输出和输入验证\t217\n8．1 单字符I/O：getchar()和putchar()\t217\n8．2 缓冲区\t218\n8．3 结束键盘输入\t219\n8．3．1 文件、流和键盘输入\t219\n8．3．2 文件结尾\t220\n8．4 重定向和文件\t222\n8．5 创建更友好的用户界面\t226\n8．5．1 使用缓冲输入\t226\n8．5．2 混合数值和字符输入\t228\n8．6 输入验证\t230\n8．6．1 分析程序\t234\n8．6．2 输入流和数字\t234\n8．7 菜单浏览\t235\n8．7．1 任务\t235\n8．7．2 使执行更顺利\t235\n8．7．3 混合字符和数值输入\t237\n8．8 关键概念\t240\n8．9 本章小结\t240\n8．10 复习题\t241\n8．11 编程练习\t241\n第9章　函数\t243\n9．1 复习函数\t243\n9．1．1 创建并使用简单函数\t244\n9．1．2 分析程序\t245\n9．1．3 函数参数\t247\n9．1．4 定义带形式参数的函数\t248\n9．1．5 声明带形式参数函数的原型\t249\n9．1．6 调用带实际参数的函数\t249\n9．1．7 黑盒视角\t250\n9．1．8 使用return从函数中返回值\t250\n9．1．9 函数类型\t252\n9．2 ANSI C函数原型\t253\n9．2．1 问题所在\t253\n9．2．2 ANSI的解决方案\t254\n9．2．3 无参数和未指定参数\t255\n9．2．4 函数原型的优点\t256\n9．3 递归\t256\n9．3．1 演示递归\t256\n9．3．2 递归的基本原理\t258\n9．3．3 尾递归\t258\n9．3．4 递归和倒序计算\t260\n9．3．5 递归的优缺点\t262\n9．4 编译多源代码文件的程序\t262\n9．4．1 UNIX\t263\n9．4．2 Linux\t263\n9．4．3 DOS命令行编译器\t263\n9．4．4 Windows和苹果的IDE编译器\t263\n9．4．5 使用头文件\t263\n9．5 查找地址：&运算符\t267\n9．6 更改主调函数中的变量\t268\n9．7 指针简介\t269\n9．7．1 间接运算符：*\t270\n9．7．2 声明指针\t270\n9．7．3 使用指针在函数间通信\t271\n9．8 关键概念\t274\n9．9 本章小结\t275\n9．10　复习题\t275\n9．11 编程练习\t276\n第10章　数组和指针\t277\n10．1 数组\t277\n10．1．1 初始化数组\t277\n10．1．2 指定初始化器（C99）\t281\n10．1．3 给数组元素赋值\t282\n10．1．4 数组边界\t282\n10．1．5 指定数组的大小\t284\n10．2 多维数组\t284\n10．2．1 初始化二维数组\t287\n10．2．2 其他多维数组\t288\n10．3 指针和数组\t288\n10．4 函数、数组和指针\t290\n10．4．1 使用指针形参\t293\n10．4．2 指针表示法和数组表示法\t294\n10．5 指针操作\t295\n10．6 保护数组中的数据\t298\n10．6．1 对形式参数使用const\t299\n10．6．2　const的其他内容\t300\n10．7 指针和多维数组\t302\n10．7．1 指向多维数组的指针\t304\n10．7．2 指针的兼容性\t305\n10．7．3 函数和多维数组\t306\n10．8 变长数组（VLA）\t309\n10．9 复合字面量\t312\n10．10 关键概念\t314\n10．11 本章小结\t315\n10．12 复习题\t316\n10．13 编程练习\t317\n第11章　字符串和字符串函数\t321\n11．1 表示字符串和字符串I/O\t321\n11．1．1 在程序中定义字符串\t322\n11．1．2 指针和字符串\t328\n11．2 字符串输入\t329\n11．2．1 分配空间\t329\n11．2．2 不幸的gets()函数\t330\n11．2．3 gets()的替代品\t331\n11．2．4 scanf()函数\t336\n11．3 字符串输出\t337\n11．3．1 puts()函数\t338\n11．3．2 fputs()函数\t339\n11．3．3 printf()函数\t339\n11．4 自定义输入/输出函数\t340\n11．5 字符串函数\t342\n11．5．1 strlen()函数\t342\n11．5．2 strcat()函数\t343\n11．5．3 strncat()函数\t345\n11．5．4 strcmp()函数\t346\n11．5．5 strcpy()和strncpy()函数\t351\n11．5．6 sprintf()函数\t356\n11．5．7 其他字符串函数\t357\n11．6 字符串示例：字符串排序\t359\n11．6．1 排序指针而非字符串\t360\n11．6．2 选择排序算法\t361\n11．7 ctype．h字符函数和字符串\t362\n11．8 命令行参数\t363\n11．8．1 集成环境中的命令行参数\t365\n11．8．2 Macintosh中的命令行参数\t365\n11．9 把字符串转换为数字\t365\n11．10 关键概念\t368\n11．11 本章小结\t368\n11．12 复习题\t369\n11．13 编程练习\t371\n第12章　存储类别、链接和内存管理\t373\n12．1 存储类别\t373\n12．1．1 作用域\t374\n12．1．2 链接\t376\n12．1．3 存储期\t376\n12．1．4 自动变量\t377\n12．1．5 寄存器变量\t380\n12．1．6 块作用域的静态变量\t381\n12．1．7 外部链接的静态变量\t382\n12．1．8 内部链接的静态变量\t386\n12．1．9 多文件\t386\n12．1．10 存储类别说明符\t387\n12．1．11 存储类别和函数\t389\n12．1．12 存储类别的选择\t389\n12．2 随机数函数和静态变量\t390\n12．3 掷骰子\t393\n12．4 分配内存：malloc()和free()\t396\n12．4．1 free()的重要性\t399\n12．4．2 calloc()函数\t400\n12．4．3 动态内存分配和变长数组\t400\n12．4．4 存储类别和动态内存分配\t401\n12．5 ANSI C类型限定符\t402\n12．5．1 const类型限定符\t403\n12．5．2 volatile类型限定符\t404\n12．5．3 restrict类型限定符\t405\n12．5．4 _Atomic类型限定符（C11）\t406\n12．5．5 旧关键字的新位置\t406\n12．6　关键概念\t407\n12．7 本章小结\t407\n12．8 复习题\t408\n12．9 编程练习\t409\n第13章　文件输入/输出\t413\n13．1 与文件进行通信\t413\n13．1．1 文件是什么\t413\n13．1．2 文本模式和二进制模式\t413\n13．1．3 I/O的级别\t415\n13．1．4 标准文件\t415\n13．2 标准I/O\t415\n13．2．1 检查命令行参数\t416\n13．2．2 fopen()函数\t416\n13．2．3 getc()和putc()函数\t417\n13．2．4 文件结尾\t418\n13．2．5 fclose()函数\t419\n13．2．6 指向标准文件的指针\t419\n13．3 一个简单的文件压缩程序\t419\n13．4 文件I/O：fprintf()、fscanf()、fgets()和fputs()\t421\n13．4．1 fprintf()和fscanf()函数\t421\n13．4．2 fgets()和fputs()函数\t422\n13．5 随机访问：fseek()和ftell()\t423\n13．5．1 fseek()和ftell()的工作原理\t424\n13．5．2 二进制模式和文本模式\t425\n13．5．3 可移植性\t425\n13．5．4 fgetpos()和fsetpos()函数\t426\n13．6 标准I/O的机理\t426\n13．7 其他标准I/O函数\t427\n13．7．1 int ungetc(int c， FILE *fp)函数\t427\n13．7．2 int fflush()函数\t428\n13．7．3 int setvbuf()函数\t428\n13．7．4 二进制I/O：fread()和fwrite()\t428\n13．7．5 size_t fwrite()函数\t429\n13．7．6 size_t fread()函数\t430\n13．7．7 int feof(FILE *fp)和int ferror(FILE *fp)函数\t430\n13．7．8 一个程序示例\t430\n13．7．9 用二进制I/O进行随机访问\t433\n13．8 关键概念\t435\n13．9 本章小结\t435\n13．10 复习题\t435\n13．11 编程练习\t437\n第14章　结构和其他数据形式\t439\n14．1 示例问题：创建图书目录\t439\n14．2 建立结构声明\t441\n14．3 定义结构变量\t441\n14．3．1 初始化结构\t442\n14．3．2 访问结构成员\t443\n14．3．3 结构的初始化器\t443\n14．4 结构数组\t444\n14．4．1 声明结构数组\t446\n14．4．2 标识结构数组的成员\t447\n14．4．3 程序讨论\t447\n14．5 嵌套结构\t448\n14．6 指向结构的指针\t449\n14．6．1 声明和初始化结构指针\t450\n14．6．2 用指针访问成员\t451\n14．7 向函数传递结构的信息\t451\n14．7．1 传递结构成员\t451\n14．7．2 传递结构的地址\t452\n14．7．3 传递结构\t453\n14．7．4 其他结构特性\t454\n14．7．5 结构和结构指针的选择\t458\n14．7．6 结构中的字符数组和字符指针\t458\n14．7．7 结构、指针和malloc()\t459\n14．7．8 复合字面量和结构（C99）\t462\n14．7．9 伸缩型数组成员（C99）\t463\n14．7．10 匿名结构（C11）\t465\n14．7．11 使用结构数组的函数\t466\n14．8 把结构内容保存到文件中\t467\n14．8．1 保存结构的程序示例\t468\n14．8．2 程序要点\t470\n14．9 链式结构\t471\n14．10 联合简介\t472\n14．10．1 使用联合\t472\n14．10．2 匿名联合（C11）\t473\n14．11 枚举类型\t474\n14．11．1 enum常量\t475\n14．11．2 默认值\t475\n14．11．3 赋值\t475\n14．11．4 enum的用法\t476\n14．11．5 共享名称空间\t477\n14．12 typedef简介\t478\n14．13 其他复杂的声明\t479\n14．14 函数和指针\t481\n14．15 关键概念\t487\n14．16 本章小结\t487\n14．17 复习题\t488\n14．18 编程练习\t490\n第15章　位操作\t493\n15．1 二进制数、位和字节\t493\n15．1．1 二进制整数\t494\n15．1．2 有符号整数\t494\n15．1．3 二进制浮点数\t495\n15．2 其他进制数\t495\n15．2．1 八进制\t495\n15．2．2 十六进制\t496\n15．3 C按位运算符\t496\n15．3．1 按位逻辑运算符\t497\n15．3．2 用法：掩码\t498\n15．3．3 用法：打开位（设置位）\t498\n15．3．4 用法：关闭位（清空位）\t499\n15．3．5 用法：切换位\t499\n15．3．6 用法：检查位的值\t500\n15．3．7 移位运算符\t500\n15．3．8 编程示例\t501\n15．3．9 另一个例子\t503\n15．4 位字段\t505\n15．4．1 位字段示例\t506\n15．4．2 位字段和按位运算符\t509\n15．5 对齐特性（C11）\t515\n15．6 关键概念\t516\n15．7 本章小结\t516\n15．8 复习题\t517\n15．9 编程练习\t518\n第16章　C预处理器和C库\t521\n16．1 翻译程序的第一步\t521\n16．2 明示常量：#define\t522\n16．2．1 记号\t525\n16．2．2 重定义常量\t525\n16．3 在#define中使用参数\t525\n16．3．1 用宏参数创建字符串：#运算符\t527\n16．3．2 预处理器黏合剂：##运算符\t528\n16．3．3 变参宏：．．．和_ _VA_ARGS_ _\t529\n16．4 宏和函数的选择\t530\n16．5 文件包含：#include\t531\n16．5．1 头文件示例\t531\n16．5．2 使用头文件\t533\n16．6 其他指令\t534\n16．6．1 #undef指令\t534\n16．6．2 从C预处理器角度看已定义\t534\n16．6．3 条件编译\t535\n16．6．4 预定义宏\t539\n16．6．5 #line和#error\t540\n16．6．6 #pragma\t540\n16．6．7 泛型选择（C11）\t541\n16．7 内联函数（C99）\t542\n16．8 _Noreturn函数（C11）\t544\n16．9 C库\t544\n16．9．1 访问C库\t544\n16．9．2 使用库描述\t545\n16．10 数学库\t546\n16．10．1 三角问题\t547\n16．10．2 类型变体\t548\n16．10．3 tgmath．h库（C99）\t550\n16．11 通用工具库\t550\n16．11．1 exit()和atexit()函数\t550\n16．11．2 qsort()函数\t552\n16．12 断言库\t556\n16．12．1 assert的用法\t556\n16．12．2 _Static_assert（C11）\t557\n16．13 string．h库中的memcpy()和memmove()\t558\n16．14 可变参数：stdarg．h\t560\n16．15 关键概念\t562\n16．16 本章小结\t562\n16．17 复习题\t562\n16．18 编程练习\t563\n第17章　高级数据表示\t567\n17．1 研究数据表示\t567\n17．2 从数组到链表\t570\n17．2．1 使用链表\t572\n17．2．2 反思\t576\n17．3 抽象数据类型（ADT）\t576\n17．3．1 建立抽象\t577\n17．3．2 建立接口\t578\n17．3．3 使用接口\t581\n17．3．4 实现接口\t583\n17．4 队列ADT\t589\n17．4．1 定义队列抽象数据类型\t590\n17．4．2 定义一个接口\t590\n17．4．3 实现接口数据表示\t591\n17．4．4 测试队列\t598\n17．5 用队列进行模拟\t600\n17．6 链表和数组\t605\n17．7 二叉查找树\t608\n17．7．1 二叉树ADT\t608\n17．7．2 二叉查找树接口\t609\n17．7．3 二叉树的实现\t611\n17．7．4 使用二叉树\t624\n17．7．5 树的思想\t628\n17．8 其他说明\t629\n17．9 关键概念\t630\n17．10 本章小结\t630\n17．11 复习题\t630\n17．12 编程练习\t631\n附录A　复习题答案\t633\n附录B　参考资料\t665\nB．1 参考资料I：补充阅读\t665\nB．2 参考资料II：C运算符\t667\nB．3 参考资料III：基本类型和存储类别\t671\nB．4 参考资料IV：表达式、语句和程序流\t675\nB．5 参考资料V：新增C99和C11的ANSI C库\t679\nB．6 参考资料VI：扩展的整数类型\t714\nB．7 参考资料VII：扩展字符支持\t716\nB．8 参考资料VIII：C99/C11数值计算增强\t720\nB．9 参考资料IX：C和C++的区别\t726",
        "pages": "730",
        "images": {
          "small": "https://img1.doubanio.com/view/subject/s/public/s29438897.jpg",
          "large": "https://img1.doubanio.com/view/subject/l/public/s29438897.jpg",
          "medium": "https://img1.doubanio.com/view/subject/m/public/s29438897.jpg"
        },
        "alt": "https://book.douban.com/subject/26792521/",
        "id": "26792521",
        "publisher": "人民邮电出版社",
        "isbn10": "7115390592",
        "isbn13": "9787115390592",
        "title": "C Primer Plus - 第6版",
        "url": "https://api.douban.com/v2/book/26792521",
        "alt_title": "C Primer Plus : 6th",
        "author_intro": "Stephen Prata曾在加利福尼亚的马林学院（肯特菲尔德）教授天文学、物理学和程序设计课程，现已退休。他在加州理工学院获得学士学位，在加州大学伯克利分校获得博士学位。他接触程序设计，是为了利用计算机给星团建模。Stephen撰写和与他人合著了十几本书籍，其中包括C++ Primer Plus和Unix Primer Plus。",
        "summary": "《C Primer Plus（第6版）中文版》详细讲解了C语言的基本概念和编程技巧。\n《C Primer Plus（第6版）中文版》共17章。第1、2章介绍了C语言编程的预备知识。第3~15章详细讲解了C语言的相关知识，包括数据类型、格式化输入/输出、运算符、表达式、语句、循环、字符输入和输出、函数、数组和指针、字符和字符串函数、内存管理、文件输入输出、结构、位操作等。第16章、17章介绍C预处理器、C库和高级数据表示。本书以完整的程序为例，讲解C语言的知识要点和注意事项。每章末设计了大量复习题和编程练习，帮助读者巩固所学知识和提高实际编程能力。附录给出了各章复习题的参考答案和丰富的参考资料。\n《C Primer Plus（第6版）中文版》可作为C语言的教材，适用于需要系统学习C语言的初学者，也适用于巩固C语言知识或希望进一步提高编程技术的程序员。",
        "price": "CNY 89.00",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "aad0b6f1e9aec7a3a6c40e1d9ba4f241ede4a5084e9f6326121ddec3b85986f9",
        "file": "C Primer Plus - 第6版.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 1569,
          "average": "9.1",
          "min": 0
        },
        "subtitle": "（第五版）",
        "author": [
          "Stephen Prata",
          "云巅工作室"
        ],
        "pubdate": "2005-2-1",
        "tags": [
          {
            "count": 811,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 789,
            "name": "c",
            "title": "c"
          },
          {
            "count": 720,
            "name": "c语言",
            "title": "c语言"
          },
          {
            "count": 528,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 420,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 346,
            "name": "经典",
            "title": "经典"
          },
          {
            "count": 327,
            "name": "C",
            "title": "C"
          },
          {
            "count": 215,
            "name": "programming",
            "title": "programming"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s1308874.jpg",
        "binding": "平装(无盘)",
        "translator": [
          "云巅工作室"
        ],
        "catalog": "第1章 概览\n1.1 C语言的起源\n1.2 使用C语言的理由\n1.3 C语言的发展方向\n1.4 计算机工作的基本原理\n1.5 高级计算机语言和编译器\n1.6 使用C语言的7个步骤\n1.7 编程机制\n1.8 语言标准\n1.9 本书的组织结构\n1.10 本书体例\n1.11 总结\n1.12 复习题\n1.13 编程练习\n第2章 C语言概述\n2.1 C语言的一个简单实例\n2.2 实例说明\n2.3 一个简单程序的结构\n2.4 使程序可读的技巧\n2.5 更进一步\n2.6 多个函数\n2.7 调试\n2.8 关键字和保留标识符\n2.9 关键概念\n2.10 总结\n2.11 复习题\n2.12 编程练习\n第3章 数据和C\n3.1 示例程序\n3.2 变量与常量数据\n3.3 数据：数据类型关键字\n3.4 C数据类型\n3.5 使用数据类型\n3.6 参数和易犯的错误\n3.7 另一个例子：转义序列\n3.8 关键概念\n3.9 总结\n3.10 复习题\n3.11 编程练习\n第4章 字符串和格式化输入/输出\n4.1 前导程序\n4.2 字符串简介\n4.3 常量和C预处理器\n4.4 研究和利用printf（）和scanf（）\n4.5 关键概念\n4.6 总结\n4.7 复习题\n4.8 编程练习\n第5章 运算符、表达式和语句\n5.1 循环简介\n5.2 基本运算符\n5.3 其他运算符\n5.4 表达式和语句\n5.5 类型转换\n5.6 带有参数的函数\n5.7 一个示例程序\n5.8 关键概念\n5.9 总结\n5.10 复习题\n5.11 编程练习\n第6章 C控制语句：循环\n6.1 再探while循环\n6.2 while语句\n6.4 不确定循环与计数循环\n6.5 for循环\n6.6 更多赋值运算符：+=、-=、*=、/=和%=\n6.7 逗号运算符\n6.8 退出条件循环：do while\n6.9 选择哪种循环\n6.10 嵌套循环\n6.11 数组\n6.12 使用函数返回值的循环例子\n6.13 关键概念\n6.14 总结\n6.15 复习题\n6.16 编程练习\n第7章 C控制语句：分支和跳转\n7.1 if语句\n7.2 在if语句中添加else关键字\n7.3 获得逻辑性\n7.4 一个统计字数的程序\n7.5 条件运算符?:\n7.6 循环辅助手段：continue和break\n7.7 多重选择：switch和break\n7.8 goto语句\n7.9 关键概念\n7.10 总结\n7.11 复习题\n7.12 编程练习\n第8章 字符输入/输出和输入确认\n8.1 单字符I/O：getchar（）和putchar（）\n8.2 缓冲区\n8.3 终止键盘输入\n8.5 创建一个更友好的用户界面\n8.6 输入确认\n8.7 菜单浏览\n8.8 关键概念\n8.9 总结\n8.10 复习题\n8.11 编程练习\n第9章 函数\n9.1 函数概述\n9.2 ANSI C的函数原型\n9.3 递归\n9.4 多源代码文件程序的编译\n9.5 地址运算符：&\n9.6 改变调用函数中的变量\n9.7 指针简介\n9.8 关键概念\n9.9 总结\n9.10 复习题\n9.11 编程练习\n第10章 数组和指针\n10.1 数组\n10.2 多维数组\n10.3 指针和数组\n10.4 函数、数组和指针\n10.5 指针操作\n10.6 保护数组内容\n10.7 指针和多维数组\n10.8 变长数组（VLA）\n10.9 复合文字\n10.10 关键概念\n10.11 总结\n10.12 复习题\n10.13 编程练习\n第11章 字符串和字符串函数\n11.1 字符串表示和字符串I/O\n11.2 字符串输入\n11.3 字符串输出\n11.4 自定义字符串输入/输出函数\n11.5 字符串函数\n11.6 字符串例子：字符串排序\n11.7 ctype.h字符函数和字符串\n11.8 命令行参数\n11.9 把字符串转换为数字\n11.10 关键概念\n11.11 总结\n11.12 复习题\n11.13 编程练习\n第12章 存储类、链接和内存管理\n12.1 存储类\n12.2 存储类说明符\n12.3 存储类和函数\n12.4 随机数函数和静态变量\n12.5 掷骰子\n12.6 分配内存：malloc（）和free（）\n12.7 ANSI C的类型限定词\n12.8 关键概念\n12.9 总结\n12.10 复习题\n12.11 编程练习\n第13章 文件输入/输出\n13.1 和文件进行通信\n13.2 标准I/O\n13.3 一个简单的文件压缩程序\n13.4 文件I/O：fprintf ( )、fscanf ( )、fgets ( )和fputs ( )函数\n13.5 随机存取：fseek（）和ftell（）函数\n13.6 标准I/O内幕\n13.7 其他标准I/O函数\n13.8 关键概念\n13.9 总结\n13.10 复习题\n13.11 编程练习\n第14章 结构和其他数据形式\n14.1 示例问题：创建图书目录\n14.2 建立结构声明\n14.3 定义结构变量\n14.4 结构数组\n14.5 嵌套结构\n14.6 指向结构的指针\n14.7 向函数传递结构信息\n14.8 把结构内容保存到文件中\n14.9 结构：下一步是什么\n14.10 联合简介\n14.11 枚举类型\n14.12 typedef简介\n14.13 奇特的声明\n14.14 函数和指针\n14.15 关键概念\n14.16 总结\n14.17 复习题\n14.18 编程练习\n第15章 位操作\n15.1 二进制数、位和字节\n15.2 其他基数\n15.3 C的位运算符\n15.4 位字段\n15.5 关键概念\n15.6 总结\n15.7 复习题\n15.8 编程练习\n第16章 C预处理器和C库\n16.1 翻译程序的第一步\n16.2 明显常量：#define\n16.3 在#define中使用参数\n16.4 宏，还是函数\n16.5 文件包含：＃include\n16.6 其他指令\n16.7 内联函数\n16.8 C库\n16.9 数学库\n16.10 通用工具库\n16.11 诊断库\n16.12 string.h库中的memcpy（）和memmove（）\n16.13 可变参数：stdarg.h\n16.14 关键概念\n16.15 总结\n16.16 复习题\n16.17 编程练习\n第17章 高级数据表示\n17.1 研究数据表示\n17.2 从数组到链表\n17.3 抽象数据类型（ADT）\n17.4 队列ADT\n17.5 用队列进行模拟\n17.6 链表与数组\n17.7 二叉搜索树\n17.8 其他说明\n17.9 关键概念\n17.10 总结\n17.11 复习题\n17.12 编程练习\n附录A 复习题答案\n附录B 参考资料",
        "pages": "626",
        "images": {
          "small": "https://img3.doubanio.com/spic/s1308874.jpg",
          "large": "https://img3.doubanio.com/lpic/s1308874.jpg",
          "medium": "https://img3.doubanio.com/mpic/s1308874.jpg"
        },
        "alt": "https://book.douban.com/subject/1240002/",
        "id": "1240002",
        "publisher": "人民邮电出版社",
        "isbn10": "7115130221",
        "isbn13": "9787115130228",
        "title": "C Primer Plus",
        "url": "https://api.douban.com/v2/book/1240002",
        "alt_title": "",
        "author_intro": "普拉塔，在加利福尼亚州的Kentfield的Marin学院教授天文学、物理学和程序设计课程。他在加州工业学院获得学士学位，从加州大学伯克利分校获得博士学位。他最早接触计算机，始于对星河的计算机建模。Stephen已经编写或与他人合作编写了十多本书。其中包括C++Primer Plus和Unix Prinmer Plus。",
        "summary": "《C Primer Plus（第5版）（中文版）》共17章。第1、2章学习C语言编程所需的预备知识。第3到15章介绍了C语言的相关知识，包括数据类型、格式化输入输出、运算符、表达式、流程控制语句、函数、数组和指针、字符串操作、内存管理、位操作等等，知识内容都针对C99标准；另外，第10章强化了对指针的讨论，第12章引入了动态内存分配的概念，这些内容更加适合读者的需求。第16章和第17章讨论了C预处理器和C库函数、高级数据表示（数据结构）方面的内容。附录给出了各章后面复习题、编程练习的答案和丰富的C编程参考资料。",
        "price": "60.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "fd3fec526da6c0fd3f85a4db983dca9803238f122cc765524edfc10c1bd49c40",
        "file": "C Primer Plus第五版 中文版.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 189,
          "average": "9.6",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "史蒂文斯 (W.Richard Stevens)",
          "拉戈 (Stephen A.Rago)"
        ],
        "pubdate": "2014-6-1",
        "tags": [
          {
            "count": 171,
            "name": "Unix",
            "title": "Unix"
          },
          {
            "count": 159,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 157,
            "name": "Linux/Unix",
            "title": "Linux/Unix"
          },
          {
            "count": 92,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 72,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 68,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 64,
            "name": "Linux",
            "title": "Linux"
          },
          {
            "count": 55,
            "name": "C",
            "title": "C"
          }
        ],
        "origin_title": "Advanced Programming in the UNIX Environment, Third Edition",
        "image": "https://img1.doubanio.com/view/subject/m/public/s28284137.jpg",
        "binding": "平装",
        "translator": [
          "戚正伟",
          "张亚英",
          "尤晋元"
        ],
        "catalog": "第1章 UNIX基础知识\n1.1 引言\n1.2 UNIX体系结构\n1.3 登录\n1.4 文件和目录\n1.5 输入和输出\n1.6 程序和进程\n1.7 出错处理\n1.8 用户标识\n1.9 信号\n1.10 时间值\n1.11 系统调用和库函数\n1.12 小结\n习题\n第2章 UNIX标准及实现\n2.1 引言\n2.2 UNIX标准化\n2.2.1 ISO C\n2.2.2 IEEE POSIX\n2.2.3 Single UNIX Specification\n2.2.4 FIPS\n2.3 UNIX系统实现\n2.3.1 SVR4\n2.3.2 4.4BSD\n2.3.3 FreeBSD\n2.3.4 Linux\n2.3.5 Mac OS X\n2.3.6 Solaris\n2.3.7 其他UNIX系统\n2.4 标准和实现的关系\n2.5 限制\n2.5.1 ISO C限制\n2.5.2 POSIX限制\n2.5.3 XSI限制\n2.5.4 函数sysconf、pathconf和fpathconf\n2.5.5 不确定的运行时限制\n2.6 选项\n2.7 功能测试宏\n2.8 基本系统数据类型\n2.9 标准之间的冲突\n2.10 小结\n习题\n第3章 文件I/O\n3.1 引言\n3.2 文件描述符\n3.3 函数open和openat\n3.4 函数creat\n3.5 函数close\n3.6 函数lseek\n3.7 函数read\n3.8 函数write\n3.9 I/O的效率\n3.10 文件共享\n3.11 原子操作\n3.12 函数dup和dup2\n3.13 函数sync、fsync和fdatasync\n3.14 函数fcntl\n3.15 函数ioctl\n3.16 /dev/fd\n3.17 小结\n习题\n第4章 文件和目录\n4.1 引言\n4.2 函数stat、fstat、fstatat和lstat\n4.3 文件类型\n4.4 设置用户ID和设置组ID\n4.5 文件访问权限\n4.6 新文件和目录的所有权\n4.7 函数access和faccessat\n4.8 函数umask\n4.9 函数chmod、fchmod和fchmodat\n4.10 粘着位\n4.11 函数chown、fchown、fchownat和lchown\n4.12 文件长度\n4.13 文件截断\n4.14 文件系统\n4.15 函数link、linkat、unlink、unlinkat和remove\n4.16 函数rename和renameat\n4.17 符号链接\n4.18 创建和读取符号链接\n4.19 文件的时间\n4.20 函数futimens、utimensat和utimes\n4.21 函数mkdir、mkdirat和rmdir\n4.22 读目录\n4.23 函数chdir、fchdir和getcwd\n4.24 设备特殊文件\n4.25 文件访问权限位小结\n4.26 小结\n习题\n第5章 标准I/O库\n5.1 引言\n5.2 流和FILE对象\n5.3 标准输入、标准输出和标准错误\n5.4 缓冲\n5.5 打开流\n5.6 读和写流\n5.7 每次一行I/O\n5.8 标准I/O的效率\n5.9 二进制I/O\n5.10 定位流\n5.11 格式化I/O\n5.12 实现细节\n5.13 临时文件\n5.14 内存流\n5.15 标准I/O的替代软件\n5.16 小结\n习题\n第6章 系统数据文件和信息\n6.1 引言\n6.2 口令文件\n6.3 阴影口令\n6.4 组文件\n6.5 附属组ID\n6.6 实现区别\n6.7 其他数据文件\n6.8 登录账户记录\n6.9 系统标识\n6.10 时间和日期例程\n6.11 小结\n习题\n第7章 进程环境\n7.1 引言\n7.2 main函数\n7.3 进程终止\n7.4 命令行参数\n7.5 环境表\n7.6 C程序的存储空间布局\n7.7 共享库\n7.8 存储空间分配\n7.9 环境变量\n7.10 函数setjmp和longjmp\n7.11 函数getrlimit和setrlimit\n7.12 小结\n习题\n第8章 进程控制\n8.1 引言\n8.2 进程标识\n8.3 函数fork\n8.4 函数vfork\n8.5 函数exit\n8.6 函数wait和waitpid\n8.7 函数waitid\n8.8 函数wait3和wait4\n8.9 竞争条件\n8.10 函数exec\n8.11 更改用户ID和更改组ID\n8.12 解释器文件\n8.13 函数system\n8.14 进程会计\n8.15 用户标识\n8.16 进程调度\n8.17 进程时间\n8.18 小结\n习题\n第9章 进程关系\n9.1 引言\n9.2 终端登录\n9.3 网络登录\n9.4 进程组\n9.5 会话\n9.6 控制终端\n9.7 函数tcgetpgrp、tcsetpgrp和tcgetsid\n9.8 作业控制\n9.9 shell执行程序\n9.10 孤儿进程组\n9.11 FreeBSD实现\n9.12 小结\n习题\n第10章 信号\n10.1 引言\n10.2 信号概念\n10.3 函数signal\n10.4 不可靠的信号\n10.5 中断的系统调用\n10.6 可重入函数\n10.7 SIGCLD语义\n10.8 可靠信号术语和语义\n10.9 函数kill和raise\n10.10 函数alarm和pause\n10.11 信号集\n10.12 函数sigprocmask\n10.13 函数sigpending\n10.14 函数sigaction\n10.15 函数sigsetjmp和siglongjmp\n10.16 函数sigsuspend\n10.17 函数abort\n10.18 函数system\n10.19 函数sleep、nanosleep和clock_nanosleep\n10.20 函数sigqueue\n10.21 作业控制信号\n10.22 信号名和编号\n10.23 小结\n习题\n第11章 线程\n11.1 引言\n11.2 线程概念\n11.3 线程标识\n11.4 线程创建\n11.5 线程终止\n11.6 线程同步\n11.6.1 互斥量\n11.6.2 避免死锁\n11.6.3 函数pthread_mutex_timedlock\n11.6.4 读写锁\n11.6.5 带有超时的读写锁\n11.6.6 条件变量\n11.6.7 自旋锁\n11.6.8 屏障\n11.7 小结\n习题\n第12章 线程控制\n12.1 引言\n12.2 线程限制\n12.3 线程属性\n12.4 同步属性\n12.4.1 互斥量属性\n12.4.2 读写锁属性\n12.4.3 条件变量属性\n12.4.4 屏障属性\n12.5 重入\n12.6 线程特定数据\n12.7 取消选项\n12.8 线程和信号\n12.9 线程和fork\n12.10 线程和I/O\n12.11 小结\n习题\n第13章 守护进程\n13.1 引言\n13.2 守护进程的特征\n13.3 编程规则\n13.4 出错记录\n13.5 单实例守护进程\n13.6 守护进程的惯例\n13.7 客户进程-服务器进程模型\n13.8 小结\n习题\n第14章 高级I/O\n14.1 引言\n14.2 非阻塞I/O\n14.3 记录锁\n14.4 I/O多路转接\n14.4.1 函数select和pselect\n14.4.2 函数poll\n14.5 异步I/O\n14.5.1 System V异步I/O\n14.5.2 BSD异步I/O\n14.5.3 POSIX异步I/O\n14.6 函数readv和writev\n14.7 函数readn和writen\n14.8 存储映射I/O\n14.9 小结",
        "pages": "812",
        "images": {
          "small": "https://img1.doubanio.com/view/subject/s/public/s28284137.jpg",
          "large": "https://img1.doubanio.com/view/subject/l/public/s28284137.jpg",
          "medium": "https://img1.doubanio.com/view/subject/m/public/s28284137.jpg"
        },
        "alt": "https://book.douban.com/subject/25900403/",
        "id": "25900403",
        "publisher": "人民邮电出版社",
        "isbn10": "7115352119",
        "isbn13": "9787115352118",
        "title": "Unix环境高级编程（第3版）",
        "url": "https://api.douban.com/v2/book/25900403",
        "alt_title": "Advanced Programming in the UNIX Environment, Third Edition",
        "author_intro": "作者介绍\nW. Richard Stevens，国际知名的UNIX和网络专家，备受赞誉的技术作家。生前著有多部经典的传世之作，包括《UNIX网络编程》（两卷本）、《TCP/IP详解》（三卷本）和本书第1版。\nStephen A. Rago，资深UNIX程序员，目前任NEC美国实验室存储系统集团研究员。之前是贝尔实验室的UNIX系统V版本4的开发人员之一。著有《UNIX系统V网络编程》，并曾担任本书第1版的技术审校和第2版的共同作者。\n译者介绍\n戚正伟，博士，上海交通大学软件学院副教授，微软亚洲研究院（2008）和美国CMU大学（2011-2012）访问学者。研究方向为系统软件和程序分析，著有《New Blue Pill深入理解硬件虚拟机》和《嵌入式GIS开发及应用》等书。\n张亚英，博士，同济大学电子与信息工程学院计算机系副教授，研究方向为分布与移动计算、嵌入式系统以及系统软件等。\n尤晋元，上海交通大学计算机科学及工程系教授、博士生导师。在科研方面，主要从事操作系统和分布对象计算技术方面的研究。在教学方面，长期承担操作系统及分布计算等课程的教学工作。主编和翻译了多本操作系统教材和参考书，包括《UNIX操作系统教程》、《UNIX高级编程技术》、《UNIX环境高级编程》和《操作系统：设计与实现》等。",
        "summary": "《UNIX环境高级编程（第3版）》是被誉为UNIX编程“圣经”的Advanced Programming in the UNIX Environment一书的第3版。在本书第2版出版后的8年中，UNIX行业发生了巨大的变化，特别是影响UNIX编程接口的有关标准变化很大。本书在保持前一版风格的基础上，根据最新的标准对内容进行了修订和增补，反映了最新的技术发展。书中除了介绍UNIX文件和目录、标准I/O库、系统数据文件和信息、进程环境、进程控制、进程关系、信号、线程、线程控制、守护进程、各种I/O、进程间通信、网络IPC、伪终端等方面的内容，还在此基础上介绍了众多应用实例，包括如何创建数据库函数库以及如何与网络打印机通信等。此外，还在附录中给出了函数原型和部分习题的答案。\n《UNIX环境高级编程（第3版）》内容权威，概念清晰，阐述精辟，对于所有层次UNIX/Linux程序员都是一本不可或缺的参考书。\n适读人群 ：所有层次UNIX/Linux程序员\n20多年来，严谨的C程序员都是依靠一本书来深入了解驱动UNIX和Linux内核的编程接口的实用知识的，这本书就是W. Richard Stevens所著的《UNIX高级环境编程》。现在，Stevens的同事Steve Rago彻底更新了这本经典著作。新的第3版支持当今领先的系统平台，反映了最新技术进展和最佳实践，并且符合最新的Single UNIX Specification第4版（SUSv4）。\nRago保留了使本书前版成为经典之作的精髓和方法。他在Stevens原著的基础上，从基础的文件、目录和进程讲起，并给诸如信号处理和终端I/O之类的先进技术保留较大的篇幅。他还深入讨论了线程和多线程编程、使用套接字接口驱动进程间通信（IPC）等方面的内容。\n这一版涵盖了70多个最新版POSIX.1标准的新增接口，包括POSIX异步I/O、旋转锁、屏障（barrier）和POSIX信号量。此外，这一版删除了许多过时的接口，保留了一些广泛使用的接口。书中几乎所有实例都已经在目前最主流的4个平台上测试过，包括Solaris 10、Mac OS X 10.6.8（Darwin 10.8.0）、FressBSD 8.0、Ubuntu 12.04（基于Linux 3.2内核）。\n与前两版一样，读者仍可以通过实例学习，这些实例包括了1万多行可下载的ISO C源代码，书中通过简明但完整的程序阐述了400多个系统调用和函数，清楚地说明它们的用法、参数和返回值。为了使读者能融会贯通，书中还提供了几个贯穿整章的案例，每个案例都根据现在的技术环境进行了全面更新。\n《UNIX环境高级编程（第3版）》帮助了几代程序员写出强大、高性能、可靠的代码。第3版根据当今主流系统进行更新，更具实用价值。\n精彩书评：\n本书第1版连同Stevens所著的系列网络技术书籍，被公认为优秀的、匠心独具的名著，成为极其畅销的作品……总之，这是一本弥足珍贵的经典著作的更新版。\n——Dennis Ritchie，图灵奖得主，UNIX操作系统和C语言之父\n对任何一个严谨的、专业的UNIX系统程序员而言，本书都是不可或缺的权威参考书。Rago更新和扩展了Stevens的经典著作，并保持了原书的风貌。书中利用清晰的实例演示了API的使用过程，还提到了许多在不同UNIX系统实现上编程时需要注意的陷阱，并指出如何使用相关的标准（如POSIX 1003.1 2004版和Single UNIX Specification第3版）来避免这些错误。\n——Andrew Josey， The Open Group标准部门主管，POSIX 1003.1标准工作组主席\n绝对的UNIX编程经典之一。\n——Eric S. Raymond，《UNIX编程艺术》作者\nStephen Rago的更新版本对于使用众多UNIX及相关操作系统环境的广大专业用户来说是一个迟来的喜讯。这一版不仅删除了过时的接口，吸纳了较新的开发接口，还根据UNIX及类UNIX操作系统环境的几种主流实现发布的新版本全面更新了所有主题、实例和应用的背景。难能可贵的是，这一版本还保持了经典的第1版的风格和品位。\n——Mukesh Kacker，Pronto Networks公司联合创始人和前任CTO\n本书对于任何在UNIX系统上编写程序的开发人员来说都是非常重要的参考书。当我想要了解或者重新回顾各种系统接口时，这本书是首选的求助工具。Stephen Rago成功地修订了本书，使其与新的操作系统（如GNU/Linux和苹果的OS X）相容，并保持了第1版易读和实用的特质。它将永远摆放在我桌上随手可及的位置。\n——Benjamin Kuperman博士，斯沃斯莫尔学院\n这是每一位严谨的UNIX C程序员必备的书籍。它深入、全面、清晰的解释是无可匹敌的。\n——UniForum Monthly\n从W. Richard Stevens的这本书中可以找到更多易于理解的、详尽的UNIX系统内部细节。这本书包含了大量实际的例子，对系统编程工作非常有益。\n——RS/Magazine",
        "price": "128.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "d3c901ac29d41a1233dcbec30f4dafd8583ae0b30f68c7193e7dfa0ba50854d9",
        "file": "Unix环境高级编程-第3版.epub"
      },
      {
        "producer": "Mac OS X 10.10.1 Quartz PDFContext",
        "creator": "LaTeX with hyperref package",
        "creation_date": "D:20150121094602Z00'00'",
        "mod_date": "D:20150121094602Z00'00'",
        "meta_type": "pdf",
        "type": "pdf",
        "sha_256": "251052e74cd98ad9558faebce2dc26f1aa2035f6e2d768777f40024680344203",
        "file": "lua源码分析.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 1482,
          "average": "8.9",
          "min": 0
        },
        "subtitle": "C语言描述",
        "author": [
          "维斯"
        ],
        "pubdate": "2004-1-1",
        "tags": [
          {
            "count": 1764,
            "name": "数据结构",
            "title": "数据结构"
          },
          {
            "count": 1408,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 696,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 555,
            "name": "数据结构与算法分析",
            "title": "数据结构与算法分析"
          },
          {
            "count": 540,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 498,
            "name": "C",
            "title": "C"
          },
          {
            "count": 420,
            "name": "算法、数据结构",
            "title": "算法、数据结构"
          },
          {
            "count": 332,
            "name": "C语言",
            "title": "C语言"
          }
        ],
        "origin_title": "Data Structures and Algorithm Analysis in C:Second Edition",
        "image": "https://img3.doubanio.com/mpic/s28015501.jpg",
        "binding": "平装",
        "translator": [
          "冯舜玺"
        ],
        "catalog": "第1章 引论\n1．1 本书讨论的内容\n1．2 数学知识复习\n1．2．1 指数\n1．2．2 对数\n1．2．3 级数\n1．2．4 模运算\n1. 2．5 证明方法\n1．3 递归简论\n总结\n练习\n参考文献\n第2章 算法分析\n2．1 数学基础\n2．2 模型\n2．3 要分析的问题\n2．4 运行时间计算\n2．4．1 一个简单的例子\n2．4．2 一般法则\n2．4．3 最大子序列和问题的解\n.2．4．4 运行时间中的对数\n2．4．5 检验你的分析\n2．4．6 分析结果的准确性\n总结\n练习\n参考文献\n第3章 表、栈和队列\n3．1 抽象数据类型(adt)\n3．2 表adt\n3．2．1 表的简单数组实现\n3．2．2 链表\n3．2．3 程序设计细节\n3．2．4 常见的错误\n3．2．5 双链表\n3．2．6 循环链表\n3．2．7 例子\n3．2．8 链表的游标实现\n3．3 栈adt\n3．3．1 栈模型\n3．3．2 栈的实现\n3．3．3 应用\n3．4 队列adt\n3．4．1 队列模型\n3．4．2 队列的数组实现\n3．4．3 队列的应用\n总结\n练习\n第4章 树\n4．1 预备知识\n4．1．1 树的实现\n4．1．2 树的遍历及应用\n4．2 二叉树\n4．2．1 实现\n4．2．2 表达式树\n4．3 查找树adt--二叉查找树\n4．3．1 makeempty\n4．3．2 find\n4．3．3 findmin和findmax\n4．3．4 insert\n4．3．5 delere\n4．3．6 平均情形分析\n4．4 avl树\n4．4．1 单旋转\n4．4．2 双旋转\n4．5 伸展树\n4．5．1 一个简单的想法\n4．5．2 展开\n4．6 树的遍历\n4．7 b-树\n总结\n练习\n参考文献\n第5章 散列\n5．1 一般想法\n5．2 散列函数\n5．3 分离链接法\n5．4 开放定址法\n5．4．1 线性探测法\n5．4．2 平方探测法\n5．4．3 双散列\n5．5 再散列\n5．6 可扩散列\n总结\n练习\n参考文献\n第6章 优先队列(堆)\n6．1 模型\n6．2 一些简单的实现\n6．3 二叉堆\n6．3．1 结构性质\n6．3．2 堆序性质\n6．3．3 基本的堆操作\n6．3．4 其他的堆操作\n6．4 优先队列的应用\n6．4．1 选择问题\n6．4．2 事件模拟\n6．5 d-堆\n6．6 左式堆\n6．6．1 左式堆的性质\n6．6．2 左式堆的操作\n6．7 斜堆\n6．8 二项队列\n6．8．1 二项队列结构\n6．8．2 二项队列操作\n6．8．3 二项队列的实现\n总结\n练习\n参考文献\n第7章 排序\n7．1 预备知识\n7．2 插入排序\n7．2．1 算法\n7．2．2 插入排序的分析\n7．3 一些简单排序算法的下界\n7. 4 希尔排序\n7．4．1 希尔排序的最坏情形分析\n7．5 堆排序\n7．5．1 堆排序的分析\n7．6 归并排序\n7．6．1 归并排序的分析\n7．7 快速排序\n7．7．1 选取枢纽元\n7．7．2 分割策略\n7．7．3 小数组\n7．7．4 实际的快速排序例程\n7．7．5 快速排序的分析\n7．7．6 选择的线性期望时间算法\n7．8 大型结构的排序\n7．9 排序的一般下界\n7．9．1 决策树\n7．10 桶式排序\n7．11 外部排序\n7．11．1 为什么需要新的算法\n7．11．2 外部排序模型\n7．11．3 简单算法\n7．11．4 多路合并\n7．11．5 多相合并\n7．11．6 替换选择\n总结\n练习\n参考文献\n第8章 不相交集adt\n8．1 等价关系\n8．2 动态等价性问题\n8．3 基本数据结构\n8．4 灵巧求并算法\n8．5 路径压缩\n8．6 按秩求并和路径压缩的最坏情形\n8．6．1 union／find算法分析\n8．7 一个应用\n总结\n练习\n参考文献\n第9章 图论算法\n9．1 若干定义\n9．1．1 图的表示\n9．2 拓扑排序\n9．3 最短路径算法\n9．3．1 无权最短路径\n9．3．2 dijkstra算法\n9．3．3 具有负边值的图\n9．3．4 无圈图\n9．3．5 所有点对最短路径\n9．4 网络流问题\n9．4．1 一个简单的最大流算法\n9．5 最小生成树\n9．5．1 prim算法\n9．5．2 kruskal算法\n9．6 深度优先搜索的应用\n9．6．1 无向图\n9．6．2 双连通性\n9．6．3 欧拉回路\n9．6．4 有向图\n9．6．5 查找强分支\n9．7 np-完全性介绍\n9．7．1 难与易\n9．7．2 np类\n9．7．3 np-完全问题\n总结\n练习\n参考文献\n第10章 算法设计技巧\n10．1 贪婪算法\n10．1．1 一个简单的调度问题\n10．1．2 huffman编码\n10．1．3 近似装箱问题\n10．2 分治算法\n10．2．1 分治算法的运行时间\n10．2．2 最近点问题\n10．2．3 选择问题\n10．2．4 一些运算问题的理论改进\n10．3 动态规划\n10．3．1 用一个表代替递归\n10．3．2 矩阵乘法的顺序安排\n10．3．3 最优二叉查找树\n10．3．4 所有点对最短路径\n10．4 随机化算法\n10．4．1 随机数发生器\n10．4．2 跳跃表\n10．4．3 素性测试\n10．5 回溯算法\n10．5．1 收费公路重建问题\n10．5．2 博弈\n总结\n练习\n参考文献\n第11章 摊还分析\n11．1 一个无关的智力问题\n11．2 二项队列\n11．3 斜堆\n11．4 斐波那契堆\n11．4．1 切除左式堆中的节点\n11．4．2 二项队列的懒惰合并\n11．4．3 斐波那契堆操作\n11．4．4 时间界的证明\n11. 5 伸展树\n总结\n练习\n参考文献\n第12章 高级数据结构及其实现\n12．1 自顶向下伸展树\n12．2 红黑树\n12．2．1 自底向上插入\n12．2．2 自顶向下红黑树\n12．2．3 自顶向下删除\n12．3 确定性跳跃表\n12．4 aa-树\n12．5 treap树\n12．6 k-d树\n12．7 配对堆\n总结\n练习\n参考文献\n索引",
        "pages": "391",
        "images": {
          "small": "https://img3.doubanio.com/spic/s28015501.jpg",
          "large": "https://img3.doubanio.com/lpic/s28015501.jpg",
          "medium": "https://img3.doubanio.com/mpic/s28015501.jpg"
        },
        "alt": "https://book.douban.com/subject/1139426/",
        "id": "1139426",
        "publisher": "机械工业出版社",
        "isbn10": "711112748X",
        "isbn13": "9787111127482",
        "title": "数据结构与算法分析",
        "url": "https://api.douban.com/v2/book/1139426",
        "alt_title": "Data Structures and Algorithm Analysis in C:Second Edition",
        "author_intro": "Mark Allen Weiss，1987年在普林斯顿大学获得计算机科学博士学位，师从Robert Sedgewick (师从Knuth)，现任美国佛罗里达国际大学计算与信息科学学院教授。他曾经担任全美AP(Advanced Placement)考试计算机学科委员会的主席(2000-2004)。他的主要研究方向是数据结构、算法和教育学。",
        "summary": "本书是《Data Structures and Algorithm Analysis in C》一书第2版的简体中译本。原书曾被评为20世纪顶尖的30部计算机著作之一，作者Mark Allen Weiss在数据结构和算法分析方面卓有建树，他的数据结构和算法分析的著作尤其畅销，并受到广泛好评．已被世界500余所大学用作教材。\n在本书中，作者更加精炼并强化了他对算法和数据结构方面创新的处理方法。通过C程序的实现，着重阐述了抽象数据类型的概念，并对算法的效率、性能和运行时间进行了分析。\n全书特点如下：\n●专用一章来讨论算法设计技巧，包括贪婪算法、分治算法、动态规划、随机化算法以及回溯算法\n●介绍了当前流行的论题和新的数据结构，如斐波那契堆、斜堆、二项队列、跳跃表和伸展树\n●安排一章专门讨论摊还分析，考查书中介绍的一些高级数据结构\n●新开辟一章讨论高级数据结构以及它们的实现，其中包括红黑树、自顶向下伸展树。treap树、k-d树、配对堆以及其他相关内容\n●合并了堆排序平均情况分析的一些新结果\n本书是国外数据结构与算法分析方面的标准教材，介绍了数据结构(大量数据的组织方法)以及算法分析(算法运行时间的估算)。本书的编写目标是同时讲授好的程序设计和算法分析技巧，使读者可以开发出具有最高效率的程序。 本书可作为高级数据结构课程或研究生一年级算法分析课程的教材，使用本书需具有一些中级程序设计知识，还需要离散数学的一些背景知识。",
        "series": {
          "id": "1163",
          "title": "计算机科学丛书"
        },
        "price": "35.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "3e96c8af63626ffe12bd73e49cc79cd026ef3dc9b0f843919d2bf1a5ecd511a8",
        "file": "数据结构与算法分析-C.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 105,
          "average": "8.2",
          "min": 0
        },
        "subtitle": "C语言描述",
        "author": [
          "Kyle Loudon"
        ],
        "pubdate": "2012-8",
        "tags": [
          {
            "count": 243,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 89,
            "name": "C语言",
            "title": "C语言"
          },
          {
            "count": 66,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 48,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 41,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 29,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 29,
            "name": "C",
            "title": "C"
          },
          {
            "count": 28,
            "name": "Programming",
            "title": "Programming"
          }
        ],
        "origin_title": "Mastering Algorithms with C",
        "image": "https://img3.doubanio.com/mpic/s11351454.jpg",
        "binding": "平装",
        "translator": [
          "肖翔",
          "陈舸"
        ],
        "catalog": "1. 前言\n2. 第1部分 预备知识\n3. 第1章 概述\n4. 数据结构简介\n5. 算法简介\n6. 小酌软件工程\n7. 如何使用本书\n8. 第2章 指针操作\n9. 指针基础\n10. 存储空间分配\n11. 数据集合与指针的算术运算\n12. 作为函数参数的指针\n13. 泛型指针与类型转换\n14. 函数指针\n15. 问与答\n16. 相关主题\n17. 第3章 递归\n18. 基本递归\n19. 尾递归\n20. 问与答\n21. 相关主题\n22. 第4章 算法分析\n23. 最坏情况分析\n24. O表示法\n25. 计算的复杂度\n26. 实例分析：插入排序\n27. 问与答\n28. 相关主题\n29. 第2部分 数据结构\n30. 第5章 链表\n31. 单链表介绍\n32. 单链表接口的定义\n33. 单链表的实现与分析\n34. 使用链表的例子：页帧管理\n35. 双向链表介绍\n36. 双向链表接口的定义\n37. 双向链表的实现与分析\n38. 循环链表介绍\n39. 循环链表接口的定义\n40. 循环链表的实现与分析\n41. 使用循环链表的例子：第二次机会页面置换法\n42. 问与答\n43. 相关主题\n44. 第6章 栈和队列\n45. 栈的描述\n46. 栈的接口定义\n47. 栈的实现与分析\n48. 队列的描述\n49. 队列的接口定义\n50. 队列的实现与分析\n51. 队列示例：事件处理\n52. 问与答\n53. 相关主题\n54. 第7章 集合\n55. 集合介绍\n56. 集合的性质\n57. 集合接口的定义\n58. 集合抽象数据类型的实现和分析\n59. Set示例：集合覆盖\n60. 问与答\n61. 相关主题\n62. 第8章 哈希表\n63. 链式哈希表的描述\n64. 链式哈希表的接口定义\n65. 链式哈希表的实现与分析\n66. 链式哈希表的例子：符号表\n67. 开地址哈希表的描述\n68. 开地址哈希函数的接口定义\n69. 开地址哈希表的实现与分析\n70. 问与答\n71. 相关主题\n72. 第9章 树\n73. 二叉树介绍\n74. 二叉树的接口定义\n75. 二叉树的实现与分析\n76. 二叉树示例：表达式处理\n77. 二叉搜索树介绍\n78. 二叉搜索树的接口定义\n79. 二叉搜索树的实现与分析\n80. 问与答\n81. 相关主题\n82. 第10章 堆和优先队列\n83. 堆的描述\n84. 堆的接口定义\n85. 堆的实现与分析\n86. 优先队列的描述\n87. 优先队列的接口定义\n88. 优先队列的实现与分析\n89. 优先队列的示例：包裹分拣\n90. 问与答\n91. 相关主题\n92. 第11章 图\n93. 图的描述\n94. 图的接口定义\n95. 图的实现与分析\n96. 关于图的应用举例：计算网络跳数\n97. 关于图的应用举例：拓扑排序\n98. 问与答\n99. 相关主题\n100. 第3部分 算法\n101. 第12章 排序和搜索\n102. 插入排序的描述\n103. 插入排序的接口定义\n104. 插入排序的实现与分析\n105. 快速排序的描述\n106. 快速排序的接口定义\n107. 快速排序的实现与分析\n108. 快速排序的例子：目录列表\n109. 归并排序的描述\n110. 归并排序的接口定义\n111. 归并排序的实现与分析\n112. 计数排序的描述\n113. 计数排序的接口定义\n114. 计数排序的实现与分析\n115. 基数排序的描述\n116. 基数排序的接口定义\n117. 基数排序的实现与分析\n118. 二分查找的描述\n119. 二分查找的接口定义\n120. 二分查找的实现与分析\n121. 二分查找的例子：拼写检查器\n122. 问与答\n123. 相关主题\n124. 第13章 数值计算\n125. 多项式插值法\n126. 多项式插值的接口定义\n127. 多项式插值的实现与分析\n128. 最小二乘估计法\n129. 最小二乘估计的接口定义\n130. 最小二乘估计的实现和分析\n131. 方程求解介绍\n132. 方程求解的接口定义\n133. 方程求解的实现与分析\n134. 问与答\n135. 相关主题\n136. 第14章 数据压缩\n137. 位操作的描述\n138. 位操作的接口定义\n139. 位操作的实现与分析\n140. 霍夫曼编码的描述\n141. 霍夫曼编码的接口定义\n142. 霍夫曼编码的分析与实现\n143. 霍夫曼编码的例子：网络优化\n144. LZ77的描述\n145. LZ77的接口定义\n146. LZ77的实现与分析\n147. 问与答\n148. 相关主题\n149. 第15章 数据加密\n150. DES算法介绍\n151. DES的接口定义\n152. DES算法的实现和分析\n153. DES应用举例：分组加密模式\n154. RSA算法介绍\n155. RSA的接口定义\n156. RSA算法的实现与分析\n157. 问与答\n158. 相关主题\n159. 第16章 图算法\n160. 最小生成树的描述\n161. 最小生成树的接口定义\n162. 最小生成树的实现与分析\n163. 最短路径的描述\n164. 最短路径的接口定义\n165. 最短路径的实现与分析\n166. 最短路径的例子：路由表\n167. 旅行商问题的描述\n168. 旅行商问题的接口定义\n169. 旅行商问题的实现与分析\n170. 问与答\n171. 相关主题\n172. 第17章 几何算法\n173. 测试线段是否相交\n174. 测试线段是否相交的标准方法\n175. 检测线段是否相交的接口定义\n176. 检测线段是否相交的实现与分析\n177. 凸包简介\n178. Jarvis’s March\n179. 凸包的接口定义\n180. 凸包的实现与分析\n181. 球面弧长\n182. 求解球面弧长的接口定义\n183. 求解球面弧长的实现和分析\n184. 球面弧长的应用举例：地球上两点之间的近似距离\n185. 问与答\n186. 相关主题",
        "pages": "401",
        "images": {
          "small": "https://img3.doubanio.com/spic/s11351454.jpg",
          "large": "https://img3.doubanio.com/lpic/s11351454.jpg",
          "medium": "https://img3.doubanio.com/mpic/s11351454.jpg"
        },
        "alt": "https://book.douban.com/subject/14267904/",
        "id": "14267904",
        "publisher": "机械工业出版社",
        "isbn10": "7111394267",
        "isbn13": "9787111394266",
        "title": "算法精解",
        "url": "https://api.douban.com/v2/book/14267904",
        "alt_title": "Mastering Algorithms with C",
        "author_intro": "Kyle Loudon是美国加州洛斯加托斯Jeppesen Dataplan公司的一名软件工程师，主管图形接口开发小组，主攻航迹规划软件的研发，这些软件主要用于商业航空公司、私营航空部门和其他一些航空制造业。在来到Jeppesen之前，Kyle在IBM公司是一名系统程序员。在技术上，Kyle主要对操作系统、网络、人机交互等领域感兴趣。1992年，Kyle在普渡大学拿到了计算机科学学士学位，并取得了法语的第二学位，同时他还被选入斐陶斐荣誉学会（美国大学优等生之荣誉学会）。他在普渡大学计算机系教了三年的计算机课程。在这期间，他完成了他个人的第一本书《Understanding Computers》，这本书用理论结合实践的方式介绍计算机的方方面面。如今，尽管他继续工作在硅谷的软件业，但他仍然坚韧不拔地在追求一个更高的学位。\n除了计算机，Kyle多年来喜欢打网球、教网球。他还喜欢山地骑行、滑冰，偶尔也和朋友们一起参加高尔夫课程。另外，Kyle还喜欢各种形式的戏剧、美食，以及某些风格的音乐和艺术；他期望成为钢琴家和艺术家，但希望渺茫。他现在在Jeppesen的工作是从他1992年开始驾驶飞机之后找到的。现在，他是一个拥有美国联邦航空局颁发的商业飞行员执照的飞行员。",
        "summary": "本书是数据结构和算法领域的经典之作，十余年来，畅销不衰！全书共分为三部分：第一部分首先介绍了数据结构和算法的概念，以及使用它们的原因和意义，然后讲解了数据结构和算法中最常用的技术——指针和递归，最后还介绍了算法的分析方法，旨在为读者学习这本书打下坚实的基础；第二部分对链表、栈、队列、集合、哈希表、堆、图等常用数据结构进行了深入阐述；第三部分对排序、搜索数值计算、数据压缩、数据加密、图算法、几何算法等经典算法进行了精辟的分析和讲解。\n本书的众多特色使得它在同类书中独树一帜：具体实现都采用正式的C语言代码而不是伪代码，在很多数据结构和算法的实现过程中，有大量细节问题是伪代码不能解决的；每一章都有精心组织的主题和应用；全部示例来自真实的应用，不只是一般的练习；对每种数据结构、算法和示例都进行了详细分析；每一章的末尾都会有一系列问题和对应的回答，旨在强调这一章的重要思想……\n本书中的代码尤为值得强调：所有实现都采用C语言编写，所有代码都优先用于教学目的，所有代码都在4种平台上经过完整测试，头文件记录了所有公共的接口，命名规则适用于全书所有的代码，所有的代码都包含大量注释……\n本书内容包括：\n· 数据结构和算法的概念，以及使用它们的原因和意义\n· 指针和递归\n· 算法分析\n· 常用数据结构：链表、栈、队列、集合、哈希表、树、堆、优先级队列以及图\n· 排序和搜索\n· 数值计算\n· 数据压缩\n· 数据加密\n· 图算法\n· 几何算法",
        "price": "79.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "750d6c45decfd0e0dca0cc5ded4ff5baafc468cc963513543ec867dfb4f3aa2a",
        "file": "算法精解-c语言描述.epub"
      }
    ]
  },
  {
    "dir_name": "c++",
    "name": "C++语言",
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 251,
          "average": "8.6",
          "min": 0
        },
        "subtitle": "中文版（第六版）",
        "author": [
          "Stephen Prata"
        ],
        "pubdate": "2012-6-19",
        "tags": [
          {
            "count": 183,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 108,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 57,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 53,
            "name": "C/C++",
            "title": "C/C++"
          },
          {
            "count": 52,
            "name": "经典",
            "title": "经典"
          },
          {
            "count": 47,
            "name": "入门",
            "title": "入门"
          },
          {
            "count": 46,
            "name": "Programming",
            "title": "Programming"
          },
          {
            "count": 21,
            "name": "技术",
            "title": "技术"
          }
        ],
        "origin_title": "C++ Primer Plus, 6th Edition",
        "image": "https://img3.doubanio.com/mpic/s10307483.jpg",
        "binding": "平装",
        "translator": [
          "张海龙",
          "袁国忠"
        ],
        "catalog": "\"第1章  预备知识 1\n1.1  C++简介 2\n1.2  C++简史 2\n1.2.1  C语言 3\n1.2.2  C语言编程原理 3\n1.2.3  面向对象编程 3\n1.2.4  C++和泛型编程 4\n1.2.5  C++的起源 4\n1.3  可移植性和标准 5\n1.3.1  C++的发展 6\n1.3.2  本书遵循的C++标准 6\n1.4  程序创建的技巧 7\n1.4.1  创建源代码文件 7\n1.4.2  编译和链接 8\n1.5  总结 11\n第2章  开始学习C++ 13\n2.1  进入C++ 14\n2.1.1  main( )函数 15\n2.1.2  C++注释 17\n2.1.3  C++预处理器和iostream文件 17\n2.1.4  头文件名 18\n2.1.5  名称空间 18\n2.1.6  使用cout进行C++输出 19\n2.1.7  C++源代码的格式化 21\n2.2  C++语句 22\n2.2.1  声明语句和变量 22\n2.2.2  赋值语句 23\n2.2.3  cout的新花样 24\n2.3  其他C++语句 24\n2.3.1  使用cin 25\n2.3.2  使用cout进行拼接 25\n2.3.3  类简介 26\n2.4  函数 27\n2.4.1  使用有返回值的函数 27\n2.4.2  函数变体 30\n2.4.3  用户定义的函数 31\n2.4.4  用户定义的有返回值的函数 33\n2.4.5  在多函数程序中使用using编译指令 34\n2.5  总结 35\n2.6  复习题 35\n2.7  编程练习 36\n第3章  处理数据 37\n3.1  简单变量 38\n3.1.1  变量名 38\n3.1.2  整型 39\n3.1.3  整型short、int、long和long long 39\n3.1.4  无符号类型 43\n3.1.5  选择整型类型 44\n3.1.6  整型字面值 45\n3.1.7  C++如何确定常量的类型 45\n3.1.8  char类型：字符和小整数 46\n3.1.9  bool类型 51\n3.2  const限定符 52\n3.3  浮点数 52\n3.3.1  书写浮点数 53\n3.3.2  浮点类型 54\n3.3.3  浮点常量 55\n3.3.4  浮点数的优缺点 55\n3.4  C++算术运算符 55\n3.4.1  运算符优先级和结合性 56\n3.4.2  除法分支 57\n3.4.3  求模运算符 57\n3.4.4  类型转换 58\n3.4.5  C++11中的auto声明 61\n3.5  总结 62\n3.6  复习题 62\n3.7  编程练习 63\n第4章  复合类型 65\n4.1  数组 66\n4.1.1  程序说明 67\n4.1.2  数组的初始化规则 68\n4.1.3  C++11数组初始化方法 68\n4.2  字符串 69\n4.2.1  拼接字符串常量 70\n4.2.2  在数组中使用字符串 70\n4.2.3  字符串输入 71\n4.2.4  每次读取一行字符串输入 72\n4.2.5  混合输入字符串和数字 74\n4.3  string类简介 75\n4.3.1  C++11字符串初始化 76\n4.3.2  赋值、拼接和附加 76\n4.3.3  string类的其他操作 76\n4.3.4  string类I/O 77\n4.3.5  其他形式的字符串字面值 78\n4.4  结构简介 79\n4.4.1  在程序中使用结构 80\n4.4.2  C++11结构初始化 81\n4.4.3  结构可以将string类作为成员吗 81\n4.4.4  其他结构属性 82\n4.4.5  结构数组 82\n4.4.6  结构中的位字段 83\n4.5  共用体 83\n4.6  枚举 84\n4.6.1  设置枚举量的值 85\n4.6.2  枚举的取值范围 86\n4.7  指针和自由存储空间 86\n4.7.1  声明和初始化指针 88\n4.7.2  指针的危险 90\n4.7.3  指针和数字 90\n4.7.4  使用new来分配内存 90\n4.7.5  使用delete释放内存 92\n4.7.6  使用new来创建动态数组 92\n4.8  指针、数组和指针算术 94\n4.8.1  程序说明 94\n4.8.2  指针小结 96\n4.8.3  指针和字符串 97\n4.8.4  使用new创建动态结构 100\n4.8.5  自动存储、静态存储和动态存储 101\n4.9  类型组合 103\n4.10  数组的替代品 104\n4.10.1  模板类vector 104\n4.10.2  模板类array（C++11） 105\n4.10.3  比较数组、vector对象和array对象 105\n4.11  总结 106\n4.12  复习题 106\n4.13  编程练习 107\n第5章  循环和关系表达式 109\n5.1  for循环 110\n5.1.1  for循环的组成部分 110\n5.1.2  回到for循环 114\n5.1.3  修改步长 115\n5.1.4  使用for循环访问字符串 116\n5.1.5  递增运算符（++）和递减运算符（--） 116\n5.1.6  副作用和顺序点 117\n5.1.7  前缀格式和后缀格式 117\n5.1.8  递增/递减运算符和指针 118\n5.1.9  组合赋值运算符 119\n5.1.10  复合语句（语句块） 119\n5.1.11  其他语法技巧——逗号运算符 120\n5.1.12  关系表达式 121\n5.1.13  赋值、比较和可能犯的错误 122\n5.1.14  C-风格字符串的比较 123\n5.1.15  比较string类字符串 125\n5.2  while循环 125\n5.2.1  for与while 127\n5.3.2  等待一段时间：编写延时循环 128\n5.3  do while循环 129\n5.4  基于范围的for循环（C++11） 131\n5.5  循环和文本输入 131\n5.5.1  使用原始的cin进行输入 131\n5.5.2  使用cin.get(char)进行补救 132\n5.5.3  使用哪一个cin.get( ) 132\n5.5.4  文件尾条件 133\n5.5.5  另一个cin.get( )版本 135\n5.6  嵌套循环和二维数组 136\n5.6.1  初始化二维数组 138\n5.6.2  使用二维数组 138\n5.7  总结 139\n5.8  复习题 139\n5.9  编程练习 140\n第6章  分支语句和逻辑运算符 143\n6.1  if语句 144\n6.1.1  if else语句 145\n6.1.2  格式化if else语句 146\n6.1.3  if else if else结构 146\n6.2  逻辑表达式 147\n6.2.1  逻辑OR运算符：|| 147\n6.2.2  逻辑AND运算符：&& 148\n6.2.3  用&&来设置取值范围 149\n6.2.4  逻辑NOT运算符：! 150\n6.2.5  逻辑运算符细节 151\n6.2.6  其他表示方式 151\n6.3  字符函数库cctype 152\n6.4  ?:运算符 153\n6.5  switch语句 154\n6.5.1  将枚举量用作标签 155\n6.5.2  switch和if else 155\n6.6  break和continue语句 156\n6.7  读取数字的循环 157\n6.8  简单文件输入/输出 159\n6.8.1  文本I/O和文本文件 159\n6.8.2  写入到文本文件中 160\n6.8.3  读取文本文件 162\n6.9  总结 164\n6.10  复习题 165\n6.11  编程练习 165\n第7章  函数——C++的编程模块 169\n7.1  复习函数的基本知识 170\n7.1.1  定义函数 170\n7.1.2  函数原型和函数调用 172\n7.2  函数参数和按值传递 174\n7.2.1  多个参数 175\n7.2.2  另外一个接受两个参数的函数 176\n7.3  函数和数组 177\n7.3.1  函数如何使用指针来处理数组 178\n7.3.2  将数组作为参数意味着什么 178\n7.3.3  更多数组函数示例 180\n7.3.4  使用数组区间的函数 182\n7.3.5  指针和const 183\n7.4  函数和二维数组 185\n7.5  函数和C-风格字符串 186\n7.5.1  将C-风格字符串作为参数的函数 187\n7.5.2  返回c-风格字符串的函数 187\n7.6  函数和结构 188\n7.6.1  传递和返回结构 188\n7.6.2  另一个处理结构的函数示例 189\n7.6.3  传递结构的地址 192\n7.7  函数和string对象 192\n7.8  函数与array对象 193\n7.9  递归 194\n7.9.1  包含一个递归调用的递归 194\n7.9.2  包含多个递归调用的递归 195\n7.10  函数指针 196\n7.10.1  函数指针的基础知识 196\n7.10.2  函数指针示例 197\n7.10.3  深入探讨函数指针 198\n7.10.4  使用typedef进行简化 200\n7.11  总结 200\n7.12  复习题 201\n7.13  编程练习 202\n第8章  函数探幽 205\n8.1  C++内联函数 206\n8.2  引用变量 208\n8.2.1  创建引用变量 208\n8.2.2  将引用用作函数参数 209\n8.2.3  引用的属性和特别之处 211\n8.2.4  将引用用于结构 213\n8.2.5  将引用用于类对象 217\n8.2.6  对象、继承和引用 218\n8.2.7  何时使用引用参数 219\n8.3  默认参数 220\n8.4  函数重载 221\n8.4.1  重载示例 223\n8.4.2  何时使用函数重载 224\n8.5  函数模板 224\n8.5.1  重载的模板 226\n8.5.2  模板的局限性 226\n8.5.3  显式具体化 226\n8.5.4  实例化和具体化 227\n8.5.5  编译器选择使用哪个函数版本 228\n8.5.6  模板函数的发展 232\n8.6  总结 234\n8.7  复习题 234\n8.8  编程练习 235\n第9章  内存模型和名称空间 237\n9.1  单独编译 238\n9.2  存储持续性、作用域和链接性 240\n9.2.1  作用域和链接 241\n9.2.2  自动存储持续性 241\n9.2.3  静态持续变量 243\n9.2.4  静态持续性、外部链接性 245\n9.2.5  静态持续性、内部链接性 247\n9.2.6  静态存储持续性、无链接性 248\n9.2.7  说明符和限定符 248\n9.2.8  函数和链接性 250\n9.2.9  语言链接性 250\n9.2.10  存储方案和动态分配 251\n9.3  名称空间 254\n9.3.1  传统的C++名称空间 254\n9.3.2  新的名称空间特性 254\n9.3.3  名称空间示例 259\n9.3.4  名称空间及其前途 260\n9.4  总结 261\n9.5  复习题 262\n9.6  编程练习 262\n第10章  对象和类 265\n10.1  过程性编程和面向对象编程 266\n10.2  抽象和类 267\n10.2.1  类型是什么 267\n10.2.2  C++中的类 267\n10.2.3  实现类成员函数 270\n10.2.4  使用类 272\n10.2.5  修改实现 273\n10.2.6  小结 274\n10.3  类的构造函数和析构函数 274\n10.3.1  声明和定义构造函数 275\n10.3.2  使用构造函数 276\n10.3.3  默认构造函数 276\n10.3.4  析构函数 277\n10.3.5  改进Stock类 278\n10.3.6  构造函数和析构函数小结 281\n10.4  this指针 282\n10.5  对象数组 285\n10.6  类作用域 286\n10.6.1  作用域为类的常量 286\n10.6.2  作用域内枚举（C++11） 287\n10.7  抽象数据类型 288\n10.8  总结 289\n10.9  复习题 289\n10.11  编程练习 290\n第11章  使用类 293\n11.1  运算符重载 294\n11.2  计算时间：一个运算符重载示例 295\n11.2.1  添加加法运算符 296\n11.2.2  重载限制 297\n11.2.3  其他重载运算符 298\n11.3  友元 298\n11.3.1  创建友元 300\n11.3.2  常用的友元：重载<<运算符 300\n11.4  重载运算符：作为成员函数还是非成员函数 304\n11.5  再谈重载：一个矢量类 304\n11.5.1  使用状态成员 307\n11.5.2  为Vector类重载算术运算符 308\n11.5.3  对实现的说明 309\n11.5.4  使用Vector类来模拟随机漫步 310\n11.6  类的自动转换和强制类型转换 311\n11.6.1  转换函数 314\n11.6.2  转换函数和友元函数 317\n11.7  总结 319\n11.8  复习题 320\n11.9  编程练习 320\n第12章  类和动态内存分配 323\n12.1  动态内存和类 324\n12.1.1  复习示例和静态类成员 324\n12.1.2  特殊成员函数 328\n12.1.3  回到Stringbad：复制构造函数的哪里出了问题 330\n12.1.4  Stringbad的其他问题：赋值运算符 333\n12.2  改进后的新String类 334\n12.2.1  修订后的默认构造函数 335\n12.2.2  比较成员函数 335\n12.2.3  使用中括号表示法访问字符 336\n12.2.4  静态类成员函数 337\n12.2.5  进一步重载赋值运算符 338\n12.3  在构造函数中使用new时应注意的事项 339\n12.3.1  应该和不应该 339\n12.3.2  包含类成员的类的逐成员复制 340\n12.4  有关返回对象的说明 340\n12.4.1  返回指向const对象的引用 340\n12.4.2  返回指向非const对象的引用 341\n12.4.3  返回对象 341\n12.4.4  返回const对象 341\n12.5  使用指向对象的指针 342\n12.5.1  再谈new和delete 343\n12.5.2  指针和对象小结 344\n12.5.3  再谈定位new运算符 345\n12.6  复习各种技术 346\n12.6.1  重载<<运算符 346\n12.6.2  转换函数 347\n12.6.3  其构造函数使用new的类 347\n12.7  队列模拟 347\n12.7.1  队列类 348\n12.7.2  Customer类 354\n12.7.3  ATM模拟 355\n12.8  总结 356\n12.9  复习题 357\n12.10  编程练习 357\n第13章  类继承 359\n13.1  一个简单的基类 360\n13.1.1  派生一个类 361\n13.1.2  构造函数：访问权限的考虑 362\n13.1.3  使用派生类 364\n13.1.4  派生类和基类之间的特殊关系 364\n13.2  继承：is-a关系 366\n13.3  多态公有继承 367\n13.3.1  开发Brass类和BrassPlus类 367\n13.4  静态联编和动态联编 371\n13.4.1  指针和引用类型的兼容性 371\n13.4.2  虚成员函数和动态联编 372\n13.4.3  有关虚函数注意事项 373\n13.5  访问控制：protected 375\n13.6  抽象基类 375\n13.6.1  应用ABC概念 377\n13.6.2  ABC理念 378\n13.7  继承和动态内存分配 378\n13.7.1  第一种情况：派生类不使用new 378\n13.7.2  第二种情况：派生类使用new 379\n13.7.3  使用动态内存分配和友元的继承示例 380\n13.8  类设计回顾 381\n13.8.1  编译器生成的成员函数 381\n13.8.2  其他的类方法 382\n13.8.3  公有继承的考虑因素 384\n13.8.4  类函数小结 386\n13.9  总结 387\n13.10  复习题 387\n13.11  编程练习 388\n第14章  C++中的代码重用 391\n14.1  包含对象成员的类 392\n14.1.1  valarray类简介 392\n14.1.2  Student类的设计 393\n14.1.3  Student类示例 394\n14.2  私有继承 396\n14.2.1  Student类示例（新版本） 396\n14.2.2  使用包含还是私有继承 398\n14.2.3  保护继承 399\n14.2.4  使用using重新定义访问权限 399\n14.3  多重继承 400\n14.3.1  有多少Worker 401\n14.3.2  哪个方法 404\n14.3.3  MI小结 406\n14.4  类模板 407\n14.4.1  定义类模板 407\n14.4.2  使用模板类 408\n14.4.3  深入探讨模板类 409\n14.4.4  数组模板示例和非类型参数 411\n14.4.5  模板多功能性 411\n14.4.6  模板的具体化 413\n14.4.7  成员模板 414\n14.4.8  将模板用作参数 415\n14.4.9  模板类和友元 416\n14.4.10  模板别名（C++11） 419\n14.5  总结 419\n14.6  复习题 421\n14.7  编程练习 421\n第15章  友元、异常和其他 425\n15.1  友元 426\n15.1.1  友元类 426\n15.1.2  友元成员函数 427\n15.1.3  其他友元关系 429\n15.2  嵌套类 429\n15.2.1  嵌套类和访问权限 430\n15.2.2  模板中的嵌套 431\n15.3  异常 432\n15.3.1  调用abort( ) 432\n15.3.2  返回错误码 432\n15.3.3  异常机制 433\n15.3.4  将对象用作异常类型 435\n15.3.4  异常规范和C++11 436\n15.3.5  栈解退 436\n15.3.6  其他异常特性 439\n15.3.7  exception类 440\n15.3.8  异常、类和继承 442\n15.3.9  异常何时会迷失方向 442\n15.3.10  有关异常的注意事项 444\n15.4  RTTI 445\n15.4.1  RTTI的用途 445\n15.4.2  RTTI的工作原理 445\n15.5  类型转换运算符 449\n15.6  总结 451\n15.7  复习题 451\n15.8  编程练习 452\n第16章  string类和标准模板库 453\n16.1  string类 454\n16.1.1  构造字符串 454\n16.1.2  string类输入 457\n16.1.3  使用字符串 458\n16.1.4  string还提供了哪些功能 460\n16.1.5  字符串种类 461\n16.2  智能指针模板类 461\n16.2.1  使用智能指针 462\n16.2.2  有关智能指针的注意事项 464\n16.2.3  unique_ptr为何优于auto_ptr 465\n16.2.4  选择智能指针 466\n16.3  标准模板库 466\n16.3.1  模板类vector 467\n16.3.2  可对矢量执行的操作 467\n16.3.3  对矢量可执行的其他操作 469\n16.3.4  基于范围的for循环（C++11） 471\n16.4  泛型编程 471\n16.4.1  为何使用迭代器 472\n16.4.2  迭代器类型 474\n16.4.3  迭代器层次结构 475\n16.4.4  概念、改进和模型 476\n16.4.5  容器种类 480\n16.4.4  关联容器 485\n16.4.5  无序关联容器（C++11） 488\n16.5  函数对象 488\n16.5.1  函数符概念 489\n16.5.2  预定义的函数符 490\n16.5.3  自适应函数符和函数适配器 491\n16.6  算法 493\n16.6.1  算法组 493\n16.6.2  算法的通用特征 493\n16.6.3  STL和string类 494\n16.6.4  函数和容器方法 494\n16.6.5  使用STL 495\n16.7  其他库 496\n16.7.1  vector、valarray和array 497\n16.7.2  模板initializer_list（C++11） 500\n16.7.3  使用initializer_list 500\n16.8  总结 501\n16.9  复习题 502\n16.10  编程练习 503\n第17章  输入、输出和文件 505\n17.1  C++输入和输出概述 506\n17.1.1  流和缓冲区 506\n17.1.2  流、缓冲区和iostream文件 508\n17.1.3  重定向 510\n17.2  使用cout进行输出 510\n17.2.1  重载的<<运算符 511\n17.2.2  其他ostream方法 512\n17.2.3  刷新输出缓冲区 514\n17.2.4  用cout进行格式化 515\n17.3  使用cin进行输入 522\n17.3.1  cin>>如何检查输入 523\n17.3.2  流状态 524\n17.3.3  其他istream类方法 527\n17.3.4  其他istream方法 530\n17.4  文件输入和输出 532\n17.4.1  简单的文件I/O 532\n17.4.2  流状态检查和is_open( ) 534\n17.4.3  打开多个文件 534\n17.4.3  命令行处理技术 535\n17.4.5  文件模式 536\n17.4.6  随机存取 540\n17.5  内核格式化 543\n17.6  总结 544\n17.7  复习题 545\n17.8  编程练习 546\n第18章  探讨C++新标准 549\n18.1  复习前面介绍过的C++11功能 550\n18.1.1  新类型 550\n18.8.2  统一的初始化 550\n18.1.3  声明 551\n18.1.4  智能指针 552\n18.1.5  异常规范方面的修改 552\n18.1.6  作用域内枚举 553\n18.1.7  对类的修改 553\n18.1.8  模板和STL方面的修改 554\n18.1.9  右值引用 555\n18.2  移动语义和右值引用 555\n18.2.1  为何需要移动语义 555\n18.2.2  一个移动示例 556\n18.2.3  移动构造函数解析 557\n18.2.4  赋值 558\n18.2.5  强制移动 558\n18.3  新的类功能 559\n18.3.1  特殊的成员函数 559\n18.3.2  默认的方法和禁用的方法 559\n18.3.3  委托构造函数 560\n18.3.4  继承构造函数 560\n18.3.5  管理虚方法：override和final 561\n18.4  Lambda函数 561\n18.4.1  比较函数指针、函数符和Lambda函数 562\n18.4.2  为何使用lambda 563\n18.5  包装器 564\n18.5.1  包装器function及模板的低效性 565\n18.5.2  修复问题 566\n18.5.3  其他方式 566\n18.6  可变参数模板 567\n18.6.1  模板和函数参数包 567\n18.6.2  展开参数包 568\n18.6.3  在可变参数模板函数中使用递归 568\n18.7  C++11新增的其他功能 570\n18.7.1  并行编程 570\n18.7.2  新增的库 570\n18.7.3  低级编程 570\n18.7.4  杂项 571\n18.8  语言变化 571\n18.8.1  Boost项目 571\n18.8.2  TR1 572\n18.8.3  使用Boost 572\n18.9  接下来的任务 572\n18.10  总结 573\n18.11  复习题 573\n18.12  编程练习 574\n附录A  计数系统 575\nA.1  十进制数 576\nA.2  八进制整数 576\nA.3  十六进制数 576\nA.4  二进制数 577\nA.5  二进制和十六进制 577\n附录B  C++保留字 579\nB.1  C++关键字 580\nB.2  替代标记 580\nB.3  C++库保留名称 580\nB.4  有特殊含义的标识符 581\n附录C  ASCII字符集 583\n附录D  运算符优先级 589\n附录E  其他运算符 593\nE.1  按位运算符 594\nE.1.1  移位运算符 594\nE.1.2  逻辑按位运算符 595\nE.1.3  按位运算符的替代表示 597\nE.1.4  几种常用的按位运算符技术 598\nE.2  成员解除引用运算符 599\nE.3  alignof（C++11） 600\nE.4  noexcept（C++11） 601\n附录F  模板类string 603\nF.1  13种类型和一个常量 604\nF.2  数据信息、构造函数及其他 605\nF.2.1  默认构造函数 606\nF.2.2  使用C-风格字符串的构造函数 607\nF.2.3  使用部分C-风格字符串的构造函数 607\nF.2.4  使用左值引用的构造函数 607\nF.2.5  使用右值引用的构造函数（C++11） 608\nF.2.6  使用一个字符的n个副本的构造函数 609\nF.2.7  使用区间的构造函数 609\nF.2.8  使用初始化列表的构造函数（C++11） 609\nF.2.9  内存杂记 610\nF.3  字符串存取 610\nF.4  基本赋值 611\nF.5  字符串搜索 611\nF.5.1  find( )系列 611\nF.5.2  rfind( )系列 612\nF.5.3  find_first_of( )系列 612\nF.5.4  find_last_of( )系列 612\nF.5.5  find_first_not_of( )系列 612\nF.5.6  find_last_not_of( )系列 613\nF.6  比较方法和函数 613\nF.7  字符串修改方法 614\nF.7.1  用于追加和相加的方法 614\nF.7.2  其他赋值方法 614\nF.7.3  插入方法 614\nF.7.4  清除方法 615\nF.7.5  替换方法 615\nF.7.6  其他修改方法：copy( )和swap( ) 615\nF.8  输出和输入 616\n附录G  标准模板库方法和函数 617\nG.1  STL和C++11 618\nG.1.1  新增的容器 618\nG.1.2  对C++98容器所做的修改 618\nG.2  大部分容器都有的成员 619\nG.3  序列容器的其他成员 621\nG.4  set和map的其他操作 623\nG.4  无序关联容器（C++11） 625\nG.5  STL函数 626\nG.5.1  非修改式序列操作 626\nG.5.2  修改式序列操作 629\nG.5.3  排序和相关操作 635\nG.5.4  数值运算 642\n附录H  精选读物和网上资源 645\nH.1  精选读物 646\nH.2  网上资源 647\n附录I  转换为ISO标准C++ 649\nI.1  使用一些预处理器编译指令的替代品 650\nI.1.1  使用const而不是#define来定义常量 650\nI.1.2  使用inline而不是# define来定义小型函数 651\nI.2  使用函数原型 651\nI.3  使用类型转换 652\nI.4  熟悉C++特性 652\nI.5  使用新的头文件 652\nI.6  使用名称空间 652\nI.7  使用智能指针 653\nI.8  使用string类 653\nI.9  使用STL 654\n附录J  复习题答案 655\n第2章复习题答案 656\n第3章复习题答案 656\n第4章复习题答案 657\n第5章复习题答案 658\n第6章复习题答案 659\n第7章复习题答案 660\n第8章复习题答案 661\n第9章复习题答案 662\n第10章复习题答案 662\n第11章复习题答案 663\n第12章复习题答案 664\n第13章复习题答案 665\n第14章复习题答案 665\n第15章复习题答案 666\n第16章复习题答案 667\n第17章复习题答案 667\n第18章复习题答案 668\n\"",
        "pages": "936",
        "images": {
          "small": "https://img3.doubanio.com/spic/s10307483.jpg",
          "large": "https://img3.doubanio.com/lpic/s10307483.jpg",
          "medium": "https://img3.doubanio.com/mpic/s10307483.jpg"
        },
        "alt": "https://book.douban.com/subject/10789789/",
        "id": "10789789",
        "publisher": "人民邮电出版社",
        "isbn10": "7115279462",
        "isbn13": "9787115279460",
        "title": "C++ Primer Plus",
        "url": "https://api.douban.com/v2/book/10789789",
        "alt_title": "C++ Primer Plus, 6th Edition",
        "author_intro": "Stephen Prata在美国加州肯特菲尔得的马林学院教授天文、物理和计算机科学。他毕业于加州理工学院，在美国加州大学伯克利分校获得博士学位。他单独或与他人合作编写的编程图书有十多本，其中《New C Primer Plus》获得了计算机出版联合会1990年度最佳“How-to”计算机图书奖，《C++ Primer Plus》获得了计算机出版联合会1991年度最佳“How-to”计算机图书奖提名。",
        "summary": "C++是在C语言基础上开发的一种集面向对象编程、通用编程和传统的过程化编程于一体的编程语言，是C语言的超集。本书是根据2003年的ISO/ANSI C++标准编写的。通过大量短小精悍的程序详细而全面地阐述了C++的基本概念和技术。全书分为18章和10个附录，分别介绍了C++程序的运行方式、基本数据类型、复合数据类型、循环和关系表达式、分支语句和逻辑操作符、函数重载和函数模板、内存模型和名称空间、类的设计和使用、多态、虚函数、动态内存分配、继承、代码重用、友元、异常处理技术、string类和标准模板库、输入/输出等内容。本书针对C++初学者，从C语言基础知识开始介绍，然后在此基础上详细阐述C++新增的特性，因此不要求读者有较多C语言方面的背景知识。本书可以作为高等院校C++课程的教材，也可以供初学者自学C++时使用。",
        "series": {
          "id": "23545",
          "title": "C和C++实务精选"
        },
        "price": "99.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "10e19996ff8031d2340ddf7c5349febecaf2308a0b7c94cffa699b7de5c2f9db",
        "file": "C++ Primer Plus  第6版  中文版.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 852,
          "average": "9.3",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[美] Stanley B. Lippman",
          "[美] Josée Lajoie",
          "[美] Barbara E. Moo"
        ],
        "pubdate": "2013-9-1",
        "tags": [
          {
            "count": 1068,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 460,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 348,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 300,
            "name": "C++11",
            "title": "C++11"
          },
          {
            "count": 256,
            "name": "编程语言",
            "title": "编程语言"
          },
          {
            "count": 233,
            "name": "C/C++",
            "title": "C/C++"
          },
          {
            "count": 229,
            "name": "经典",
            "title": "经典"
          },
          {
            "count": 202,
            "name": "程序设计",
            "title": "程序设计"
          }
        ],
        "origin_title": "C++ Primer, 5th Edition",
        "image": "https://img3.doubanio.com/mpic/s27023182.jpg",
        "binding": "平装",
        "translator": [
          "王刚",
          "杨巨峰"
        ],
        "catalog": "第1章  开始\t1\n1.1  编写一个简单的C++程序\t2\n1.1.1  编译、运行程序\t3\n1.2  初识输入输出\t5\n1.3  注释简介\t8\n1.4  控制流\t10\n1.4.1  while语句\t10\n1.4.2  for语句\t11\n1.4.3  读取数量不定的输入数据\t13\n1.4.4  if语句\t15\n1.5  类简介\t17\n1.5.1  Sales_item类\t17\n1.5.2  初识成员函数\t20\n1.6  书店程序\t21\n小结\t23\n术语表\t23\n第Ⅰ部分  C++基础\t27\n第2章  变量和基本类型\t29\n2.1  基本内置类型\t30\n2.1.1  算术类型\t30\n2.1.2  类型转换\t32\n2.1.3  字面值常量\t35\n2.2  变量\t38\n2.2.1  变量定义\t38\n2.2.2  变量声明和定义的关系\t41\n2.2.3  标识符\t42\n2.2.4  名字的作用域\t43\n2.3  复合类型\t45\n2.3.1  引用\t45\n2.3.2  指针\t47\n2.3.3  理解复合类型的声明\t51\n2.4  const限定符\t53\n2.4.1  const的引用\t54\n2.4.2  指针和const\t56\n2.4.3  顶层const\t57\n2.4.4  constexpr和常量表达式\t58\n2.5  处理类型\t60\n2.5.1  类型别名\t60\n2.5.2  auto类型说明符\t61\n2.5.3  decltype类型指示符\t62\n2.6  自定义数据结构\t64\n2.6.1  定义Sales_data类型\t64\n2.6.2  使用Sales_data类\t66\n2.6.3  编写自己的头文件\t67\n小结\t69\n术语表\t69\n第3章  字符串、向量和数组\t73\n3.1  命名空间的using声明\t74\n3.2  标准库类型string\t75\n3.2.1  定义和初始化string对象\t76\n3.2.2  string对象上的操作\t77\n3.2.3  处理string对象中的字符\t81\n3.3  标准库类型vector\t86\n3.3.1  定义和初始化vector对象\t87\n3.3.2  向vector对象中添加元素\t90\n3.3.3  其他vector操作\t91\n3.4  迭代器介绍\t95\n3.4.1  使用迭代器\t95\n3.4.2  迭代器运算\t99\n3.5  数组\t101\n3.5.1  定义和初始化内置数组\t101\n3.5.2  访问数组元素\t103\n3.5.3  指针和数组\t105\n3.5.4  C风格字符串\t109\n3.5.5  与旧代码的接口\t111\n3.6  多维数组\t112\n小结\t117\n术语表\t117\n第4章  表达式\t119\n4.1  基础\t120\n4.1.1  基本概念\t120\n4.1.2  优先级与结合律\t121\n4.1.3  求值顺序\t123\n4.2  算术运算符\t124\n4.3  逻辑和关系运算符\t126\n4.4  赋值运算符\t129\n4.5  递增和递减运算符\t131\n4.6  成员访问运算符\t133\n4.7  条件运算符\t134\n4.8  位运算符\t135\n4.9  sizeof运算符\t139\n4.10  逗号运算符\t140\n4.11  类型转换\t141\n4.11.1  算术转换\t142\n4.11.2  其他隐式类型转换\t143\n4.11.3  显式转换\t144\n4.12  运算符优先级表\t147\n小结\t149\n术语表\t149\n第5章  语句\t153\n5.1  简单语句\t154\n5.2  语句作用域\t155\n5.3  条件语句\t156\n5.3.1  if语句\t156\n5.3.2  switch语句\t159\n5.4  迭代语句\t165\n5.4.1  while语句\t165\n5.4.2  传统的for语句\t166\n5.4.3  范围for语句\t168\n5.4.4  do while语句\t169\n5.5  跳转语句\t170\n5.5.1  break语句\t170\n5.5.2  continue语句\t171\n5.5.3  goto语句\t172\n5.6  TRY语句块和异常处理\t172\n5.6.1  throw表达式\t173\n5.6.2  try语句块\t174\n5.6.3  标准异常\t176\n小结\t178\n术语表\t178\n第6章  函数\t181\n6.1  函数基础\t182\n6.1.1  局部对象\t184\n6.1.2  函数声明\t186\n6.1.3  分离式编译\t186\n6.2  参数传递\t187\n6.2.1  传值参数\t187\n6.2.2  传引用参数\t188\n6.2.3  const形参和实参\t190\n6.2.4  数组形参\t193\n6.2.5  main：处理命令行选项\t196\n6.2.6  含有可变形参的函数\t197\n6.3  返回类型和return语句\t199\n6.3.1  无返回值函数\t200\n6.3.2  有返回值函数\t200\n6.3.3  返回数组指针\t205\n6.4  函数重载\t206\n6.4.1  重载与作用域\t210\n6.5  特殊用途语言特性\t211\n6.5.1  默认实参\t211\n6.5.2  内联函数和constexpr函数\t213\n6.5.3  调试帮助\t215\n6.6  函数匹配\t217\n6.6.1  实参类型转换\t219\n6.7  函数指针\t221\n小结\t225\n术语表\t225\n第7章  类\t227\n7.1  定义抽象数据类型\t228\n7.1.1  设计Sales_data类\t228\n7.1.2  定义改进的Sales_data类\t230\n7.1.3  定义类相关的非成员函数\t234\n7.1.4  构造函数\t235\n7.1.5  拷贝、赋值和析构\t239\n7.2  访问控制与封装\t240\n7.2.1  友元\t241\n7.3  类的其他特性\t243\n7.3.1  类成员再探\t243\n7.3.2  返回*this的成员函数\t246\n7.3.3  类类型\t249\n7.3.4  友元再探\t250\n7.4  类的作用域\t253\n7.4.1  名字查找与类的作用域\t254\n7.5  构造函数再探\t257\n7.5.1  构造函数初始值列表\t258\n7.5.2  委托构造函数\t261\n7.5.3  默认构造函数的作用\t262\n7.5.4  隐式的类类型转换\t263\n7.5.5  聚合类\t266\n7.5.6  字面值常量类\t267\n7.6  类的静态成员\t268\n小结\t273\n术语表\t273\n第Ⅱ部  C++标准库\t275\n第8章  IO库\t277\n8.1  IO类\t278\n8.1.1  IO对象无拷贝或赋值\t279\n8.1.2  条件状态\t279\n8.1.3  管理输出缓冲\t281\n8.2  文件输入输出\t283\n8.2.1  使用文件流对象\t284\n8.2.2  文件模式\t286\n8.3  string流\t287\n8.3.1  使用istringstream\t287\n8.3.2  使用ostringstream\t289\n小结\t290\n术语表\t290\n第9章  顺序容器\t291\n9.1  顺序容器概述\t292\n9.2  容器库概览\t294\n9.2.1  迭代器\t296\n9.2.2  容器类型成员\t297\n9.2.3  begin和end成员\t298\n9.2.4  容器定义和初始化\t299\n9.2.5  赋值和swap\t302\n9.2.6  容器大小操作\t304\n9.2.7  关系运算符\t304\n9.3  顺序容器操作\t305\n9.3.1  向顺序容器添加元素\t305\n9.3.2  访问元素\t309\n9.3.3  删除元素\t311\n9.3.4  特殊的forward_list操作\t312\n9.3.5  改变容器大小\t314\n9.3.6  容器操作可能使迭代器失效\t315\n9.4  vector对象是如何增长的\t317\n9.5  额外的string操作\t320\n9.5.1  构造string的其他方法\t321\n9.5.2  改变string的其他方法\t322\n9.5.3  string搜索操作\t325\n9.5.4  compare函数\t327\n9.5.5  数值转换\t327\n9.6  容器适配器\t329\n小结\t332\n术语表\t332\n第10章  泛型算法\t335\n10.1  概述\t336\n10.2  初识泛型算法\t338\n10.2.1  只读算法\t338\n10.2.2  写容器元素的算法\t339\n10.2.3  重排容器元素的算法\t342\n10.3  定制操作\t344\n10.3.1  向算法传递函数\t344\n10.3.2  lambda表达式\t345\n10.3.3  lambda捕获和返回\t349\n10.3.4  参数绑定\t354\n10.4  再探迭代器\t357\n10.4.1  插入迭代器\t358\n10.4.2  iostream迭代器\t359\n10.4.3  反向迭代器\t363\n10.5  泛型算法结构\t365\n10.5.1  5类迭代器\t365\n10.5.2  算法形参模式\t367\n10.5.3  算法命名规范\t368\n10.6  特定容器算法\t369\n小结\t371\n术语表\t371\n第11章  关联容器\t373\n11.1  使用关联容器\t374\n11.2  关联容器概述\t376\n11.2.1  定义关联容器\t376\n11.2.2  关键字类型的要求\t378\n11.2.3  pair类型\t379\n11.3  关联容器操作\t381\n11.3.1  关联容器迭代器\t382\n11.3.2  添加元素\t383\n11.3.3  删除元素\t386\n11.3.4  map的下标操作\t387\n11.3.5  访问元素\t388\n11.3.6  一个单词转换的map\t391\n11.4  无序容器\t394\n小结\t397\n术语表\t397\n第12章  动态内存\t399\n12.1  动态内存与智能指针\t400\n12.1.1  shared_ptr类\t400\n12.1.2  直接管理内存\t407\n12.1.3  shared_ptr和new结合使用\t412\n12.1.4  智能指针和异常\t415\n12.1.5  unique_ptr\t417\n12.1.6  weak_ptr\t420\n12.2  动态数组\t423\n12.2.1  new和数组\t423\n12.2.2  allocator类\t427\n12.3  使用标准库：文本查询程序\t430\n12.3.1  文本查询程序设计\t430\n12.3.2  文本查询程序类的定义\t432\n小结\t436\n术语表\t436\n第Ⅲ部分  类设计者的工具\t437\n第13章  拷贝控制\t439\n13.1  拷贝、赋值与销毁\t440\n13.1.1  拷贝构造函数\t440\n13.1.2  拷贝赋值运算符\t443\n13.1.3  析构函数\t444\n13.1.4  三/五法则\t447\n13.1.5  使用=default\t449\n13.1.6  阻止拷贝\t449\n13.2  拷贝控制和资源管理\t452\n13.2.1  行为像值的类\t453\n13.2.2  定义行为像指针的类\t455\n13.3  交换操作\t457\n13.4  拷贝控制示例\t460\n13.5  动态内存管理类\t464\n13.6  对象移动\t470\n13.6.1  右值引用\t471\n13.6.2  移动构造函数和移动赋值运算符\t473\n13.6.3  右值引用和成员函数\t481\n小结\t486\n术语表\t486\n第14章  操作重载与类型转换\t489\n14.1  基本概念\t490\n14.2  输入和输出运算符\t494\n14.2.1  重载输出运算符<<\t494\n14.2.2  重载输入运算符>>\t495\n14.3  算术和关系运算符\t497\n14.3.1  相等运算符\t497\n14.3.2  关系运算符\t498\n14.4  赋值运算符\t499\n14.5  下标运算符\t501\n14.6  递增和递减运算符\t502\n14.7  成员访问运算符\t504\n14.8  函数调用运算符\t506\n14.8.1  lambda是函数对象\t507\n14.8.2  标准库定义的函数对象\t509\n14.8.3  可调用对象与function\t511\n14.9  重载、类型转换与运算符\t514\n14.9.1  类型转换运算符\t514\n14.9.2  避免有二义性的类型转换\t517\n14.9.3  函数匹配与重载运算符\t521\n小结\t523\n术语表\t523\n第15章  面向对象程序设计\t525\n15.1  OOP：概述\t526\n15.2  定义基类和派生类\t527\n15.2.1  定义基类\t528\n15.2.2  定义派生类\t529\n15.2.3  类型转换与继承\t534\n15.3  虚函数\t536\n15.4  抽象基类\t540\n15.5  访问控制与继承\t542\n15.6  继承中的类作用域\t547\n15.7  构造函数与拷贝控制\t551\n15.7.1  虚析构函数\t552\n15.7.2  合成拷贝控制与继承\t552\n15.7.3  派生类的拷贝控制成员\t554\n15.7.4  继承的构造函数\t557\n15.8  容器与继承\t558\n15.8.1  编写Basket类\t559\n15.9  文本查询程序再探\t562\n15.9.1  面向对象的解决方案\t563\n15.9.2  Query_base类和Query类\t567\n15.9.3  派生类\t568\n15.9.4  eval函数\t571\n小结\t575\n术语表\t575\n第16章  模板与泛型编程\t577\n16.1  定义模板\t578\n16.1.1  函数模板\t578\n16.1.2  类模板\t583\n16.1.3  模板参数\t592\n16.1.4  成员模板\t595\n16.1.5  控制实例化\t597\n16.1.6  效率与灵活性\t599\n16.2  模板实参推断\t600\n16.2.1  类型转换与模板类型参数\t601\n16.2.2  函数模板显式实参\t603\n16.2.3  尾置返回类型与类型转换\t604\n16.2.4  函数指针和实参推断\t607\n16.2.5  模板实参推断和引用\t608\n16.2.6  理解std::move\t610\n16.2.7  转发\t612\n16.3  重载与模板\t614\n16.4  可变参数模板\t618\n16.4.1  编写可变参数函数模板\t620\n16.4.2  包扩展\t621\n16.4.3  转发参数包\t622\n16.5  模板特例化\t624\n小结\t630\n术语表\t630\n第Ⅳ部分  高级主题\t633\n第17章  标准库特殊设施\t635\n17.1  tuple类型\t636\n17.1.1  定义和初始化tuple\t637\n17.1.2  使用tuple返回多个值\t638\n17.2  BITSET类型\t640\n17.2.1  定义和初始化bitset\t641\n17.2.2  bitset操作\t643\n17.3  正则表达式\t645\n17.3.1  使用正则表达式库\t646\n17.3.2  匹配与Regex迭代器类型\t650\n17.3.3  使用子表达式\t653\n17.3.4  使用regex_replace\t657\n17.4  随机数\t659\n17.4.2  其他随机数分布\t663\nbernoulli_distribution类\t665\n17.5  IO库再探\t666\n17.5.1  格式化输入与输出\t666\n17.5.2  未格式化的输入/输出操作\t673\n17.5.3  流随机访问\t676\n小结\t680\n术语表\t680\n第18章  用于大型程序的工具\t683\n18.1  异常处理\t684\n18.1.1  抛出异常\t684\n18.1.2  捕获异常\t687\n18.1.3  函数try语句块与构造函数\t689\n18.1.4  noexcept异常说明\t690\n18.1.5  异常类层次\t693\n18.2  命名空间\t695\n18.2.1  命名空间定义\t695\n18.2.2  使用命名空间成员\t701\n18.2.3  类、命名空间与作用域\t705\n18.2.4  重载与命名空间\t708\n18.3  多重继承与虚继承\t710\n18.3.1  多重继承\t711\n18.3.2  类型转换与多个基类\t713\n18.3.3  多重继承下的类作用域\t715\n18.3.4  虚继承\t717\n18.3.5  构造函数与虚继承\t720\n小结\t722\n术语表\t722\n第19章  特殊工具与技术\t725\n19.1  控制内存分配\t726\n19.1.1  重载new和delete\t726\n19.1.2  定位new表达式\t729\n19.2  运行时类型识别\t730\n19.2.1  dynamic_cast运算符\t730\n19.2.2  typeid运算符\t732\n19.2.3  使用RTTI\t733\n19.2.4  type_info类\t735\n19.3  枚举类型\t736\n19.4  类成员指针\t739\n19.4.1  数据成员指针\t740\n19.4.2  成员函数指针\t741\n19.4.3  将成员函数用作可调用对象\t744\n19.5  嵌套类\t746\n19.6  union：一种节省空间的类\t749\n19.7  局部类\t754\n19.8  固有的不可移植的特性\t755\n19.8.1  位域\t756\n19.8.2  volatile限定符\t757\n19.8.3  链接指示：extern \"C\"\t758\n小结\t762\n术语表\t762\n附录A  标准库\t765\nA.1  标准库名字和头文件\t766\nA.2  算法概览\t770\nA.2.1  查找对象的算法\t771\nA.2.2  其他只读算法\t772\nA.2.3  二分搜索算法\t772\nA.2.4  写容器元素的算法\t773\nA.2.5  划分与排序算法\t775\nA.2.6  通用重排操作\t776\nA.2.7  排列算法\t778\nA.2.8  有序序列的集合算法\t778\nA.2.9  最小值和最大值\t779\nA.2.10  数值算法\t780\nA.3  随机数\t781\nA.3.1  随机数分布\t781\nA.3.2  随机数引擎\t783\nC++11的新特性\n2.1.1  long long类型\t31\n2.2.1  列表初始化\t39\n2.3.2  nullptr常量\t48\n2.4.4  constexpr变量\t59\n2.5.1  类型别名声明\t60\n2.5.2  auto类型指示符\t61\n2.5.3  decltype类型指示符\t62\n2.6.1  类内初始化\t65\n3.2.2  使用auto或decltype缩写类型\t79\n3.2.3  范围for语句\t82\n3.3   定义vector对象的vector（向量的向量）\t87\n3.3.1  vector对象的列表初始化\t88\n3.4.1  容器的cbegin和cend函数\t98\n3.5.3  标准库begin和end函数\t106\n3.6   使用auto和decltype简化声明\t115\n4.2   除法的舍入规则\t125\n4.4   用大括号包围的值列表赋值\t129\n4.9   将sizeof用于类成员\t139\n5.4.3 范围for语句\t168\n6.2.6  标准库initializer_list类\t197\n6.3.2  列表初始化返回值\t203\n6.3.3  定义尾置返回类型\t206\n6.3.3  使用decltype简化返回类型定义\n6.5.2  constexpr函数\t214\n7.1.4  使用=default生成默认构造函数\t237\n7.3.1  类对象成员的类内初始化\t246\n7.5.2  委托构造函数\t261\n7.5.6  constexpr构造函数\t268\n8.2.1  用string对象处理文件名\t284\n9.1   array和forward_list容器\t293\n9.2.3 容器的cbegin和cend函数\t298\n9.2.4  容器的列表初始化\t300\n9.2.5  容器的非成员函数swap\t303\n9.3.1  容器insert成员的返回类型\t308\n9.3.1  容器的emplace成员的返回类型\t308\n9.4   shrink_to_fit\t318\n9.5.5  string的数值转换函数\t327\n10.3.2  Lambda表达式\t346\n10.3.3  Lambda表达式中的尾置返回类型\t353\n10.3.4  标准库bind函数\t354\n11.2.1  关联容器的列表初始化\t377\n11.2.3  列表初始化pair的返回类型\t380\n11.3.2  pair的列表初始化\t384\n11.4   无序容器\t394\n12.1   智能指针\t400\n12.1.1  shared_ptr类\n12.1.2  动态分配对象的列表初始化\t407\n12.1.2  auto和动态分配\t408\n12.1.5  unique_ptr类\t417\n12.1.6  weak_ptr类\t420\n12.2.1  范围for语句不能应用于动态分配数组\t424\n12.2.1  动态分配数组的列表初始化\t424\n12.2.1  auto不能用于分配数组\t424\n12.2.2  allocator::construct可使用任意构造函数\t428\n13.1.5  将=default用于拷贝控制成员\t449\n13.1.6  使用=default阻止拷贝类对象\t449\n13.5   用移动类对象代替拷贝类对象\t469\n13.6.1  右值引用\t471\n13.6.1  标准库move函数\t472\n13.6.2  移动构造函数和移动赋值\t473\n13.6.2  移动构造函数通常应该是noexcept\t473\n13.6.2  移动迭代器\t480\n13.6.3  引用限定成员函数\t483\n14.8.3  function类模板\t512\n14.9.1  explicit类型转换运算符\t516\n15.2.2  虚函数的override指示符\t530\n15.2.2  通过定义类为final来阻止继承\t533\n15.3   虚函数的override和final指示符\t538\n15.7.2  删除的拷贝控制和继承\t553\n15.7.4  继承的构造函数\t557\n16.1.2  声明模板类型形参为友元\t590\n16.1.2  模板类型别名\t590\n16.1.3  模板函数的默认模板参数\t594\n16.1.5  实例化的显式控制\t597\n16.2.3  模板函数与尾置返回类型\t605\n16.2.5  引用折叠规则\t609\n16.2.6  用static_cast将左值转换为右值\t612\n16.2.7  标准库forward函数\t614\n16.4   可变参数模板\t618\n16.4   sizeof...运算符\t619\n16.4.3  可变参数模板与转发\t622\n17.1   标准库Tuple类模板\t636\n17.2.2  新的bitset运算\t643\n17.3   正则表达式库\t645\n17.4   随机数库\t659\n17.5.1  浮点数格式控制\t670\n18.1.4  noexcept异常指示符\t690\n18.1.4  noexcept运算符\t691\n18.2.1  内联名字空间\t699\n18.3.1  继承的构造函数和多重继承\t712\n19.3   有作用域的enum\t736\n19.3   说明类型用于保存enum对象\t738\n19.3   enum的提前声明\t738\n19.4.3  标准库mem_fn类模板\t746\n19.6   类类型的联合成员\t751",
        "pages": "838",
        "images": {
          "small": "https://img3.doubanio.com/spic/s27023182.jpg",
          "large": "https://img3.doubanio.com/lpic/s27023182.jpg",
          "medium": "https://img3.doubanio.com/mpic/s27023182.jpg"
        },
        "alt": "https://book.douban.com/subject/25708312/",
        "id": "25708312",
        "publisher": "电子工业出版社",
        "isbn10": "7121155354",
        "isbn13": "9787121155352",
        "title": "C++ Primer 中文版（第 5 版）",
        "url": "https://api.douban.com/v2/book/25708312",
        "alt_title": "C++ Primer, 5th Edition",
        "author_intro": "Stanley B. Lippman目前是微软公司 Visual C++ 团队的架构师。他从1984年开始在贝尔实验室与C++的设计者Bjarne Stroustrup一起从事C++的设计与开发。他在迪士尼和梦工厂从事动画制作，还担任过JPL的高级顾问。\nJosée Lajoie曾经是IBM加拿大研究中心C/C++编译器开发团队的成员，在ISO C++标准委员会工作了7年，担任过ISO核心语言工作组的主席和C++ Report杂志的专栏作家。\nBarbara E. Moo是拥有25年软件经验的独立咨询顾问。在AT&T，她与Stroustrup、Lippman一起管理过复杂的C++开发项目。",
        "summary": "这本久负盛名的 C++经典教程，时隔八年之久，终迎来史无前例的重大升级。除令全球无数程序员从中受益，甚至为之迷醉的——C++ 大师 Stanley B. Lippman 的丰富实践经验，C++标准委员会原负责人 Josée Lajoie 对C++标准的深入理解，以及C++ 先驱 Barbara E. Moo 在 C++教学方面的真知灼见外，更是基于全新的 C++11标准进行了全面而彻底的内容更新。非常难能可贵的是，《C++ Primer 中文版(第5版)》所有示例均全部采用 C++11 标准改写，这在经典升级版中极其罕见——充分体现了 C++ 语言的重大进展及其全面实践。书中丰富的教学辅助内容、醒目的知识点提示，以及精心组织的编程示范，让这本书在 C++ 领域的权威地位更加不可动摇。无论是初学者入门，或是中、高级程序员提升，本书均为不容置疑的首选。",
        "price": "CNY 128.00",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "322d5d6f0b48ad11b7b80b3122db78d8a2b3194946ac5766810cf7ac2803287d",
        "file": "C++Primer 第5版.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 47,
          "average": "5.8",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "Anthony Williams"
        ],
        "pubdate": "2015-5",
        "tags": [
          {
            "count": 53,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 39,
            "name": "并发编程",
            "title": "并发编程"
          },
          {
            "count": 27,
            "name": "多线程",
            "title": "多线程"
          },
          {
            "count": 20,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 12,
            "name": "并发",
            "title": "并发"
          },
          {
            "count": 10,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 10,
            "name": "programming",
            "title": "programming"
          },
          {
            "count": 9,
            "name": "计算机科学",
            "title": "计算机科学"
          }
        ],
        "origin_title": "C++ Concurrency in Action",
        "image": "https://img1.doubanio.com/mpic/s28077549.jpg",
        "binding": "",
        "translator": [
          "周全",
          "梁娟娟",
          "宋真真",
          "许敏"
        ],
        "catalog": "目录\n第1章 你好，C++并发世界 1\n1.1 什么是并发 2\n1.1.1 计算机系统中的并发 2\n1.1.2 并发的途径 3\n1.2 为什么使用并发 5\n1.2.1 为了划分关注点而使用并发 5\n1.2.2 为了性能而使用并发 6\n1.2.3 什么时候不使用并发 7\n1.3 在C++中使用并发和多线程 8\n1.3.1 C++多线程历程 8\n1.3.2 新标准中的并发支持 9\n1.3.3 C++线程库的效率 9\n1.3.4 平台相关的工具 10\n1.4 开始入门 11\n1.5 小结 12\n第2章 管理线程 13\n2.1 基本线程管理 13\n2.1.1 启动线程 14\n2.1.2 等待线程完成 16\n2.1.3 在异常环境下的等待 17\n2.1.4 在后台运行线程 19\n2.2 传递参数给线程函数 20\n2.3 转移线程的所有权 23\n2.4 在运行时选择线程数量 26\n2.5 标识线程 28\n2.6 小结 29\n第3章 在线程间共享数据 31\n3.1 线程之间共享数据的问题 32\n3.1.1 竞争条件 33\n3.1.2 避免有问题的竞争条件 34\n3.2 用互斥元保护共享数据 35\n3.2.1 使用C++中的互斥元 35\n3.2.2 为保护共享数据精心组织代码 36\n3.2.3 发现接口中固有的竞争条件 38\n3.2.4 死锁：问题和解决方案 44\n3.2.5 避免死锁的进一步指南 46\n3.2.6 用std::unique_lock灵活锁定 51\n3.2.7 在作用域之间转移锁的所有权 52\n3.2.8 锁定在恰当的粒度 54\n3.3 用于共享数据保护的替代工具 56\n3.3.1 在初始化时保护共享数据 56\n3.3.2 保护很少更新的数据结构 59\n3.3.3 递归锁 61\n3.4 小结 62\n第4章 同步并发操作 63\n4.1 等待事件或其他条件 63\n4.1.1 用条件变量等待条件 65\n4.1.2 使用条件变量建立一个线程安全队列 67\n4.2 使用future等待一次性事件 71\n4.2.1 从后台任务中返回值 72\n4.2.2 将任务与future相关联 74\n4.2.3 生成(std::)promise 77\n4.2.4 为future保存异常 79\n4.2.5 等待自多个线程 80\n4.3 有时间限制的等待 82\n4.3.1 时钟 83\n4.3.2 时间段 84\n4.3.3 时间点 85\n4.3.4 接受超时的函数 86\n4.4 使用操作同步来简化代码 88\n4.4.1 带有future的函数式编程 88\n4.4.2 具有消息传递的同步操作 92\n4.5 小结 96\n第5章 C++内存模型和原子类型上操作 97\n5.1 内存模型基础 98\n5.1.1 对象和内存位置 98\n5.1.2 对象、内存位置以及并发 99\n5.1.3 修改顺序 100\n5.2 C++中的原子操作及类型 100\n5.2.1 标准原子类型 101\n5.2.2 std::atomic_flag上的操作 103\n5.2.3 基于std::atomicbool的操作 105\n5.2.4 std::atomicT*上的操作：指针算术运算 107\n5.2.5 标准原子整型的操作 108\n5.2.6 std::atomic初级类模板 109\n5.2.7 原子操作的自由函数 111\n5.3 同步操作和强制顺序 112\n5.3.1 synchronizes-with关系 114\n5.3.2 happens-before关系 114\n5.3.3 原子操作的内存顺序 116\n5.3.4 释放序列和synchronizes-with 133\n5.3.5 屏障 135\n5.3.6 用原子操作排序非原子操作 137\n5.4 小结 138\n第6章 设计基于锁的并发数据结构 140\n6.1 为并发设计的含义是什么 141\n6.2 基于锁的并发数据结构 142\n6.2.1 使用锁的线程安全栈 142\n6.2.2 使用锁和条件变量的线程安全队列 145\n6.2.3 使用细粒度锁和条件变量的线程安全队列 149\n6.3 设计更复杂的基于锁的数据结构 160\n6.3.1 编写一个使用锁的线程安全查找表 160\n6.3.2 编写一个使用锁的线程安全链表 165\n6.4 小结 169\n第7章 设计无锁的并发数据结构 170\n7.1 定义和结果 171\n7.1.1 非阻塞数据结构的类型 171\n7.1.2 无锁数据结构 172\n7.1.3 无等待的数据结构 172\n7.1.4 无锁数据结构的优点与缺点 172\n7.2 无锁数据结构的例子 173\n7.2.1 编写不用锁的线程安全栈 174\n7.2.2 停止恼人的泄漏：在无锁数据结构中管理内存 178\n7.2.3 用风险指针检测不能被回收的结点 182\n7.2.4 使用引用计数检测结点 189\n7.2.5 将内存模型应用至无锁栈 194\n7.2.6 编写不用锁的线程安全队列 198\n7.3 编写无锁数据结构的准则 209\n7.3.1 准则：使用std::memory_order_seq_cst作为原型 210\n7.3.2 准则：使用无锁内存回收模式 210\n7.3.3 准则：当心ABA问题 210\n7.3.4 准则：识别忙于等待的循环以及辅助其他线程 211\n7.4 小结 211\n第8章 设计并发代码 213\n8.1 在线程间划分工作的技术 214\n8.1.1 处理开始前在线程间划分数据 214\n8.1.2 递归地划分数据 215\n8.1.3 以任务类型划分工作 219\n8.2 影响并发代码性能的因素 222\n8.2.1 有多少个处理器 222\n8.2.2 数据竞争和乒乓缓存 223\n8.2.3 假共享 225\n8.2.4 数据应该多紧密 225\n8.2.5 过度订阅和过多的任务切换 226\n8.3 为多线程性能设计数据结构 226\n8.3.1 为复杂操作划分数组元素 227\n8.3.2 其他数据结构中的数据访问方式 228\n8.4 为并发设计时的额外考虑 230\n8.4.1 并行算法中的异常安全 230\n8.4.2 可扩展性和阿姆达尔定律 237\n8.4.3 用多线程隐藏延迟 238\n8.4.4 用并发提高响应性 239\n8.5 在实践中设计并发代码 241\n8.5.1 std::for_each的并行实现 241\n8.5.2 std::find的并行实现 243\n8.5.3 std::partial_sum的并行实现 248\n8.6 总结 256\n第9章 高级线程管理 258\n9.1 线程池 259\n9.1.1 最简单的线程池 259\n9.1.2 等待提交给线程池的任务 261\n9.1.3 等待其他任务的任务 265\n9.1.4 避免工作队列上的竞争 267\n9.1.5 工作窃取 269\n9.2 中断线程 273\n9.2.1 启动和中断另一个线程 274\n9.2.2 检测一个线程是否被中断 275\n9.2.3 中断等待条件变量 276\n9.2.4 中断在std::condition_variable_ any上的等待 279\n9.2.5 中断其他阻塞调用 281\n9.2.6 处理中断 281\n9.2.7 在应用退出时中断后台任务 282\n9.3 总结 284\n第10章 多线程应用的测试与调试 285\n10.1 并发相关错误的类型 285\n10.1.1 不必要的阻塞 286\n10.1.2 竞争条件 286\n10.2 定位并发相关的错误的技巧 288\n10.2.1 审阅代码以定位潜在的错误 288\n10.2.2 通过测试定位并发相关的错误 290\n10.2.3 可测试性设计 291\n10.2.4 多线程测试技术 292\n10.2.5 构建多线程的测试代码 295\n10.2.6 测试多线程代码的性能 297\n10.3 总结 298\n附录A 附录A C++11部分\n语言特性简明\n参考 299\n附录B 并发类库",
        "pages": "360",
        "images": {
          "small": "https://img1.doubanio.com/spic/s28077549.jpg",
          "large": "https://img1.doubanio.com/lpic/s28077549.jpg",
          "medium": "https://img1.doubanio.com/mpic/s28077549.jpg"
        },
        "alt": "https://book.douban.com/subject/26386925/",
        "id": "26386925",
        "publisher": "人民邮电出版社",
        "isbn10": "711538732X",
        "isbn13": "9787115387325",
        "title": "C++并发编程实战",
        "url": "https://api.douban.com/v2/book/26386925",
        "alt_title": "C++ Concurrency in Action",
        "author_intro": "",
        "summary": "《C++并发编程实战》是一本基于C++11新标准的并发和多线程编程深度指南。内容包括从std::thread、std::mutex、std::future和std::async等基础类的使用，到内存模型和原子操作、基于锁和无锁数据结构的构建，再扩展到并行算法、线程管理，最后还介绍了多线程代码的测试工作。本书的附录部分还对C++11新语言特性中与多线程相关的项目进行了简要的介绍，并提供了C++11线程库的完整参考。\n《C++并发编程实战》适合于需要深入了解C++多线程开发的读者，以及使用C++进行各类软件开发的开发人员、测试人员。对于使用第三方线程库的读者，也可以从本书后面的章节中了解到相关的指引和技巧。同时，本书还可以作为C++11线程库的参考工具书。",
        "price": "69.00",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "fc9acd2d659a2a9317c042cd3a0f8f59f54d88f5619494f3df04025f59850618",
        "file": "C++并发编程实战.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 340,
          "average": "8.8",
          "min": 0
        },
        "subtitle": "使用muduo C++网络库",
        "author": [
          "陈硕"
        ],
        "pubdate": "2013-1-15",
        "tags": [
          {
            "count": 505,
            "name": "网络编程",
            "title": "网络编程"
          },
          {
            "count": 443,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 439,
            "name": "Linux",
            "title": "Linux"
          },
          {
            "count": 372,
            "name": "多线程",
            "title": "多线程"
          },
          {
            "count": 113,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 108,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 64,
            "name": "Networks",
            "title": "Networks"
          },
          {
            "count": 60,
            "name": "Programming",
            "title": "Programming"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/mpic/s24522799.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "第1 部分C++ 多线程系统编程1\n第1章 线程安全的对象生命期管理3\n1.1 当析构函数遇到多线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . 3\n1.1.1 线程安全的定义. . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\n1.1.2 MutexLock 与MutexLockGuard . . . . . . . . . . . . . . . . . . . . 4\n1.1.3 一个线程安全的Counter 示例. . . . . . . . . . . . . . . . . . . . 4\n1.2 对象的创建很简单. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5\n1.3 销毁太难. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.1 mutex 不是办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 7\n1.3.2 作为数据成员的mutex 不能保护析构. . . . . . . . . . . . . . . 8\n1.4 线程安全的Observer 有多难. . . . . . . . . . . . . . . . . . . . . . . . . 8\n1.5 原始指针有何不妥. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\n1.6 神器shared_ptr/weak_ptr . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n1.7 插曲：系统地避免各种指针错误. . . . . . . . . . . . . . . . . . . . . . . 14\n1.8 应用到Observer 上. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\n1.9 再论shared_ptr 的线程安全. . . . . . . . . . . . . . . . . . . . . . . . . 17\n1.10 shared_ptr 技术与陷阱. . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\n1.11 对象池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21\n1.11.1 enable_shared_from_this . . . . . . . . . . . . . . . . . . . . . . 23\n1.11.2 弱回调. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24\n1.12 替代方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.13 心得与小结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26\n1.14 Observer 之谬. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\n第2章 线程同步精要31\n2.1 互斥器（mutex） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32\n2.1.1 只使用非递归的mutex . . . . . . . . . . . . . . . . . . . . . . . . 33\n2.1.2 死锁. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35\n2.2 条件变量（condition variable） . . . . . . . . . . . . . . . . . . . . . . . 40\n2.3 不要用读写锁和信号量. . . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n2.4 封装MutexLock、MutexLockGuard、Condition . . . . . . . . . . . . . . 44\n2.5 线程安全的Singleton 实现. . . . . . . . . . . . . . . . . . . . . . . . . . 48\n2.6 sleep(3) 不是同步原语. . . . . . . . . . . . . . . . . . . . . . . . . . . . 50\n2.7 归纳与总结. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n2.8 借shared_ptr 实现copy-on-write . . . . . . . . . . . . . . . . . . . . . . 52\n第3章 多线程服务器的适用场合与常用编程模型59\n3.1 进程与线程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59\n3.2 单线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 61\n3.3 多线程服务器的常用编程模型. . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.1 one loop per thread . . . . . . . . . . . . . . . . . . . . . . . . . . 62\n3.3.2 线程池. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\n3.3.3 推荐模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 64\n3.4 进程间通信只用TCP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 65\n3.5 多线程服务器的适用场合. . . . . . . . . . . . . . . . . . . . . . . . . . . 67\n3.5.1 必须用单线程的场合. . . . . . . . . . . . . . . . . . . . . . . . . 69\n3.5.2 单线程程序的优缺点. . . . . . . . . . . . . . . . . . . . . . . . . 70\n3.5.3 适用多线程程序的场景. . . . . . . . . . . . . . . . . . . . . . . . 71\n3.6 “多线程服务器的适用场合”例释与答疑. . . . . . . . . . . . . . . . . . 74\n第4章 C++ 多线程系统编程精要83\n4.1 基本线程原语的选用. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\n4.2 C/C++ 系统库的线程安全性. . . . . . . . . . . . . . . . . . . . . . . . . 85\n4.3 Linux 上的线程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\n4.4 线程的创建与销毁的守则. . . . . . . . . . . . . . . . . . . . . . . . . . . 91\n4.4.1 pthread_cancel 与C++ . . . . . . . . . . . . . . . . . . . . . . . 94\n4.4.2 exit(3) 在C++ 中不是线程安全的. . . . . . . . . . . . . . . . . 94\n4.5 善用__thread 关键字. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\n4.6 多线程与IO . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\n4.7 用RAII 包装文件描述符. . . . . . . . . . . . . . . . . . . . . . . . . . . 99\n4.8 RAII 与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 101\n4.9 多线程与fork() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n4.10 多线程与signal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\n4.11 Linux 新增系统调用的启示. . . . . . . . . . . . . . . . . . . . . . . . . . 105\n第5章 高效的多线程日志107\n5.1 功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\n5.2 性能需求. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 112\n5.3 多线程异步日志. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 114\n5.4 其他方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\n第2部分 muduo 网络库123\n第6章 muduo 网络库简介125\n6.1 由来. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 125\n6.2 安装. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\n6.3 目录结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\n6.3.1 代码结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n6.3.2 例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\n6.3.3 线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135\n6.4 使用教程. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.1 TCP 网络编程本质论. . . . . . . . . . . . . . . . . . . . . . . . . 136\n6.4.2 echo 服务的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n6.4.3 七步实现finger 服务. . . . . . . . . . . . . . . . . . . . . . . . . 140\n6.5 性能评测. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\n6.5.1 muduo 与Boost.Asio、libevent2 的吞吐量对比. . . . . . . . . . 145\n6.5.2 击鼓传花：对比muduo 与libevent2 的事件处理效率. . . . . . 148\n6.5.3 muduo 与Nginx 的吞吐量对比. . . . . . . . . . . . . . . . . . . 153\n6.5.4 muduo 与ZeroMQ 的延迟对比. . . . . . . . . . . . . . . . . . . 156\n6.6 详解muduo 多线程模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.1 数独求解服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\n6.6.2 常见的并发网络服务程序设计方案. . . . . . . . . . . . . . . . . 160\n第7章 muduo 编程示例177\n7.1 五个简单TCP 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 178\n7.2 文件传输. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 185\n7.3 Boost.Asio 的聊天服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.1 TCP 分包. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 194\n7.3.2 消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 195\n7.3.3 编解码器LengthHeaderCodec . . . . . . . . . . . . . . . . . . . . 197\n7.3.4 服务端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\n7.3.5 客户端的实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\n7.4 muduo Buffer 类的设计与使用. . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.1 muduo 的IO 模型. . . . . . . . . . . . . . . . . . . . . . . . . . 204\n7.4.2 为什么non-blocking 网络编程中应用层buffer 是必需的. . . . 205\n7.4.3 Buffer 的功能需求. . . . . . . . . . . . . . . . . . . . . . . . . . 207\n7.4.4 Buffer 的数据结构. . . . . . . . . . . . . . . . . . . . . . . . . . 209\n7.4.5 Buffer 的操作. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\n7.4.6 其他设计方案. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\n7.4.7 性能是不是问题. . . . . . . . . . . . . . . . . . . . . . . . . . . . 218\n7.5 一种自动反射消息类型的Google Protobuf 网络传输方案. . . . . . . . 220\n7.5.1 网络编程中使用Protobuf 的两个先决条件. . . . . . . . . . . . . 220\n7.5.2 根据type name 反射自动创建Message 对象. . . . . . . . . . . . 221\n7.5.3 Protobuf 传输格式. . . . . . . . . . . . . . . . . . . . . . . . . . 226\n7.6 在muduo 中实现Protobuf 编解码器与消息分发器. . . . . . . . . . . . 228\n7.6.1 什么是编解码器（codec） . . . . . . . . . . . . . . . . . . . . . . 229\n7.6.2 实现ProtobufCodec . . . . . . . . . . . . . . . . . . . . . . . . . 232\n7.6.3 消息分发器（dispatcher）有什么用. . . . . . . . . . . . . . . . 232\n7.6.4 ProtobufCodec 与ProtobufDispatcher 的综合运用. . . . . . . 233\n7.6.5 ProtobufDispatcher 的两种实现. . . . . . . . . . . . . . . . . . 234\n7.6.6 ProtobufCodec 和ProtobufDispatcher 有何意义. . . . . . . . . 236\n7.7 限制服务器的最大并发连接数. . . . . . . . . . . . . . . . . . . . . . . . 237\n7.7.1 为什么要限制并发连接数. . . . . . . . . . . . . . . . . . . . . . 237\n7.7.2 在muduo 中限制并发连接数. . . . . . . . . . . . . . . . . . . . 238\n7.8 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.1 程序中的时间. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 240\n7.8.2 Linux 时间函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . 241\n7.8.3 muduo 的定时器接口. . . . . . . . . . . . . . . . . . . . . . . . . 242\n7.8.4 Boost.Asio Timer 示例. . . . . . . . . . . . . . . . . . . . . . . . 243\n7.8.5 Java Netty 示例. . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\n7.9 测量两台机器的网络延迟和时间差. . . . . . . . . . . . . . . . . . . . . 248\n7.10 用timing wheel 踢掉空闲连接. . . . . . . . . . . . . . . . . . . . . . . . 250\n7.10.1 timing wheel 原理. . . . . . . . . . . . . . . . . . . . . . . . . . 251\n7.10.2 代码实现与改进. . . . . . . . . . . . . . . . . . . . . . . . . . . . 254\n7.11 简单的消息广播服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 257\n7.12 “串并转换”连接服务器及其自动化测试. . . . . . . . . . . . . . . . . . 260\n7.13 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.1 TCP 中继器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\n7.13.2 socks4a 代理服务器. . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.13.3 N : 1 与1 : N 连接转发. . . . . . . . . . . . . . . . . . . . . . . . 267\n7.14 短址服务. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267\n7.15 与其他库集成. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 268\n7.15.1 UDNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 270\n7.15.2 c-ares DNS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 272\n7.15.3 curl . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273\n7.15.4 更多. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275\n第8章 muduo 网络库设计与实现277\n8.0 什么都不做的EventLoop . . . . . . . . . . . . . . . . . . . . . . . . . . . 277\n8.1 Reactor 的关键结构. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.1 Channel class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 280\n8.1.2 Poller class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 283\n8.1.3 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 287\n8.2 TimerQueue 定时器. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.1 TimerQueue class . . . . . . . . . . . . . . . . . . . . . . . . . . . 290\n8.2.2 EventLoop 的改动. . . . . . . . . . . . . . . . . . . . . . . . . . . 292\n8.3 EventLoop::runInLoop() 函数. . . . . . . . . . . . . . . . . . . . . . . . 293\n8.3.1 提高TimerQueue 的线程安全性. . . . . . . . . . . . . . . . . . . 296\n8.3.2 EventLoopThread class . . . . . . . . . . . . . . . . . . . . . . . . 297\n8.4 实现TCP 网络库. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 299\n8.5 TcpServer 接受新连接. . . . . . . . . . . . . . . . . . . . . . . . . . . . 303\n8.5.1 TcpServer class . . . . . . . . . . . . . . . . . . . . . . . . . . . . 304\n8.5.2 TcpConnection class . . . . . . . . . . . . . . . . . . . . . . . . . 305\n8.6 TcpConnection 断开连接. . . . . . . . . . . . . . . . . . . . . . . . . . . 308\n8.7 Buffer 读取数据. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 313\n8.7.1 TcpConnection 使用Buffer 作为输入缓冲. . . . . . . . . . . . . 314\n8.7.2 Buffer::readFd() . . . . . . . . . . . . . . . . . . . . . . . . . . 315\n8.8 TcpConnection 发送数据. . . . . . . . . . . . . . . . . . . . . . . . . . . 316\n8.9 完善TcpConnection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 320\n8.9.1 SIGPIPE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321\n8.9.2 TCP No Delay 和TCP keepalive . . . . . . . . . . . . . . . . . . 321\n8.9.3 WriteCompleteCallback 和HighWaterMarkCallback . . . . . . . 322\n8.10 多线程TcpServer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 324\n8.11 Connector . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 327\n8.12 TcpClient . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 332\n8.13 epoll . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n8.14 测试程序一览. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 336\n第3部分 工程实践经验谈337\n第9章 分布式系统工程实践339\n9.1 我们在技术浪潮中的位置. . . . . . . . . . . . . . . . . . . . . . . . . . . 341\n9.1.1 分布式系统的本质困难. . . . . . . . . . . . . . . . . . . . . . . . 343\n9.1.2 分布式系统是个险恶的问题. . . . . . . . . . . . . . . . . . . . . 344\n9.2 分布式系统的可靠性浅说. . . . . . . . . . . . . . . . . . . . . . . . . . . 349\n9.2.1 分布式系统的软件不要求7  24 可靠. . . . . . . . . . . . . . . . 352\n9.2.2 “能随时重启进程”作为程序设计目标. . . . . . . . . . . . . . . 354\n9.3 分布式系统中心跳协议的设计. . . . . . . . . . . . . . . . . . . . . . . . 356\n9.4 分布式系统中的进程标识. . . . . . . . . . . . . . . . . . . . . . . . . . . 360\n9.4.1 错误做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361\n9.4.2 正确做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 362\n9.4.3 TCP 协议的启示. . . . . . . . . . . . . . . . . . . . . . . . . . . . 363\n9.5 构建易于维护的分布式程序. . . . . . . . . . . . . . . . . . . . . . . . . 364\n9.6 为系统演化做准备. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367\n9.6.1 可扩展的消息格式. . . . . . . . . . . . . . . . . . . . . . . . . . 368\n9.6.2 反面教材：ICE 的消息打包格式. . . . . . . . . . . . . . . . . . . 369\n9.7 分布式程序的自动化回归测试. . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.1 单元测试的能与不能. . . . . . . . . . . . . . . . . . . . . . . . . 370\n9.7.2 分布式系统测试的要点. . . . . . . . . . . . . . . . . . . . . . . . 373\n9.7.3 分布式系统的抽象观点. . . . . . . . . . . . . . . . . . . . . . . . 374\n9.7.4 一种自动化的回归测试方案. . . . . . . . . . . . . . . . . . . . . 375\n9.7.5 其他用处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 379\n9.8 分布式系统部署、监控与进程管理的几重境界. . . . . . . . . . . . . . . 380\n9.8.1 境界1：全手工操作. . . . . . . . . . . . . . . . . . . . . . . . . 382\n9.8.2 境界2：使用零散的自动化脚本和第三方组件. . . . . . . . . . . 383\n9.8.3 境界3：自制机群管理系统，集中化配置. . . . . . . . . . . . . 386\n9.8.4 境界4：机群管理与naming service 结合. . . . . . . . . . . . . 389\n第10章 C++ 编译链接模型精要391\n10.1 C 语言的编译模型及其成因. . . . . . . . . . . . . . . . . . . . . . . . . 394\n10.1.1 为什么C 语言需要预处理. . . . . . . . . . . . . . . . . . . . . . 395\n10.1.2 C 语言的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . 398\n10.2 C++ 的编译模型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.1 单遍编译. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 399\n10.2.2 前向声明. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 402\n10.3 C++ 链接（linking） . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 404\n10.3.1 函数重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 406\n10.3.2 inline 函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 407\n10.3.3 模板. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409\n10.3.4 虚函数. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 414\n10.4 工程项目中头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . 415\n10.4.1 头文件的害处. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 416\n10.4.2 头文件的使用规则. . . . . . . . . . . . . . . . . . . . . . . . . . 417\n10.5 工程项目中库文件的组织原则. . . . . . . . . . . . . . . . . . . . . . . . 418\n10.5.1 动态库是有害的. . . . . . . . . . . . . . . . . . . . . . . . . . . . 423\n10.5.2 静态库也好不到哪儿去. . . . . . . . . . . . . . . . . . . . . . . . 424\n10.5.3 源码编译是王道. . . . . . . . . . . . . . . . . . . . . . . . . . . . 428\n第11章 反思C++ 面向对象与虚函数429\n11.1 朴实的C++ 设计. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429\n11.2 程序库的二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . . . . 431\n11.2.1 什么是二进制兼容性. . . . . . . . . . . . . . . . . . . . . . . . . 432\n11.2.2 有哪些情况会破坏库的ABI . . . . . . . . . . . . . . . . . . . . . 433\n11.2.3 哪些做法多半是安全的. . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.4 反面教材：COM . . . . . . . . . . . . . . . . . . . . . . . . . . . 435\n11.2.5 解决办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3 避免使用虚函数作为库的接口. . . . . . . . . . . . . . . . . . . . . . . . 436\n11.3.1 C++ 程序库的作者的生存环境. . . . . . . . . . . . . . . . . . . . 437\n11.3.2 虚函数作为库的接口的两大用途. . . . . . . . . . . . . . . . . . 438\n11.3.3 虚函数作为接口的弊端. . . . . . . . . . . . . . . . . . . . . . . . 439\n11.3.4 假如Linux 系统调用以COM 接口方式实现. . . . . . . . . . . . 442\n11.3.5 Java 是如何应对的. . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.4 动态库接口的推荐做法. . . . . . . . . . . . . . . . . . . . . . . . . . . . 443\n11.5 以boost::function 和boost::bind 取代虚函数. . . . . . . . . . . . . 447\n11.5.1 基本用途. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 450\n11.5.2 对程序库的影响. . . . . . . . . . . . . . . . . . . . . . . . . . . . 451\n11.5.3 对面向对象程序设计的影响. . . . . . . . . . . . . . . . . . . . . 453\n11.6 iostream 的用途与局限. . . . . . . . . . . . . . . . . . . . . . . . . . . . 457\n11.6.1 stdio 格式化输入输出的缺点. . . . . . . . . . . . . . . . . . . . . 457\n11.6.2 iostream 的设计初衷. . . . . . . . . . . . . . . . . . . . . . . . . 461\n11.6.3 iostream 与标准库其他组件的交互. . . . . . . . . . . . . . . . . 463\n11.6.4 iostream 在使用方面的缺点. . . . . . . . . . . . . . . . . . . . . 464\n11.6.5 iostream 在设计方面的缺点. . . . . . . . . . . . . . . . . . . . . 468\n11.6.6 一个300 行的memory buffer output stream . . . . . . . . . . . 476\n11.6.7 现实的C++ 程序如何做文件IO . . . . . . . . . . . . . . . . . . . 480\n11.7 值语义与数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.1 什么是值语义. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 482\n11.7.2 值语义与生命期. . . . . . . . . . . . . . . . . . . . . . . . . . . . 483\n11.7.3 值语义与标准库. . . . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.4 值语义与C++ 语言. . . . . . . . . . . . . . . . . . . . . . . . . . 488\n11.7.5 什么是数据抽象. . . . . . . . . . . . . . . . . . . . . . . . . . . . 490\n11.7.6 数据抽象所需的语言设施. . . . . . . . . . . . . . . . . . . . . . 493\n11.7.7 数据抽象的例子. . . . . . . . . . . . . . . . . . . . . . . . . . . . 495\n第12章 C++ 经验谈501\n12.1 用异或来交换变量是错误的. . . . . . . . . . . . . . . . . . . . . . . . . 501\n12.1.1 编译器会分别生成什么代码. . . . . . . . . . . . . . . . . . . . . 503\n12.1.2 为什么短的代码不一定快. . . . . . . . . . . . . . . . . . . . . . 505\n12.2 不要重载全局::operator new() . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.1 内存管理的基本要求. . . . . . . . . . . . . . . . . . . . . . . . . 507\n12.2.2 重载::operator new() 的理由. . . . . . . . . . . . . . . . . . . 508\n12.2.3 ::operator new() 的两种重载方式. . . . . . . . . . . . . . . . . 508\n12.2.4 现实的开发环境. . . . . . . . . . . . . . . . . . . . . . . . . . . . 509\n12.2.5 重载::operator new() 的困境. . . . . . . . . . . . . . . . . . . 510\n12.2.6 解决办法：替换malloc() . . . . . . . . . . . . . . . . . . . . . . 512\n12.2.7 为单独的class 重载::operator new() 有问题吗. . . . . . . . . 513\n12.2.8 有必要自行定制内存分配器吗. . . . . . . . . . . . . . . . . . . . 513\n12.3 带符号整数的除法与余数. . . . . . . . . . . . . . . . . . . . . . . . . . . 514\n12.3.1 语言标准怎么说. . . . . . . . . . . . . . . . . . . . . . . . . . . . 515\n12.3.2 C/C++ 编译器的表现. . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.3 其他语言的规定. . . . . . . . . . . . . . . . . . . . . . . . . . . . 516\n12.3.4 脚本语言解释器代码. . . . . . . . . . . . . . . . . . . . . . . . . 517\n12.3.5 硬件实现. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521\n12.4 在单元测试中mock 系统调用. . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.1 系统函数的依赖注入. . . . . . . . . . . . . . . . . . . . . . . . . 522\n12.4.2 链接期垫片（link seam） . . . . . . . . . . . . . . . . . . . . . . 524\n12.5 慎用匿名namespace . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 526\n12.5.1 C 语言的static 关键字的两种用法. . . . . . . . . . . . . . . . . 526\n12.5.2 C++ 语言的static 关键字的四种用法. . . . . . . . . . . . . . . . 526\n12.5.3 匿名namespace 的不利之处. . . . . . . . . . . . . . . . . . . . . 527\n12.5.4 替代办法. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 529\n12.6 采用有利于版本管理的代码格式. . . . . . . . . . . . . . . . . . . . . . . 529\n12.6.1 对diff 友好的代码格式. . . . . . . . . . . . . . . . . . . . . . . . 530\n12.6.2 对grep 友好的代码风格. . . . . . . . . . . . . . . . . . . . . . . 537\n12.6.3 一切为了效率. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 538\n12.7 再探std::string . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539\n12.7.1 直接拷贝（eager copy） . . . . . . . . . . . . . . . . . . . . . . . 540\n12.7.2 写时复制（copy-on-write） . . . . . . . . . . . . . . . . . . . . . 542\n12.7.3 短字符串优化（SSO） . . . . . . . . . . . . . . . . . . . . . . . . 543\n12.8 用STL algorithm 轻松解决几道算法面试题. . . . . . . . . . . . . . . . 546\n12.8.1 用next_permutation() 生成排列与组合. . . . . . . . . . . . . . 546\n12.8.2 用unique() 去除连续重复空白. . . . . . . . . . . . . . . . . . . 548\n12.8.3 用{make,push,pop}_heap() 实现多路归并. . . . . . . . . . . . 549\n12.8.4 用partition() 实现“重排数组，让奇数位于偶数前面” . . . . 553\n12.8.5 用lower_bound() 查找IP 地址所属的城市. . . . . . . . . . . . . 554\n第4 部分附录559\n附录A 谈一谈网络编程学习经验561\n附录B 从《C++ Primer（第4 版）》入手学习C++ 579\n附录C 关于Boost 的看法591\n附录D 关于TCP 并发连接的几个思考题与试验593\n参考文献599",
        "pages": "610",
        "images": {
          "small": "https://img1.doubanio.com/spic/s24522799.jpg",
          "large": "https://img1.doubanio.com/lpic/s24522799.jpg",
          "medium": "https://img1.doubanio.com/mpic/s24522799.jpg"
        },
        "alt": "https://book.douban.com/subject/20471211/",
        "id": "20471211",
        "publisher": "电子工业出版社",
        "isbn10": "7121192829",
        "isbn13": "9787121192821",
        "title": "Linux多线程服务端编程",
        "url": "https://api.douban.com/v2/book/20471211",
        "alt_title": "",
        "author_intro": "陈硕，北京师范大学硕士，擅长C++ 多线程网络编程和实时分布式系统架构。曾在摩根士丹利IT 部门工作5 年，从事实时外汇交易系统开发。现在在美国加州硅谷某互联网大公司工作，从事大规模分布式系统的可靠性工程。编写了开源C++ 网络库muduo，参与翻译了《代码大全（ 第2 版）》和《C++ 编程规范（繁体版）》，整理了《C++ Primer （第4 版）（评注版）》，并曾多次在各地技术大会演讲。",
        "summary": "本书主要讲述采用现代C++ 在x86-64 Linux 上编写多线程TCP 网络服务程序的主流常规技术，重点讲解一种适应性较强的多线程服务器的编程模型，即one loop per thread。这是在Linux 下以native 语言编写用户态高性能网络程序最成熟的模式，掌握之后可顺利地开发各类常见的服务端网络应用程序。本书以muduo 网络库为例，讲解这种编程模型的使用方法及注意事项。\n本书的宗旨是贵精不贵多。掌握两种基本的同步原语就可以满足各种多线程同步的功能需求，还能写出更易用的同步设施。掌握一种进程间通信方式和一种多线程网络编程模型就足以应对日常开发任务，编写运行于公司内网环境的分布式服务统。",
        "price": "89.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "a2318169aef295c05fa9b4f627c07ecb6f4724f16e28edd3793ebff5dac202a9",
        "file": "Linux多线程服务端编程.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 10,
          "average": "7.4",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "薛正华",
          "沈庚",
          "韦远科"
        ],
        "pubdate": "2014-6-1",
        "tags": [
          {
            "count": 4,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 2,
            "name": "软件工程",
            "title": "软件工程"
          },
          {
            "count": 2,
            "name": "程序设计",
            "title": "程序设计"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s27328243.jpg",
        "binding": "",
        "translator": [
          "薛正华",
          "沈庚",
          "韦远科"
        ],
        "catalog": "第1章 C++ 基础 1\n1.1 C++简介 2\nC++语言的起源 2\nC++与面向对象编程 3\nC++的特点 3\nC++术语 3\nC++程序示例 3\n1.2 变量、表达式及赋值语句 5\n标识符 5\n变量 6\n赋值语句 8\nstring类简介 9\n陷阱：未初始化变量 9\n提示：采用有意义的变量名 10\n更多赋值语句 11\n赋值兼容性 11\n字面值 12\n转义序列 14\n命名常量 14\n算数运算符和表达式 16\n整数和浮点数除法 17\n陷阱：全整数除法 17\n类型转换 18\n自增和自减运算符 20\n陷阱：求值顺序 21\n1.3 控制台输入/输出 22\n使用cout输出 22\n换行符 23\n提示：以\\n或endl结束程序 24\n格式化浮点数 24\n用cerr输出 25\n用cin输入 25\n提示：输入/输出中的换行 28\n1.4 编程风格 28\n注释 28\n1.5 库与命名空间 29\n库与include命令 29\n命名空间 29\n陷阱：库名的问题 30\n第2章　流程控制 37\n2.1 布尔表达式 38\n创建布尔表达式 38\n陷阱：不等式连写 39\n布尔表达式求值 40\n优先级规则 41\n陷阱：整数值用作布尔值 44\n2.2 分支机制 45\nif-else语句 45\n复合语句 47\n陷阱：用=代替== 47\n省略else 49\n嵌套语句 49\n多分支if-else语句 49\nswitch语句 50\n陷阱：遗漏switch语句中的break 52\n提示：在菜单中使用switch语句 52\n枚举类型 53\n条件运算符 53\n2.3 循环 54\nwhile和do-while循环 54\n再谈自增和自减运算符 57\n逗号运算符 58\nfor语句 59\n提示：重复N次的循环 61\n陷阱：for语句中额外的分号 62\n陷阱：无限循环 62\nbreak与continue语句 65\n嵌套循环 67\n2.4 文件输入简介 67\n通过ifstream读取文本文件内容 68\n第3章 函数基础 81\n3.1 预定义函数 82\n带有返回值的预定义函数 82\n预定义的void函数 86\n随机数生成器 88\n3.2 自定义函数 91\n定义带有返回值的函数 91\n函数声明的另一种形式 93\n陷阱：参数顺序的错误 93\n调用函数的函数 94\n示例：一个四舍五入的函数 94\n返回布尔值的函数 96\n定义void函数 96\nvoid函数中的return语句 98\n前提条件和运行结果 98\nmain函数 100\n递归函数 100\n3.3 作用域规则 101\n局部变量 101\n过程抽象 103\n全局常量和全局变量 104\n语句块 106\n嵌套作用域 107\n提示：在分支和循环语句中使用函数调用 107\nfor循环体中的变量声明 107\n第4章 函数与重载 117\n4.1 参数 118\n传值参数 118\n初识引用参数 120\n引用传递调用机制详解 122\n常量引用参数 124\n示例：函数swapValues 124\n提示：一种操作，而不是代码 125\n混合参数列表 126\n提示：使用何种参数 126\n陷阱：无意的局部变量 128\n提示：选择形参的名字 129\n示例：买比萨 129\n4.2 重载与默认实参 132\n重载简介 132\n陷阱：自动类型转换与重载 134\n重载解析的规则 135\n示例：改写“买比萨程序” 136\n默认参数 138\n4.3 函数的测试和调试 140\nassert宏 140\n占位程序和驱动程序 141\n第5章 数组 151\n5.1 数组简介 152\n数组的声明和引用 152\n提示：对数组使用for循环 154\n陷阱：数组的索引始终是从0开始的 154\n提示：使用已定义的常量作为数组的大小 154\n内存中的数组 155\n陷阱：数组越界 157\n数组的初始化 157\n5.2 函数中的数组 159\n索引变量作为函数实参 159\n整个数组作为函数实参 160\nconst修饰符 163\n陷阱：const参数的不一致使用 164\n返回数组的函数 164\n示例：生产图表 165\n5.3 用数组编程 169\n部分填充的数组 169\n提示：不要吝啬形参的使用 169\n示例：查询数组 172\n示例：给数组排序 174\n5.4 多维数组 178\n多维数组基础 178\n多维数组参数 179\n示例：使用二维数组的记分程序 179\n第6章 结构体和类 195\n6.1 结构体 196\n结构体类型 198\n陷阱：漏掉结构体定义末尾的分号 200\n结构体作为函数参数 201\n提示：使用多重结构体 201\n结构体的初始化 204\n6.2 类 206\n定义类和成员函数 206\n封装 211\n公有成员和私有成员 211\n取值和赋值函数 214\n提示：接口和实现的分离 216\n提示：封装的测试 216\n结构体与类 217\n提示：对象思考 217\n第7章 构造函数及其他工具 225\n7.1 构造函数 226\n构造函数的定义 226\n陷阱：无参构造函数 230\n构造函数的显式调用 230\n提示：总是为类定义一个默认构造函数 231\n示例：BankAccount类 233\n类类型成员变量 238\n7.2 其他工具 241\nconst修饰符 241\n陷阱：const的不一致用法 243\n内联函数 246\n静态成员 248\n嵌套类和局部类定义 251\n7.3 向量——标准模板库预览 251\n向量基础 252\n陷阱：方括号的索引超过向量的大小 253\n提示：向量的赋值 254\n效率问题 255\n第8章 运算符重载、友元和引用 263\n8.1 基本运算符的重载 264\n重载基础 264\n提示：构造函数可以返回一个对象 269\n返回常量类型 270\n一元运算符的重载 272\n作为成员函数的运算符重载 272\n提示：类可以访问其所有对象 275\n重载函数调用符( ) 275\n陷阱：重载 &&、||及逗号运算符 275\n8.2 友元函数与自动类型转换 276\n构造函数的自动类型转换 276\n陷阱：成员运算符和自动类型转换 277\n友元函数 277\n友元类 280\n陷阱：不支持友元的编译器 281\n8.3 引用和其他运算符重载 282\n引用 282\n提示：返回类的成员变量 283\n重载“>>”和“<<” 284\n提示：应使用什么样的返回值类型 289\n赋值运算符 291\n重载自增和自减运算符 291\n重载数组运算符[ ] 294\n基于左值和右值的重载 296\n第9章 字符串 303\n9.1 字符串类型数组 304\nC字符串值和C字符串变量 304\n陷阱：对C字符串使用 “=” 和 “==” 308\n<cstring>中的其他函数 309\n示例： 命令行参数 311\nC字符串的输入/输出 313\n9.2 字符操作工具 315\n字符的输入/输出 315\n成员函数get和put 315\n示例：使用换行函数检查输入 318\n陷阱：输入时没有处理‘\\n’ 319\n成员函数putback、peek和ignore 320\n字符操作函数 322\n陷阱：函数toupper和tolower返回int型数值 324\n9.3 标准string类 325\n标准string类简介 325\nstring类的输入和输出 327\n提示：getline函数的其他版本 330\n陷阱：对cin同时使用>>和getline 331\n使用string类处理字符串 331\n示例： 回文检测 335\nstring类对象和C字符串的转换 338\n第10章 指针和动态数组 347\n10.1 指针 348\n指针变量 349\n内存管理基础 355\n陷阱：悬空指针 357\n动态变量和自动变量 358\n提示：定义指针类型 358\n陷阱：指针用作传值参数 360\n指针的应用 361\n10.2 动态数组 362\n数组变量和指针变量 362\n创建并使用动态数组 363\n示例：一个返回数组的函数 366\n指针运算 368\n多维动态数组 368\n10.3 类、指针和动态数组 371\n运算符-> 371\nthis指针 371\n重载赋值运算符 372\n示例：部分填充数组的类 378\n析构函数 380\n拷贝构造函数 381\n第11章 分散编译和命名空间 391\n11.1 分散编译 392\n封装回顾 392\n头文件和实现文件 393\n示例：DigitalTime类 399\n提示：可重用的组件 401\n使用#ifndef 401\n提示：定义其他库 403\n11.2 命名空间 404\n命名空间和using指令 404\n创建一个命名空间 406\nusing声明 409\n限定名称 410\n提示：为命名空间取名 412\n示例：一个定义在命名空间中的类 412\n无名称的命名空间 413\n陷阱：混淆全局命名空间和无名称命名空间 418\n提示：用无名称命名空间代替static修饰符 419\n提示：隐藏帮助函数 419\n嵌套命名空间 420\n提示：应该如何指明使用的命名空间 420\n第12章 流和文件I/O操作 429\n12.1 I/O流 430\n文件I/O 431\n陷阱：流变量的使用限制 434\n向文件追加输出内容 435\n提示： 打开文件的另一种方法 436\n提示：检查一个文件是否已被成功打开 439\n字符I/O 440\n文件结束检查 440\n12.2 I/O流工具 444\n使用文件名输入 444\n使用流函数进行格式化输出 444\n控制符 447\n保存设置的标记 448\n更多的输出流成员函数 449\n示例：整理文件格式 450\n示例：编辑文本文件 452\n12.3 流的继承层次：继承概述 455\n流之间的继承 455\n示例：另一版本的newLine函数 457\n使用类stringstream解析字符串 460\n12.4 随机文件存取 462\n第13章 递归 477\n13.1 递归void函数 478\n示例：竖直排列的数字 479\n跟踪一个递归调用 481\n深入理解递归 484\n陷阱：无限递归 485\n递归调用中的栈 487\n陷阱：栈溢出 488\n递归与迭代的比较 488\n13.2 有返回值的递归函数 489\n有返回值的递归函数的一般形式 489\n示例：另一个幂函数 490\n交叉递归 494\n13.3 按递归方式思考问题 496\n递归设计技巧 496\n二分查找 497\n编码 498\n检查递归是否正确 501\n效率 502\n第14章 继承 513\n14.1 继承基础 514\n派生类 514\n派生类的构造函数 522\n陷阱：使用基类的私有成员变量 524\n陷阱：私有成员函数是无法被有效继承的 526\nprotected限定符 526\n成员函数的重定义 529\n重定义与重载 530\n访问被重定义过的基类函数 531\n不可被继承的函数 532\n14.2 利用继承编程 533\n派生类中的赋值运算符和拷贝构造函数 533\n派生类的析构函数 534\n示例：可备份的部分填充的数组 534\n陷阱：赋值运算符两边是同一个对象 541\n示例：PFArrayDBak的另一种实现 542\n提示：一个类可以访问本类所有对象的私有成员 544\n提示：“是一个”和“有一个” 544\n保护继承和私有继承 545\n多继承 546\n第15章 多态与虚函数 555\n15.1 虚函数基础 556\n延迟绑定 556\nC++中的虚函数 557\n提示：virtual属性会被继承 563\n提示：什么时候应该使用虚函数 563\n陷阱：没有对虚成员函数进行定义 564\n抽象类与纯虚函数 564\n示例：抽象类 565\n15.2 指针和虚函数 567\n虚函数与扩展类型兼容性 567\n陷阱：切片问题 571\n提示：使析构函数成为虚函数 572\n向下类型转换和向上类型转换 573\nC++如何实现虚函数 574\n第16章 模板 585\n16.1 函数模板 586\n函数模板语法 587\n陷阱：编译器的复杂性 590\n提示：如何定义模板 592\n示例：一个通用的排序函数 592\n陷阱：使用模板时误用了不正确的数据类型 596\n16.2 类模板 597\n类模板语法 598\n示例：一个数组模板类 601\n模板中的vector和 basic_string 606\n16.3 模板和继承 606\n示例： 带备份的部分填充数组模板类 607\n第17章 链式数据结构 617\n17.1 节点和链表 619\n节点 619\n链表 623\n在链表头插入节点 625\n陷阱：丢失节点 627\n插入和删除链表内的节点 628\n陷阱：对动态数据结构使用赋值运算符 631\n搜索链表 631\n搜索函数伪代码 632\n双向链表 633\n为双向链表增加一个节点 635\n从双向链表中删除一个节点 635\n示例： 使用双向链表实现的通用排序模板函数 641\n17.2 链表的应用 644\n示例：栈模板类 644\n示例：队列模板类 650\n提示：命名空间的注解 652\n友元类以及类似的其他选择 653\n示例：包含节点链的哈希表 655\n字符串哈希函数 656\n哈希表的效率 660\n示例：集合（set）模板类 661\n集合的基本操作 662\n链表创建的集合的效率 667\n17.3 迭代器 668\n指针作为迭代器 668\n迭代器类 669\n示例：迭代器类 670\n17.4 树 676\n树的属性 676\n示例：树模板类 678\n第18章 异常处理 695\n18.1 异常处理基础 696\n异常处理的简单样例 697\n定义自己的异常类 704\n多个抛出和捕获 704\n陷阱：首先捕获比较明确的异常 707\n提示：异常类可以很简单 708\n在函数中抛出异常 708\n异常说明 710\n陷阱：派生类中的异常说明 712\n18.2 异常处理的编程技术 713\n抛出异常的时机 713\n陷阱：未被捕获的异常 714\n陷阱：嵌套try-catch块 715\n陷阱：过度使用异常 715\n异常类层次结构 715\n可用内存测试 716\n再次抛出异常 716\n第19章 标准模板库 721\n19.1 迭代器 723\n迭代器基础 723\n陷阱：编译器问题 726\n迭代器的种类 728\n常量迭代器和可变迭代器 731\n反向迭代器 732\n其他种类的迭代器 733\n19.2 容器 734\n连续容器 734\n陷阱：迭代器和删除元素 738\n提示：容器中的类型定义 739\n容器适配器栈和队列 739\n陷阱：底层容器 740\n关联式容器set和map 742\n效率 747\n19.3 泛型算法 748\n运行时间和大-O表示法 749\n容器访问运行时间 752\n不改变序列的算法 753\n改变序列的算法 757\n集合算法 758\n排序算法 7601",
        "pages": "788",
        "images": {
          "small": "https://img3.doubanio.com/spic/s27328243.jpg",
          "large": "https://img3.doubanio.com/lpic/s27328243.jpg",
          "medium": "https://img3.doubanio.com/mpic/s27328243.jpg"
        },
        "alt": "https://book.douban.com/subject/25929393/",
        "id": "25929393",
        "publisher": "电子工业出版社",
        "isbn10": "7121231980",
        "isbn13": "9787121231988",
        "title": "完美c++（第5版）（双色）",
        "url": "https://api.douban.com/v2/book/25929393",
        "alt_title": "",
        "author_intro": "",
        "summary": "《完美C++（第5版）》为读者提供了一个学习、理解和掌握 C++编程语言的全面视图，覆盖面广、实用性强。书中介绍了 C++的基本数据类型，如字符串、数组、指针、结构体、类等，同时也详细描述了面向对象编程语言的特性：封装、继承和多态，以及这些特性在 C++语言中的具体使用方式。本书的后面章节还重点介绍了模板、链式数据结构、标准模板库以及异常处理等C++语言的进阶编程知识。这些知识在从事具体编程工作时会经常使用到。\n《完美C++（第5版）》对C++的一些重点知识，辅以实例进行了重点讲解，特别是对一些易混淆、易犯错的知识点，专门以“陷阱”的组织方式进行深入分析和讨论，帮助读者更好地理解和掌握。《完美C++（第5版）》中各章均含有大量例子及完整的代码段和分析，帮助读者强化对关键概念的理解，以及对主题的掌握。各章还配有丰富的自测习题以及答案，帮助读者进一步提升对C++知识的理解以及实际动手编程能力。\n原书由知名学者所著，历经多个版本，根据C++技术的发展，内容不断完善、丰富，体系完整、实践性强。\n《完美C++（第5版）》可以作为高等院校学习编程基本知识以及C++编程语言课程的教材，也可以作为有C++编程经验者的参考书。",
        "price": "148.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "e65a431b7cb568cb055bcb1801aab851785265a12344161212795014a2a95cfe",
        "file": "完美C ++ (第5版).pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 257,
          "average": "8.4",
          "min": 0
        },
        "subtitle": "C++描述(第三版)",
        "author": [
          "[美]Mark Allen Weiss"
        ],
        "pubdate": "2007年",
        "tags": [
          {
            "count": 241,
            "name": "数据结构",
            "title": "数据结构"
          },
          {
            "count": 184,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 169,
            "name": "C++",
            "title": "C++"
          },
          {
            "count": 86,
            "name": "数据结构与算法",
            "title": "数据结构与算法"
          },
          {
            "count": 81,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 50,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 39,
            "name": "算法分析",
            "title": "算法分析"
          },
          {
            "count": 34,
            "name": "Algorithm",
            "title": "Algorithm"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/mpic/s2210957.jpg",
        "binding": "",
        "translator": [
          "张怀勇"
        ],
        "catalog": "",
        "pages": "435",
        "images": {
          "small": "https://img1.doubanio.com/spic/s2210957.jpg",
          "large": "https://img1.doubanio.com/lpic/s2210957.jpg",
          "medium": "https://img1.doubanio.com/mpic/s2210957.jpg"
        },
        "alt": "https://book.douban.com/subject/1971825/",
        "id": "1971825",
        "publisher": "人民邮电出版社",
        "isbn10": "7115139237",
        "isbn13": "9787115139238",
        "title": "数据结构与算法分析",
        "url": "https://api.douban.com/v2/book/1971825",
        "alt_title": "Data Structures and Algorithm Analysis in C++",
        "author_intro": "Mark Allen Weiss\n1987年在普林斯顿大学获得计算机科学博士学位,师从著名算法大师Robert Sedgewick,现任美国佛罗里达国际大学计算与信息科学学院教授.他曾经担任全美AP(Advanced Placement)考试计算机学科委员会的主席(2000-2004).他的主要研究方向是数据结构,算法,和教育学.",
        "summary": "《数据结构与算法分析:C++描述(第3版)》是数据结构和算法分析的经典教材，书中使用主流的程序设计语言C++作为具体的实现语言。书的内容包括表、栈、队列、树、散列表、优先队列、排序、不相交集算法、图论算法、算法分析、算法设计、摊还分析、查找树算法、k-d树和配对堆等。《数据结构与算法分析:C++描述(第3版)》适合作为计算机相关专业本科生的数据结构课程和研究生算法分析课程的教材。本科生的数据结构课程可以使用《数据结构与算法分析:C++描述(第3版)》第1章～第9章，多学时课程还可以讲解第10章；研究生算法分析课程可以使用第6章～第12章。",
        "series": {
          "id": "18507",
          "title": "图灵计算机科学丛书"
        },
        "price": "49.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "ee145b4c2a62b082868c4c2df8ae980dfda7779bbd9b86868f9ec6b0195fde3c",
        "file": "数据结构与算法分析–C++(第3版,扫描,书签).pdf"
      },
      {
        "title_sort": "高速上手 C++11/14",
        "timestamp": "2017-08-29T15:01:14.045509+00:00",
        "publisher": "GitBook",
        "description": "C++11 的出现及C++14 对 C++11的重要补充，让 C++ 这门古老的语言注入了新的活力。如果你还在使用传统 C++，打着 C++ 的名号写出 C 语言代码，请停下来。本教程将带领你快速上手 C++11/14 的重要特性。",
        "language": "zh",
        "creator": "Changkun",
        "title": "高速上手 C++11/14",
        "date": "2016-09-20T01:18:30.162862+00:00",
        "contributor": "calibre (3.7.0) [https://calibre-ebook.com]",
        "identifier": {
          "mobi-asin": "4f7426e0-4ecc-4342-9a81-0174ee00dfbb",
          "uuid": "fca6936a-eebf-410d-80b3-d13a15c2dfa9",
          "calibre": "fca6936a-eebf-410d-80b3-d13a15c2dfa9"
        },
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "b7304d334a8133ac7628d02a66aeaa71287ea9a01163dad3cc7d82f1864f09e7",
        "file": "高速上手C++11-14.epub"
      }
    ]
  },
  {
    "dir_name": "css",
    "name": "css",
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 154,
          "average": "9.5",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[希] Lea Verou"
        ],
        "pubdate": "2016-4",
        "tags": [
          {
            "count": 249,
            "name": "CSS",
            "title": "CSS"
          },
          {
            "count": 141,
            "name": "前端开发",
            "title": "前端开发"
          },
          {
            "count": 81,
            "name": "前端",
            "title": "前端"
          },
          {
            "count": 44,
            "name": "网页设计",
            "title": "网页设计"
          },
          {
            "count": 34,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 32,
            "name": "CSS秘笈",
            "title": "CSS秘笈"
          },
          {
            "count": 21,
            "name": "Web前端开发",
            "title": "Web前端开发"
          },
          {
            "count": 20,
            "name": "计算机",
            "title": "计算机"
          }
        ],
        "origin_title": "CSS Secrets: Better Solutions to Everyday Web Design Problems",
        "image": "https://img1.doubanio.com/mpic/s28659699.jpg",
        "binding": "平装",
        "translator": [
          "CSS魔法"
        ],
        "catalog": "译者序\n序\n前言\n第1章 引言\n第2章 背景与边框\n第3章 形状\n第4章 视觉效果\n第5章 字体排印\n第6章 用户体验\n第7章 结构与布局\n第8章 过渡与动画\n按规范分类",
        "pages": "260",
        "images": {
          "small": "https://img1.doubanio.com/spic/s28659699.jpg",
          "large": "https://img1.doubanio.com/lpic/s28659699.jpg",
          "medium": "https://img1.doubanio.com/mpic/s28659699.jpg"
        },
        "alt": "https://book.douban.com/subject/26745943/",
        "id": "26745943",
        "publisher": "人民邮电出版社",
        "isbn10": "711541694X",
        "isbn13": "9787115416940",
        "title": "Css揭秘",
        "url": "https://api.douban.com/v2/book/26745943",
        "alt_title": "CSS Secrets: Better Solutions to Everyday Web Design Problems",
        "author_intro": "Lea Verou\nW3C CSS工作组特邀专家，设计CSS语言的委员之一，此前曾在W3C担任开发者代言人。目前，她在麻省理工学院从事人机交互领域的研究。她还是一位博客作家，并经常在国际性的技术会议上担任讲师；她创建的多个开源项目广受开发者欢迎。\nCSS魔法\n原名张鹏，国内知名的CSS技术专家，百姓网前端架构师。拥有近十年的网站开发经验，在移动前端领域积累颇深，自称“披着工程师外衣的设计师”。他是CMUI、Action、GHX等开源项目的作者，曾为GitHub、Gulp、Stylus等网站和项目翻译过大量文档；其生动活泼、循序渐进的博客写作风格深受读者喜爱；在CSS Conf等技术会议上所作的演讲广受好评。",
        "summary": "本书是一本注重实践的教程，作者为我们揭示了 47 个鲜为人知的 CSS 技巧，主要内容包括背景与边框、形状、 视觉效果、字体排印、用户体验、结构与布局、过渡与动画等。本书将带领读者循序渐进地探寻更优雅的解决方案，攻克每天都会遇到的各种网页样式难题。\n本书的读者对象为前端工程师、网页开发人员。",
        "price": "99.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "55f672cdb9a62b5b49c767e9c2eae9588e0370a5f69240f321f51f1324f2d48c",
        "file": "CSS揭秘.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 544,
          "average": "8.5",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[美] Eric A.Meyer"
        ],
        "pubdate": "2007-10",
        "tags": [
          {
            "count": 494,
            "name": "css",
            "title": "css"
          },
          {
            "count": 198,
            "name": "CSS权威指南",
            "title": "CSS权威指南"
          },
          {
            "count": 175,
            "name": "CSS",
            "title": "CSS"
          },
          {
            "count": 161,
            "name": "网页设计",
            "title": "网页设计"
          },
          {
            "count": 125,
            "name": "Web标准",
            "title": "Web标准"
          },
          {
            "count": 117,
            "name": "Web",
            "title": "Web"
          },
          {
            "count": 95,
            "name": "前端开发",
            "title": "前端开发"
          },
          {
            "count": 94,
            "name": "计算机",
            "title": "计算机"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s2921314.jpg",
        "binding": "平装",
        "translator": [
          "侯妍",
          "尹志忠"
        ],
        "catalog": "前言\n第1章 CS S和文档\nweb的衰落\nCSS作救星\n元素\n结合CSS和xHTML\n小结\n第2章 选择器\n基本规则\n分组\n类选择器和ID选择器\n属性选择器\n使用文档结构\n伪类和伪元素\n小结\n第3章 结构和层叠\n特殊性\n继承\n层叠\n小结\n第4章 值和单位\n数字\n百分数\n颜色\n长度单位\nURL\ncss2单位\n小结\n第5章 字体\n字体系列\n字体加粗\n字体大小\n风格和变形\n拉伸和调整字体\nfont属性\n字体匹配\n小结\n第6章 文本属性\n缩进和水平对齐\n垂直对齐\n字间隔和字母间隔\n文本转换\n文本装饰\n文本阴影\n小结\n第7章 基本视觉格式化\n第8章 内边距、边框和外边距\n第9章 颜色和背景\n第10章 浮动和定位\n第11章 表布局\n第12章 列表与生成内容\n第13章 用户界面样式\n第14章 非屏幕媒体\n附录A 属性参考\n附录B 选择器、伪类和伪元素参考\n附录C 示例HTML 4样式表",
        "pages": "508",
        "images": {
          "small": "https://img3.doubanio.com/spic/s2921314.jpg",
          "large": "https://img3.doubanio.com/lpic/s2921314.jpg",
          "medium": "https://img3.doubanio.com/mpic/s2921314.jpg"
        },
        "alt": "https://book.douban.com/subject/2308234/",
        "id": "2308234",
        "publisher": "中国电力出版社",
        "isbn10": "7508355946",
        "isbn13": "9787508355948",
        "title": "Css权威指南（第三版）",
        "url": "https://api.douban.com/v2/book/2308234",
        "alt_title": "",
        "author_intro": "",
        "summary": "你是否既想获得丰富复杂的网页样式，同时又想节省时间和精力？本书为你展示了如何遵循CSS最新规范（CSS2和CSS2.1）将层叠样式表的方方面面应用于实践。\n通过本书提供的诸多示例，你将了解如何做到仅在一处建立样式表就能创建或修改整个网站的外观，以及如何得到HTML力不能及的更丰富的表现效果。\n资深CSS专家Eric A.Meyer。利用他独有的睿智和丰富的经验对属性、标记、标记属性和实现做了深入的研究，另外在浏览器支持和设计原则等实际问题上也有独到的见解。你所需要的就是HTML 4.0的知识即可以为网站布局和分页创建简明而且易于维护的脚本，同时兼具桌面系统的美观性和可控性。在本书中你将学到以下内容：\n·用多种方式对文本应用样式\n·用户界面、表布局、列表和生成内容\n·浮动和定位的优缺点\n·字体系列和后路\n·框模型的工作原理\n·IE7、Firefox和其他浏览器支持的新CSS3选择器\n最新版《CSS权威指南》一书经过全面更新，涵盖了Internet Explorer 7，详细介绍了各个CSS属性以及属性之间的相互作用，并指导你如何避免一些常见的错误。不论你是一位经验丰富的web创作人员，还是一无所知的新手，都可以把它作为内容翔实的CSS参考资料放在手边。Eric A.Meyer。在HTML、CSS和web标准领域是国际上公认的专家，他从1993年就开始从事web方面的工作。他也是complex spiral consulting公司的奠基人，其客户包括美国在线、苹果计算机公司、富国银行和Macromedia等著名公司。",
        "series": {
          "id": "697",
          "title": "博文视点O'reilly系列"
        },
        "price": "58.00",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "b0cac6516ce008845a78e27a024255a4021952c559c39e00b1c15a831ad74651",
        "file": "CSS权威指南第三版.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 1631,
          "average": "8.4",
          "min": 0
        },
        "subtitle": "Web视觉艺术设计的王者之书",
        "author": [
          "[美] Dave Shea",
          "Molly E. Holzschlag"
        ],
        "pubdate": "2007-6",
        "tags": [
          {
            "count": 1584,
            "name": "css",
            "title": "css"
          },
          {
            "count": 807,
            "name": "网页设计",
            "title": "网页设计"
          },
          {
            "count": 567,
            "name": "Web设计",
            "title": "Web设计"
          },
          {
            "count": 285,
            "name": "Web标准",
            "title": "Web标准"
          },
          {
            "count": 261,
            "name": "web",
            "title": "web"
          },
          {
            "count": 254,
            "name": "设计",
            "title": "设计"
          },
          {
            "count": 208,
            "name": "交互设计",
            "title": "交互设计"
          },
          {
            "count": 172,
            "name": "design",
            "title": "design"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s2406764.jpg",
        "binding": "平装",
        "translator": [
          "陈黎夫",
          "山崺颋"
        ],
        "catalog": "第1章 追本溯源\n第2章 设计\n2.1 Atlantis\n2.2 Zunflower\n2.3 Springtime\n2.4 Viridity\n2.5 Ballade\n2.6 Night Drive\n第3章 正文布局\n3.1 Backyard\n3.2 Entomology\n3.3 White Lily\n3.4 pret-a-proter\n3.5 CS（S）Monk\n3.6 Not So Minimal\n第4章 图像\n4.1 Japanese Garden\n4.2 Revolution！\n4.3 Deco\n4.4 No Frontiers！\n4.5 Coastal Breeze\n4.6 What Lies Beneath\n第5章 文字排印\n5.1 Oceans Apart\n5.2 si6\n5.3 Release One\n5.4 Dead or Alive\n5.5 Blood Lust\n5.6 Golden Mean\n第6章 特效\n6.1 This is Cereal\n6.2 Gemination\n6.3 Bonsai Sky\n6.4 Tulipe\n6.5 door to my garden\n6.6 Elastic Lawn\n第7章 重构\n7.1 Hedges\n7.2 Radio Zen\n7.3 South of the Border\n7.4 Corporate Zen Works\n7.5 Open Window\n7.6 mnemonic\n结语",
        "pages": "273",
        "images": {
          "small": "https://img3.doubanio.com/spic/s2406764.jpg",
          "large": "https://img3.doubanio.com/lpic/s2406764.jpg",
          "medium": "https://img3.doubanio.com/mpic/s2406764.jpg"
        },
        "alt": "https://book.douban.com/subject/2052176/",
        "id": "2052176",
        "publisher": "人民邮电出版社",
        "isbn10": "711516035X",
        "isbn13": "9787115160355",
        "title": "Css禅意花园",
        "url": "https://api.douban.com/v2/book/2052176",
        "alt_title": "",
        "author_intro": "Dave Shea是一位图像设计师，“CSS禅意花园”网站的创始人和耕耘者，该网站获得了很多奖项，其中包括SouthWest Interactive会议授予的\"Best of Show”。Dave Shea曾在全球的行业大会上发表演讲，其作品被世界各地的书籍和杂志采用。他还是Web Standards Project（WaSP）的成员，这是一个由Web开发人员和设计师组成的小组，致力于推广基于跨平台和非专用技术的Web设计。Dave是Web设计机构Bright Creative的拥有者兼主管，还为其在线出版物mezzoblue.com编写所有Web内容几乎均为Dave所作。\nMollv E．Holzschlag是一位作家、教师和Web设计师，编写了30多本有关Web设计和开发的图书。她享有“最伟大的数字作家之一”的美誉，同时被认为是网上最有影响力的25位女性之一。Molly无疑是Web设计和开发界最有趣、最活跃的人物之一。\n作为WaSP指导委员会的成员，Molly同其他Web开发人员和设计师一道，致力于推广w3C推荐规范。她还在亚利桑那大学、菲尼克斯大学和比马社区学院教授“网站管理员(Webmaster)”课程。在Web Techniques Magazine关闭之前的最后三年中，Molly在该杂志撰写的专栏Integrated Design深受欢迎；她还在WebReview．tom担任过一年的执行编辑。",
        "summary": "这本书的作者是世界著名的网站设计师，书中的范例来自网站设计领域最著名的网站——CSS Zen Garden（CSS禅意花园）。全书分为两个主要部分。第1章为第一部分，讨论网站“CSS禅意花同”及其最基本的主题，包含正确的标记结构和灵活性规划等。第二部分包括6章，占据了书中的大部分篇幅。\n每章剖析“CSS禅意花园”收录的6件设计作品，这些作品围绕一个主要的设计概念展开，如文字的使用等。通过探索36件设计作品面临的挑战和解决的问题，读者将洞悉主要的Web设计原则以及它们运用的CSS布局技巧，理解CSS设计的精髓，恰当地处理图形和字体来创建界面优美、性能优良且具有强大生命力的网站。",
        "price": "49.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "7b11835db2a2805111cb5ed773baf432f4a5b066b0cca97c379632330b8f9520",
        "file": "CSS禅意花园(修订版).epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 312,
          "average": "7.2",
          "min": 0
        },
        "subtitle": "HTML5和CSS3实战",
        "author": [
          "Ben Frain"
        ],
        "pubdate": "2013-1-1",
        "tags": [
          {
            "count": 255,
            "name": "响应式设计",
            "title": "响应式设计"
          },
          {
            "count": 185,
            "name": "Web开发",
            "title": "Web开发"
          },
          {
            "count": 151,
            "name": "html5",
            "title": "html5"
          },
          {
            "count": 138,
            "name": "前端开发",
            "title": "前端开发"
          },
          {
            "count": 109,
            "name": "CSS3",
            "title": "CSS3"
          },
          {
            "count": 74,
            "name": "HTML5",
            "title": "HTML5"
          },
          {
            "count": 40,
            "name": "css3",
            "title": "css3"
          },
          {
            "count": 39,
            "name": "web",
            "title": "web"
          }
        ],
        "origin_title": "Responsive Web Design with HTML5 and CSS3",
        "image": "https://img3.doubanio.com/mpic/s24423104.jpg",
        "binding": "平装",
        "translator": [
          "王永强"
        ],
        "catalog": "第1章 　HTML5、CSS3及响应式设计入门　　1\n1.1 　为什么智能手机很重要（而老版的IE不再重要）　　2\n1.2 　响应式设计一定是最佳选择吗　　3\n1.3 　响应式网页设计的定义　　3\n1.4 　为什么要在响应式设计上停滞不前　　4\n1.5 　响应式网页设计示例　　4\n1.5.1 　下载视口调试工具　　4\n1.5.2 　在线创意源泉　　11\n1.6 　为什么HTML5很优秀　　12\n1.6.1 　省时省力　　12\n1.6.2 　新增了语义化标签元素　　13\n1.7 　CSS3为响应式设计和更多创新奠定了基础　　13\n1.7.1 　底线：CSS3不破坏任何东西　　14\n1.7.2 　CSS3如何解决日常设计问题　　14\n1.8 　看呐，不用图片　　17\n1.9 　HTML5和CSS3现在就能用吗　　20\n1.10 　响应式网页设计不是灵丹妙药　　20\n1.11 　引导客户：网站不必在所有浏览器中表现一致　　21\n1.12 　小结　　22\n第2章 　媒体查询：支持不同的视口　　23\n2.1 　现在就能使用媒体查询　　23\n2.2 　为什么响应式设计需要媒体查询　　24\n2.2.1 　媒体查询语法　　24\n2.2.2 　 媒体查询能检测那些特性　　26\n2.2.3 　用媒体查询改造我们的设计　　27\n2.2.4 　加载媒体查询的最佳方法　　27\n2.3 　我们的第一个响应式设计　　27\n2.3.1 　我们的设计是固定宽度的，不要惊讶　　28\n2.3.2 　响应式设计中要保证图片尽可能精简　　32\n2.3.3 　小视口下的内容剪切　　33\n2.4 　阻止移动浏览器自动调整页面大小　　34\n2.5 　针对不同视口宽度修正设计　　37\n2.6 　响应式设计中内容始终优先　　38\n2.7 　媒体查询只是必要条件之一　　42\n2.8 　小结　　42\n第3章 　拥抱流式布局　　43\n3.1 　固定布局经不起未来考验　　43\n3.2 　为什么响应式设计需要百分比布局　　44\n3.3 　将网页从固定布局修改为百分比布局　　44\n3.3.1 　需要牢记的公式　　45\n3.3.2 　设置百分比元素的上下文　　47\n3.3.3 　必须时刻牢记上下文　　52\n3.4 　用em替换px　　54\n3.5 　弹性图片　　56\n3.5.1 　让图片随视口缩放　　56\n3.5.2 　为特定图片指定特定规则　　58\n3.5.3 　给弹性图片设置阈值　　59\n3.5.4 　超级全能的max-width属性　　61\n3.6 　为不同的屏幕尺寸提供不同的图片　　61\n3.7 　流动网格布局和媒体查询的默契配合　　66\n3.8 　CSS网格系统　　66\n3.9 　小结　　72\n第4章 　响应式设计中的HTML5　　73\n4.1 　HTML5的哪些部分现在就能用　　73\n4.1.1 　大多数网站可以用HTML5编写　　74\n4.1.2 　腻子脚本和Modernizr　　74\n4.2 　如何编写HTML5网页　　75\n4.2.1 　HTML5的精简之道　　76\n4.2.2 　HTML5标签的合理写法　　76\n4.2.3 　伟大的<a>标签万岁　　77\n4.2.4 　HTML的废弃零件　　77\n4.3 　HTML5的全新语义化元素　　78\n4.3.1 　<section>　　78\n4.3.2 　<nav>　　79\n4.3.3 　<article>　　79\n4.3.4 　<aside>　　79\n4.3.5 　<hgroup>　　79\n4.3.6 　<header>　　81\n4.3.7 　<footer>　　81\n4.3.8 　<address>　　81\n4.4 　HTML5结构元素的实际用法　　81\n4.5 　HTML5的文本级语义元素　　87\n4.5.1 　<b>　　88\n4.5.2 　<em>　　88\n4.5.3 　<i>　　88\n4.5.4 　在页面中应用文本层语义元素　　88\n4.6 　遵循WAI-ARIA实现无障碍站点　　90\n4.7 　在HTML5中嵌入媒体　　93\n4.8 　用HTML5的方法为页面添加视频或音频　　93\n4.8.1 　提供备用的媒体源文件　　95\n4.8.2 　针对老版本浏览器的备用方案　　95\n4.8.3 　和标签的用法基本一致　　96\n4.9 　响应式视频　　96\n4.10 　离线Web应用　　99\n4.10.1 　离线Web应用概述　　99\n4.10.2 　让网页可离线使用　　99\n4.10.3 　理解manifest文件　　100\n4.10.4 　页面被自动加载到离线缓存　　101\n4.10.5 　版本注释的用途　　101\n4.10.6 　离线访问网站　　101\n4.10.7 　离线Web应用的故障诊断　　102\n4.11 　小结　　103\n第5章 　CSS3：选择器、字体和颜色模式　　104\n5.1 　CSS3给前端开发人员带来了什么　　104\n5.1.1 　Internet Explorer 6到8对CSS3的支持　　105\n5.1.2 　使用CSS3设计和开发页面　　105\n5.2 　CSS规则解析　　105\n5.3 　私有前缀及其用法　　106\n5.4 　快速而有效的CSS技巧　　108\n5.4.1 　CSS3多栏布局　　108\n5.4.2 　文字换行　　110\n5.5 　CSS3的新增选择器及其用法　　111\n5.5.1 　CSS3属性选择器　　111\n5.5.2 　CSS3结构伪类　　113\n5.5.3 　对伪元素的修正　　122\n5.6 　自定义网页字体　　123\n5.6.1 　@font-face规则　　124\n5.6.2 　使用@font-face嵌入网页字体　　124\n5.7 　帮帮我，标题模糊怎么办　　127\n5.8 　新的CSS3颜色格式和透明度　　129\n5.8.1 　RGB颜色　　130\n5.8.2 　HSL颜色　　131\n5.8.3 　针对IE6、IE7和IE8提供备用颜色值　　132\n5.8.4 　透明通道　　132\n5.9 　小结　　134\n第6章 　用CSS3创造令人惊艳的美　　135\n6.1 　文字阴影　　136\n6.1.1 　HEX、HSL或RGB颜色都可以　　136\n6.1.2 　px、em或rem都行　　136\n6.1.3 　取消文字阴影　　138\n6.1.4 　制作浮雕文字阴影效果　　139\n6.1.5 　多重文字阴影　　140\n6.2 　盒阴影　　140\n6.2.1 　内阴影　　141\n6.2.2 　多重阴影　　142\n6.3 　背景渐变　　143\n6.3.1 　线性背景渐变　　144\n6.3.2 　径向背景渐变　　147\n6.3.3 　重复渐变　　149\n6.4 　背景渐变图案　　151\n6.5 　CSS3的响应性　　153\n6.6 　组合使用CSS3属性　　155\n6.7 　多重背景图片　　159\n6.7.1 　背景图片大小　　161\n6.7.2 　背景图片位置　　161\n6.7.3 　背景属性的缩写语法　　161\n6.8 　更多CSS特性　　162\n6.9 　可缩放图标：响应式设计中的完美选择　　162\n6.10 　小结　　163\n第7章 　CSS3过渡、变形和动画　　164\n7.1 　什么是CSS3过渡以及如何使用它　　164\n7.1.1 　过渡相关的属性　　166\n7.1.2 　响应式网站中的有趣过渡　　168\n7.2 　CSS3的2D变形　　169\n7.3 　尝试CSS3的3D变形　　174\n7.3.1 　分析3D变形效果　　176\n7.3.2 　3D变形尚未成熟　　178\n7.4 　CSS3动画效果　　179\n7.5 　小结　　185\n第8章 　用HTML5和CSS3征服表单　　186\n8.1 　HTML5表单　　186\n8.1.1 　理解HTML5表单中的元素　　188\n8.1.2 　placeholder　　189\n8.1.3 　required　　189\n8.1.4 　autofocus　　190\n8.1.5 　autocomplete　　191\n8.1.6 　list（及对应的datalist元素）　　191\n8.1.7 　HTML5的新输入类型　　192\n8.1.8 　日期和时间输入类型　　198\n8.2 　如何给不支持新特性的浏览器打补丁　　203\n8.3 　使用CSS3美化HTML5表单　　204\n8.4 　小结　　210\n第9章 　解决跨浏览器问题　　211\n9.1 　渐进增强与优雅降级　　215\n9.2 　该不该修复老版本IE　　216\n9.2.1 　统计数据（再看看世界的变化）　　216\n9.2.2 　个人选择　　216\n9.3 　前端的瑞士军刀：Modernizr　　217\n9.3.1 　使用Modernizr辅助修正样式问题　　219\n9.3.2 　使用Modernizr让老版本IE支持HTML5元素　　221\n9.3.3 　给IE6、7、8追加min/max媒体查询功能　　222\n9.3.4 　使用Modernizr按需加载资源　　223\n9.4 　必要时将导航链接转换为下拉菜单　　225\n9.5 　高分辨率设备（未来趋势）　　228\n9.6 　小结　　231\n",
        "pages": "231",
        "images": {
          "small": "https://img3.doubanio.com/spic/s24423104.jpg",
          "large": "https://img3.doubanio.com/lpic/s24423104.jpg",
          "medium": "https://img3.doubanio.com/mpic/s24423104.jpg"
        },
        "alt": "https://book.douban.com/subject/20390374/",
        "id": "20390374",
        "publisher": "人民邮电出版社",
        "isbn10": "7115299226",
        "isbn13": "9787115299222",
        "title": "响应式Web设计",
        "url": "https://api.douban.com/v2/book/20390374",
        "alt_title": "Responsive Web Design with HTML5 and CSS3",
        "author_intro": "Ben Frain是一名具有十多年经验的网页设计师和前端工程师，直接与世界各地的客户和设计机构并肩工作。同时他还是一名技术记者，定期为一些关注Mac平台、前沿科技、网页设计和航空技术的刊物撰稿。\n在此之前，他曾是一名怀才不遇的（而且谦虚谨慎的）电视演员，毕业于索尔福德大学的媒体与表演专业。他写了四部（自认为）同样被低估的剧本，而且始终心怀能卖出一部的信念（尽管不像最初那么强烈了）。\n工作之余，在身体（和妻子）允许的情况下，他喜欢玩室内足球。 他的个人网站是www.benfrain.com，Twitter地址是twitter.com/benfrain。",
        "summary": "随着iPad mini的发布，又一个新的屏幕尺寸诞生了。用不着全面统计，你就会发现移动互联网时代众多的屏幕规格，从智能手机的3、4、5英寸，到平板电脑的7、8、9、10英寸，再到笔记本和台式机的13至30英寸，绝非目前单一的固定或流式布局所能应付。于是，响应式设计应运而生，而且它也将成为移动互联网时代前端设计与开发人员的一门必修课。\n本书堪称学习响应式Web设计的难得佳作。它不仅全面、细致、图文并茂地介绍了响应式设计相关的技术，比如媒体查询、流式布局、弹性媒体和弹性字体等，还把近几年来Web设计领域公认的最佳设计理念有机地融入到了实例当中，比如移动先行（Mobile First）、渐进增强、平稳退化、无障碍设计等。更加难得的是，本书以设计跨屏幕的网页（响应式设计）为出发点，以点带面，把如今Web设计领域两大标准的最新版本HTML5和CSS3也纳入其中，读者在掌握先进设计方法的同时也能掌握最新的设计技术（比如使用新的HTML5结构化语义标记、嵌入媒体、响应式视频，以及CSS3的新选择器、特效、过渡、变形和动画等），从而可以免除重复学习新标准之苦，让自己一步跨入Web设计领域的最前沿。无论你想学习响应式Web设计，还是学习HTML5和CSS3的实际应用，本书都能满足你的需要，是毋庸置疑的明智之选。\n说到底，响应式Web设计并非一门独立的技术，而只是现有技术的一个组合应用。只要有一点HTML和CSS基础的读者都能顺利地掌握它。对于中、高级的前端设计和开发人员，翻阅本书也有助于理清自己的知识脉络，对这个新的设计理念获得更全面、深入的理解和把握。\n习惯移动阅读的读者，可访问图灵社区，购买本书电子版：http://www.ituring.com.cn/book/1055",
        "price": "49.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "461665e0abf4e2a7064025358bfe39ee4b8534f106dd590a4559a9950e998bcf",
        "file": "响应式Web设计_HTML5和CSS3实战 - Ben Frain.epub"
      }
    ]
  },
  {
    "dir_name": "cvs",
    "name": "版本管理",
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 137,
          "average": "9.3",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "Scott Chacon",
          "Ben Straub"
        ],
        "pubdate": "2014-11-9",
        "tags": [
          {
            "count": 94,
            "name": "Git",
            "title": "Git"
          },
          {
            "count": 66,
            "name": "版本控制",
            "title": "版本控制"
          },
          {
            "count": 39,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 22,
            "name": "Programming",
            "title": "Programming"
          },
          {
            "count": 16,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 16,
            "name": "git",
            "title": "git"
          },
          {
            "count": 12,
            "name": "软件工程",
            "title": "软件工程"
          },
          {
            "count": 8,
            "name": "英文版",
            "title": "英文版"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/mpic/s27715507.jpg",
        "binding": "Paperback",
        "translator": [],
        "catalog": "1. Getting Started\n1.1 About Version Control\n1.2 A Short History of Git\n1.3 Git Basics\n1.4 The Command Line\n1.5 Installing Git\n1.6 First-Time Git Setup\n1.7 Getting Help\n1.8 Summary\n2. Git Basics\n2.1 Getting a Git Repository\n2.2 Recording Changes to the Repository\n2.3 Viewing the Commit History\n2.4 Undoing Things\n2.5 Working with Remotes\n2.6 Tagging\n2.7 Git Aliases\n2.8 Summary\n3. Git Branching\n3.1 Branches in a Nutshell\n3.2 Basic Branching and Merging\n3.3 Branch Management\n3.4 Branching Workflows\n3.5 Remote Branches\n3.6 Rebasing\n3.7 Summary\n4. Git on the Server\n4.1 The Protocols\n4.2 Getting Git on a Server\n4.3 Generating Your SSH Public Key\n4.4 Setting Up the Server\n4.5 Git Daemon\n4.6 Smart HTTP\n4.7 GitWeb\n4.8 GitLab\n4.9 Third Party Hosted Options\n4.10 Summary\n5. Distributed Git\n5.1 Distributed Workflows\n5.2 Contributing to a Project\n5.3 Maintaining a Project\n5.4 Summary\n6. GitHub\n6.1 Account Setup and Configuration\n6.2 Contributing to a Project\n6.3 Maintaining a Project\n6.4 Managing an organization\n6.5 Scripting GitHub\n6.6 Summary\n7. Git Tools\n7.1 Revision Selection\n7.2 Interactive Staging\n7.3 Stashing and Cleaning\n7.4 Signing Your Work\n7.5 Searching\n7.6 Rewriting History\n7.7 Reset Demystified\n7.8 Advanced Merging\n7.9 Rerere\n7.10 Debugging with Git\n7.11 Submodules\n7.12 Bundling\n7.13 Replace\n7.14 Credential Storage\n7.15 Summary\n8. Customizing Git\n8.1 Git Configuration\n8.2 Git Attributes\n8.3 Git Hooks\n8.4 An Example Git-Enforced Policy\n8.5 Summary\n9. Git and Other Systems\n9.1 Git as a Client\n9.2 Migrating to Git\n9.3 Summary\n10. Git Internals\n10.1 Plumbing and Porcelain\n10.2 Git Objects\n10.3 Git References\n10.4 Packfiles\n10.5 The Refspec\n10.6 Transfer Protocols\n10.7 Maintenance and Data Recovery\n10.8 Environment Variables\n10.9 Summary\nA1. Git in Other Environments\nA1.1 Graphical Interfaces\nA1.2 Git in Visual Studio\nA1.3 Git in Eclipse\nA1.4 Git in Bash\nA1.5 Git in Zsh\nA1.6 Git in Powershell\nA1.7 Summary\nA2. Embedding Git in your Applications\nA2.1 Command-line Git\nA2.2 Libgit2\nA2.3 JGit\nA3. Git Commands\nA3.1 Setup and Config\nA3.2 Getting and Creating Projects\nA3.3 Basic Snapshotting\nA3.4 Branching and Merging\nA3.5 Sharing and Updating Projects\nA3.6 Inspection and Comparison\nA3.7 Debugging\nA3.8 Patching\nA3.9 Email\nA3.10 External Systems\nA3.11 Administration\nA3.12 Plumbing Commands",
        "pages": "350",
        "images": {
          "small": "https://img1.doubanio.com/spic/s27715507.jpg",
          "large": "https://img1.doubanio.com/lpic/s27715507.jpg",
          "medium": "https://img1.doubanio.com/mpic/s27715507.jpg"
        },
        "alt": "https://book.douban.com/subject/26208470/",
        "id": "26208470",
        "publisher": "Apress",
        "isbn10": "1484200772",
        "isbn13": "9781484200773",
        "title": "Pro Git2 - GitBook",
        "url": "https://api.douban.com/v2/book/26208470",
        "alt_title": "",
        "author_intro": "",
        "summary": "Scott Chacon is a cofounder and the CIO of GitHub and is also the maintainer of the Git homepage ( git-scm.com ) . Scott has presented at dozens of conferences around the world on Git, GitHub and the future of work.\nBen Straub is a developer, long time contributor to Libgit2, holder of a Masters degree, international speaker and Git teacher, avid reader, lifelong explorer, and student of the art of making fine software. He lives with his wife and two children in Portland, Oregon.",
        "price": "USD 59.99",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "fe6f33e8112a0c4d9dcee2e18a55fe8c76225debe7aa964a32c4b3024e7bbd1e",
        "file": "progit2-gitbook.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 137,
          "average": "9.3",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "Scott Chacon",
          "Ben Straub"
        ],
        "pubdate": "2014-11-9",
        "tags": [
          {
            "count": 94,
            "name": "Git",
            "title": "Git"
          },
          {
            "count": 66,
            "name": "版本控制",
            "title": "版本控制"
          },
          {
            "count": 39,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 22,
            "name": "Programming",
            "title": "Programming"
          },
          {
            "count": 16,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 16,
            "name": "git",
            "title": "git"
          },
          {
            "count": 12,
            "name": "软件工程",
            "title": "软件工程"
          },
          {
            "count": 8,
            "name": "英文版",
            "title": "英文版"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/mpic/s27715507.jpg",
        "binding": "Paperback",
        "translator": [],
        "catalog": "1. Getting Started\n1.1 About Version Control\n1.2 A Short History of Git\n1.3 Git Basics\n1.4 The Command Line\n1.5 Installing Git\n1.6 First-Time Git Setup\n1.7 Getting Help\n1.8 Summary\n2. Git Basics\n2.1 Getting a Git Repository\n2.2 Recording Changes to the Repository\n2.3 Viewing the Commit History\n2.4 Undoing Things\n2.5 Working with Remotes\n2.6 Tagging\n2.7 Git Aliases\n2.8 Summary\n3. Git Branching\n3.1 Branches in a Nutshell\n3.2 Basic Branching and Merging\n3.3 Branch Management\n3.4 Branching Workflows\n3.5 Remote Branches\n3.6 Rebasing\n3.7 Summary\n4. Git on the Server\n4.1 The Protocols\n4.2 Getting Git on a Server\n4.3 Generating Your SSH Public Key\n4.4 Setting Up the Server\n4.5 Git Daemon\n4.6 Smart HTTP\n4.7 GitWeb\n4.8 GitLab\n4.9 Third Party Hosted Options\n4.10 Summary\n5. Distributed Git\n5.1 Distributed Workflows\n5.2 Contributing to a Project\n5.3 Maintaining a Project\n5.4 Summary\n6. GitHub\n6.1 Account Setup and Configuration\n6.2 Contributing to a Project\n6.3 Maintaining a Project\n6.4 Managing an organization\n6.5 Scripting GitHub\n6.6 Summary\n7. Git Tools\n7.1 Revision Selection\n7.2 Interactive Staging\n7.3 Stashing and Cleaning\n7.4 Signing Your Work\n7.5 Searching\n7.6 Rewriting History\n7.7 Reset Demystified\n7.8 Advanced Merging\n7.9 Rerere\n7.10 Debugging with Git\n7.11 Submodules\n7.12 Bundling\n7.13 Replace\n7.14 Credential Storage\n7.15 Summary\n8. Customizing Git\n8.1 Git Configuration\n8.2 Git Attributes\n8.3 Git Hooks\n8.4 An Example Git-Enforced Policy\n8.5 Summary\n9. Git and Other Systems\n9.1 Git as a Client\n9.2 Migrating to Git\n9.3 Summary\n10. Git Internals\n10.1 Plumbing and Porcelain\n10.2 Git Objects\n10.3 Git References\n10.4 Packfiles\n10.5 The Refspec\n10.6 Transfer Protocols\n10.7 Maintenance and Data Recovery\n10.8 Environment Variables\n10.9 Summary\nA1. Git in Other Environments\nA1.1 Graphical Interfaces\nA1.2 Git in Visual Studio\nA1.3 Git in Eclipse\nA1.4 Git in Bash\nA1.5 Git in Zsh\nA1.6 Git in Powershell\nA1.7 Summary\nA2. Embedding Git in your Applications\nA2.1 Command-line Git\nA2.2 Libgit2\nA2.3 JGit\nA3. Git Commands\nA3.1 Setup and Config\nA3.2 Getting and Creating Projects\nA3.3 Basic Snapshotting\nA3.4 Branching and Merging\nA3.5 Sharing and Updating Projects\nA3.6 Inspection and Comparison\nA3.7 Debugging\nA3.8 Patching\nA3.9 Email\nA3.10 External Systems\nA3.11 Administration\nA3.12 Plumbing Commands",
        "pages": "350",
        "images": {
          "small": "https://img1.doubanio.com/spic/s27715507.jpg",
          "large": "https://img1.doubanio.com/lpic/s27715507.jpg",
          "medium": "https://img1.doubanio.com/mpic/s27715507.jpg"
        },
        "alt": "https://book.douban.com/subject/26208470/",
        "id": "26208470",
        "publisher": "Apress",
        "isbn10": "1484200772",
        "isbn13": "9781484200773",
        "title": "Pro Git (Second Edition)",
        "url": "https://api.douban.com/v2/book/26208470",
        "alt_title": "",
        "author_intro": "",
        "summary": "Scott Chacon is a cofounder and the CIO of GitHub and is also the maintainer of the Git homepage ( git-scm.com ) . Scott has presented at dozens of conferences around the world on Git, GitHub and the future of work.\nBen Straub is a developer, long time contributor to Libgit2, holder of a Masters degree, international speaker and Git teacher, avid reader, lifelong explorer, and student of the art of making fine software. He lives with his wife and two children in Portland, Oregon.",
        "price": "USD 59.99",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "91884058f31e42c7324489427f5f30604272f44ffee3bf0a49ad36109a4ee9f1",
        "file": "progit2.epub"
      }
    ]
  },
  {
    "dir_name": "design",
    "name": "设计",
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 117,
          "average": "8.8",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "Robin Williams"
        ],
        "pubdate": "2016-1",
        "tags": [
          {
            "count": 104,
            "name": "设计",
            "title": "设计"
          },
          {
            "count": 29,
            "name": "艺术/设计",
            "title": "艺术/设计"
          },
          {
            "count": 18,
            "name": "艺术",
            "title": "艺术"
          },
          {
            "count": 17,
            "name": "入门",
            "title": "入门"
          },
          {
            "count": 17,
            "name": "Design",
            "title": "Design"
          },
          {
            "count": 14,
            "name": "产品",
            "title": "产品"
          },
          {
            "count": 12,
            "name": "设计思维",
            "title": "设计思维"
          },
          {
            "count": 11,
            "name": "罗宾·威廉姆斯",
            "title": "罗宾·威廉姆斯"
          }
        ],
        "origin_title": "The Non-Designer's Design Book(4th Edition)",
        "image": "https://img1.doubanio.com/mpic/s28340357.jpg",
        "binding": "平装",
        "translator": [
          "苏金国",
          "李盼"
        ],
        "catalog": "第一部分　设计原则\n第1章　引言　　3\n约书亚树　　3\n4大基本原则　　5\n第2章　亲密性　　7\n把问题说出来　　 22\n亲密性小结　　24\n根本目的　　24\n如何实现　　24\n要避免的问题　　24\n第3章　对齐　　25\n到处看看　　 44\n对齐小结　　46\n根本目的　　46\n如何实现　　46\n要避免的问题　　46\n第4章　重复　　47\n重复小结　　60\n根本目的　　60\n如何实现　　60\n要避免的问题　　60\n第5章　对比　　61\n对比小结　　76\n根本目的　　76\n如何实现　　76\n要避免的问题　　76\n第6章　4大基本原则复习　　77\n亲密性　　78\n对齐　　79\n重复　　80\n对比　　81\n小测验#1：设计原则　　82\n小测验#2：重新设计广告　　83\n小结　　86\n第7章　颜色运用　　87\n不同凡响的色轮　　88\n颜色关系　　89\n互补　　90\n三色组　　91\n分裂互补三色组　　92\n类似色　　93\n暗色和亮色　　94\n建立你自己的暗色和亮色　　95\n单色　　96\n暗色和亮色的组合　　97\n注意色质　　98\n暖色与冷色　　99\n如何取舍　　100\nCMYK与RGB，印刷与Web　　102\n印刷与Web 颜色模型　　104\n小测验#3：颜色　　104\n第8章　更多提示与技巧　　105\n创建包装或品牌　　106\n企业名片　　109\n关于设计企业名片的提示　　112\n信笺和信封　　113\n关于设计信笺和信封的提示　　116\n传单　　117\n关于设计传单的提示　　120\n新闻简报　　121\n关于设计新闻简报的提示　　124\n宣传册　　125\n关于设计宣传册的提示　　128\n明信片　　129\n关于设计明信片的提示　　132\n报纸广告　　133\n关于设计报纸广告的提示　　136\n简历　　137\n关于设计简历的提示　　140\n第二部分　字体设计\n第9章　字体的基本规则　　143\n标点后面一个空格　　144\n引号　　145\n撇号　　146\n小测验#4：撇号　　147\n连接号　　148\n特殊符号　　150\n重音符号　　152\n大写字母　　153\n下划线　　154\n字距调整　　155\n寡妇和孤儿　　156\n其他　　157\n第10章　字体（与人生）　　159\n协调　　160\n冲突　　162\n对比　　164\n小结　　166\n第11章　字体类别　　167\nOldstyle（旧式体）　　168\nModern（现代体）　　169\nSlab serif（粗衬线体）　　170\nSans serif（无衬线体）　　171\nScript（手写体）　　173\nDecorative（花体）　　174\n有意识地去做　　175\n小测验#5：字体类别　　175\n小测验#6：粗/细过渡　　176\n小测验#7：截线　　177\n小结　　178\n第12章　字体对比　　179\n大小　　180\n粗细　　184\n结构　　188\n形状　　192\n方向　　196\n颜色　　200\n结合多种对比　　206\n小结　　207\n小测验#8：对比还是冲突　　208\n小测验#9：可做与不可做　　209\n结合多种对比的练习　　210\n第三部分　其他\n第13章　你掌握了吗　　213\n过程　　214\n练习　　215\n好的——重新设计!　　216\n第14章　测验答案和建议　　217\n测试答案　　217\n设计师之眼建议　　220\n第15章　本书所用字体　　225\n附录A：迷你术语表和资源　　231\n附录B：我永远是一名教师　　232\n附录C：生活就要设计　　237\n索引　　238",
        "ebook_url": "https://read.douban.com/ebook/18692011/",
        "pages": "252",
        "images": {
          "small": "https://img1.doubanio.com/spic/s28340357.jpg",
          "large": "https://img1.doubanio.com/lpic/s28340357.jpg",
          "medium": "https://img1.doubanio.com/mpic/s28340357.jpg"
        },
        "alt": "https://book.douban.com/subject/26664522/",
        "id": "26664522",
        "publisher": "人民邮电出版社",
        "isbn10": "7115404402",
        "isbn13": "9787115404404",
        "title": "写给大家看的设计书（第4版）",
        "url": "https://api.douban.com/v2/book/26664522",
        "alt_title": "The Non-Designer's Design Book(4th Edition)",
        "author_intro": "Robin　Williams\n世界著名设计师、技术专家和畅销书作家。通过写书和授课，她已经影响了整整一代数字设计师。同时，作为Adobe和Mac技术社区内的偶像级专家，她拥有大批拥戴者。\n她是Publish　Magazine、Adobe　Magazine等杂志的专栏作家，是MacWorld　Expo等业界重要活动和组织的顾问委员会成员，还创办了Santa　Fe电影艺术学院。除本书外，她还著有几十部畅销图书和获奖著作，包括《写给大家看的Web设计书》等，有的书已经被翻译为十几种文字，产生了世界性的影响。\n图灵社区对她做过访谈，感兴趣的读者可以看看被豆瓣网友评为J.K.罗琳似的艰苦奋斗代表是如何自我定位的：ituring.cn/article/41065。",
        "summary": "畅销设计入门书最新版，让每个人都能成为设计师\n在这个创意无处不在的时代，越来越多的人成为设计师。简历、论文、PPT、个人主页、博客、活动海报、给客人的邮件、名片……，处处都在考验你的设计能力。\n美术功课不好？没有艺术细胞？毫无设计经验？\n没关系！在设计大师RobinWilliams看来，设计其实很简单。在这部畅销全球多年、影响了一代设计师的经典著作中，RobinWilliams将优秀设计的秘诀归纳为对比、重复、对齐和亲密性四条基本原则，并用简洁通俗、幽默生动的文笔，同时配以大量经过修改进行前后对比的实例图解和设计练习（并提供解答），直观清晰地传授给读者。通过本书，普通读者很快就能够自信地设计出专业级别的作品，而专业设计师也将从中获得灵感和解决问题的途径。\nRobin　Williams　　世界著名设计师、技术专家和畅销书作家。通过写书和授课，她已经影响了整整一代数字设计师。同时，作为Adobe和Mac技术社区内的偶像级专家，她拥有大批拥戴者。她是Publish　Magazine、Adobe　Magazine等杂志的专栏作家，是MacWorld　Expo等业界重要活动和组织的顾问委员会成员，还创办了Santa　Fe电影艺术学院。除本书外，她还著有几十部畅销图书和获奖著作，包括《写给大家看的Web设计书》等，有的书已经被翻译为十几种文字，产生了世界性的影响。图灵社区对她做过访谈，收录在本书内，感兴趣的读者看看被豆瓣网友评为“J.K.罗琳似的艰苦奋斗代表”的Robin是如何自我定位的。访谈电子版地址：ituring.cn/article/41065。",
        "ebook_price": "18.00",
        "price": "59.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "257da09d5f062526e19047a82f9052d93d22ff1706bf3165276fea1f9c7b4a2b",
        "file": "写给大家看的设计书-第四版.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 21,
          "average": "8.8",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "【美】Stephen Hay"
        ],
        "pubdate": "2014-9-1",
        "tags": [
          {
            "count": 28,
            "name": "响应式设计",
            "title": "响应式设计"
          },
          {
            "count": 20,
            "name": "Web前端",
            "title": "Web前端"
          },
          {
            "count": 18,
            "name": "交互设计",
            "title": "交互设计"
          },
          {
            "count": 10,
            "name": "前端",
            "title": "前端"
          },
          {
            "count": 9,
            "name": "网页设计",
            "title": "网页设计"
          },
          {
            "count": 6,
            "name": "前端开发",
            "title": "前端开发"
          },
          {
            "count": 6,
            "name": "web设计",
            "title": "web设计"
          },
          {
            "count": 6,
            "name": "web",
            "title": "web"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/view/subject/m/public/s27759609.jpg",
        "binding": "平装",
        "translator": [
          "余果"
        ],
        "catalog": "第1章　拥抱变化　1\n1.1　精美设计稿的诞生　2\n1.2　静态设计稿舒适区　4\n1.3　专家的入侵　5\n1.4　我们都是交互设计师　8\n1.5　跳出瀑布模型　8\n1.6　压死骆驼的稻草　9\n1.7　屋里的大象　10\n1.8　这并非福音书　11\n1.9　这是个挑战　11\n第2章　从内容开始　13\n2.1　微结构vs.模块化结构　14\n2.2　懒人的内容清单　16\n2.3　通用的例子：本书网站　　16\n2.4　渐进的设计原则：零界面　17\n2.5　创建内容清单示例　18\n2.6　试试看　21\n第3章　内容参考线框图　23\n3.1　别把线框图复杂化　25\n3.2　第一步：创建低保真的、基于网络的设计稿　26\n3.2.1　创建基础HTML　27\n3.2.2　形成基本样式　30\n3.2.3　移动优先版线框图　33\n3.2.4　添加导航　35\n3.2.5　为大尺寸屏幕创造变量　37\n3.3　打破神话　43\n3.3.1　交互设计师应该做线框图　43\n3.3.2　线框图应该详细　44\n3.3.3　内容参考线框图是否限制了设计选择？　44\n3.3.4　现在就考虑布局是不是有点太早了？　45\n3.3.5　我应该做什么样的线框图？　45\n3.3.6　我应何时让客户参与？(或者说“我的漂亮的交付品在哪儿？”)　46\n3.4　动手试试　46\n第4章　基于文本而设计　49\n4.1　内容为王　50\n4.2　标记纯文本　53\n4.2.1　用Markdown来处理图书页面的内容　54\n4.2.2　这个阶段修改的意义　56\n4.2.3　思考很重要　58\n4.3　将纯文本转换为HTML　59\n4.3.1　使用命令行　60\n4.3.2　转化为HTML　65\n第5章　线性设计　67\n5.1　开发一种设计语言　68\n5.1.1　使用设计漏斗　70\n5.1.2　在实际设备中运行设计　72\n5.2　增强结构化内容　74\n5.2.1　模板介绍　76\n5.2.2　目前你的项目文件夹　79\n5.2.3　思考和画草图　80\n5.2.4　多尝试字体和颜色　81\n5.2.5　暂时不要做太多　85\n第6章　断点图　87\n6.1　文档断点　89\n6.1.1　剖析断点　90\n6.1.2　可视化断点　92\n6.1.3　断点图组件　93\n6.2　创建简单的断点图　95\n6.3　主次断点　97\n6.4　添加更多东西　98\n6.5　总结　102\n第7章　为断点而设计　103\n7.1　首先，关于草图的一点点东西　104\n7.1.1　如何素描　105\n7.1.2　在设备上素描　109\n7.1.3　养成素描的习惯　111\n7.2　专注于主断点　112\n7.3　素描的时候仔细思考内容　114\n7.3.1　文本　114\n7.3.2　导航　115\n7.3.3　表格　116\n7.4　当你没有灵感的时候怎么办　119\n第8章　创建Web设计模型　121\n8.1　跨越障碍　123\n8.1.1　客户不关心　123\n8.1.2　其他的人　124\n8.1.3　你自己　125\n8.1.4　展示你的模型　127\n8.2　开始实践　128\n8.3　从静态页面到静态网站生成器　133\n8.3.1　模板　133\n8.3.2　选择一个静态站点生成器　134\n8.3.3　关于Dexy　135\n8.3.4　安装Dexy　136\n8.3.5　你积累的资源　140\n8.3.6　添加样式　140\n8.3.7　添加内容　142\n8.3.8　给内容分组　142\n8.3.9　Dexy控制中心：dexy.yaml文件　146\n8.3.10　使用CSS完成Web设计模型　148\n8.3.11　多个页面　148\n8.4　总结　150\n第9章　截屏　151\n9.1　为什么不直接在网页上进行展示？　152\n9.1.1　演示/现实的平衡　153\n9.1.2　截屏：从Web设计模型回到图像　154\n9.2　如何截屏　157\n9.2.1　手动截屏　157\n9.2.2　自动截屏　159\n9.3　展示截屏　164\n第10章　成果展示：浏览器体验　167\n10.1　你会在你的设计中发现很多的bug　168\n10.2　沟通与协作　169\n10.3　怎样去展示你的交互原型　171\n10.3.1　用设备来让你的设计更有说服力　171\n10.3.2　解释你的设计　172\n10.4　测试和客户审阅　173\n10.4.1　客户审阅　175\n10.4.2　做好笔记　176\n10.4.3　使用笔记去修改设计　182\n第11章　创建设计手册　185\n11.1　网页设计规范　187\n11.2　设计手册的内容与结构　189\n11.3　我心仪的规范设计软件　191\n11.4　创建设计文档　193\n11.4.1　动手写文档　194\n11.4.2　添加各种形式的示例　196\n11.4.3　生成截图　197\n11.4.4　配置Dexy　199\n11.4.5　测试整个Dexy项目　200\n11.4.6　捕获特定元素的屏幕截图　201\n11.4.7　引入能渲染出效果的HTML　204\n11.4.8　包含高亮的代码　207\n11.4.9　动手做一个你自己的文档　210\n11.5　写在末尾的话　211",
        "pages": "212",
        "images": {
          "small": "https://img1.doubanio.com/view/subject/s/public/s27759609.jpg",
          "large": "https://img1.doubanio.com/view/subject/l/public/s27759609.jpg",
          "medium": "https://img1.doubanio.com/view/subject/m/public/s27759609.jpg"
        },
        "alt": "https://book.douban.com/subject/26241601/",
        "id": "26241601",
        "publisher": "人民邮电出版社",
        "isbn10": "7115364214",
        "isbn13": "9787115364210",
        "title": "响应式Web设计全流程解析",
        "url": "https://api.douban.com/v2/book/26241601",
        "alt_title": "",
        "author_intro": "Stephen Hay\n出生于加利福利亚，1992年时迁往荷兰生活和工作，从1 9 9 5 年开始设计Web站点。他现在的工作是在Zero Interface公司担任Web设计和开发顾问，在那之前他做过企业形象设计、包装设计、广告设计，这些设计经验为其现在的工作奠定了扎实的基础。除了经常在行业会议上发表演讲，Stephen还会发表一些关于CSS、Web可用性、开放网络标准以及设计方面的文章。",
        "summary": "固定宽度的Photoshop图层、不断膨胀的客户需求、无休止的线框图……抛弃它们吧！陈旧的Web设计交付流程不再适用于移动时代的响应式方案。设计的工作流本质上并没有发生改变，是最佳实践变了。\n《响应式Web设计全流程解析》为你展示了如何拥抱新的设计范式，创造微信时代的网站。你会学到的策略包括：如何更好地管理客户的开发需求和预期；在浏览器中进行设计的方法；超越静态的Photoshop图层的文档化方法；将响应式设计断点可视化的方法。 　学习并掌握《响应式Web设计全流程解析》引人入胜的内容之后，你就可以完全抛弃老旧的瀑布流交付模型，转而使用一种全新的方式来设计移动时代的网站。",
        "price": "55",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "5ea0d8b476b87b9e7a627d043658c7414993a1ebf44d65414c1cfa401395742c",
        "file": "响应式Web设计全流程解析.epub"
      }
    ]
  },
  {
    "dir_name": "engineering",
    "name": "软件工程",
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 26,
          "average": "8.0",
          "min": 0
        },
        "subtitle": "好代码的逻辑",
        "author": [
          "[美] Cristina Videira Lopes"
        ],
        "pubdate": "2017-8",
        "tags": [
          {
            "count": 30,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 18,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 15,
            "name": "Python",
            "title": "Python"
          },
          {
            "count": 12,
            "name": "编程风格",
            "title": "编程风格"
          },
          {
            "count": 11,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 8,
            "name": "编程艺术",
            "title": "编程艺术"
          },
          {
            "count": 5,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 5,
            "name": "软件工程",
            "title": "软件工程"
          }
        ],
        "origin_title": "Exercises in Programming Style",
        "image": "https://img3.doubanio.com/view/subject/m/public/s29507161.jpg",
        "binding": "平装",
        "translator": [
          "顾中磊"
        ],
        "catalog": "第一部分　悠久历史\n第1章　往日的美好　　2\n1.1　约束　　2\n1.2　代码　　3\n1.3　注解　　5\n1.4　系统设计中的应用　　6\n1.5　发展历程　　7\n1.6　拓展阅读　　7\n1.7　词汇表　　8\n1.8　练习　　8\n第2章　Forth风格　　9\n2.1　约束　　9\n2.2　代码　　10\n2.3　注解　　12\n2.4　发展历程　　14\n2.5　拓展阅读　　14\n2.6　词汇表　　14\n2.7　练习　　15\n第二部分　基本风格\n第3章　单片风格　　18\n3.1　约束　　18\n3.2　代码　　19\n3.3　注解　　20\n3.4　系统设计中的应用　　21\n3.5　拓展阅读　　22\n3.6　词汇表　　22\n3.7　练习　　22\n第4章　食谱风格　　23\n4.1　约束　　23\n4.2　代码　　24\n4.3　注解　　25\n4.4　系统设计中的应用　　26\n4.5　发展历程　　27\n4.6　拓展阅读　　27\n4.7　词汇表　　27\n4.8　练习　　28\n第5章　流水线风格　　29\n5.1　约束　　29\n5.2　代码　　30\n5.3　注解　　31\n5.4　系统设计中的应用　　33\n5.5　发展历程　　33\n5.6　拓展阅读　　34\n5.7　词汇表　　35\n5.8　练习　　35\n第6章　高尔夫风格　　36\n6.1　约束　　36\n6.2　代码　　37\n6.3　注解　　37\n6.4　系统设计中的应用　　38\n6.5　发展历程　　39\n6.6　拓展阅读　　39\n6.7　词汇表　　39\n6.8　练习　　39\n第三部分　函数组合\n第7章　无限镜像风格　　42\n7.1　约束　　42\n7.2　代码　　43\n7.3　注解　　44\n7.4　发展历程　　44\n7.5　拓展阅读　　45\n7.6　词汇表　　45\n7.7　练习　　45\n第8章　骨牌风格　　46\n8.1　约束　　46\n8.2　代码　　47\n8.3　注解　　48\n8.4　系统设计中的应用　　48\n8.5　发展历程　　49\n8.6　拓展阅读　　49\n8.7　词汇表　　49\n8.8　练习　　50\n第9章　单子风格　　51\n9.1　约束　　51\n9.2　代码　　52\n9.3　注解　　53\n9.4　发展历程　　54\n9.5　拓展阅读　　54\n9.6　词汇表　　54\n9.7　练习　　55\n第四部分　对象与对象交互\n第10章　对象风格　　58\n10.1　约束　　58\n10.2　代码　　59\n10.3　注解　　60\n10.4　系统设计中的应用　　62\n10.5　发展历程　　63\n10.6　拓展阅读　　63\n10.7　词汇表　　63\n10.8　练习　　64\n第11章　消息风格　　65\n11.1　约束　　65\n11.2　代码　　66\n11.3　注解　　68\n11.4　系统设计中的应用　　68\n11.5　发展历程　　68\n11.6　拓展阅读　　69\n11.7　词汇表　　69\n11.8　练习　　69\n第12章　闭域风格　　70\n12.1　约束　　70\n12.2　代码　　71\n12.3　注解　　72\n12.4　发展历程　　73\n12.5　拓展阅读　　73\n12.6　词汇表　　73\n12.7　练习　　73\n第13章　抽象对象风格　　75\n13.1　约束　　75\n13.2　代码　　76\n13.3　注解　　78\n13.4　系统设计中的应用　　80\n13.5　发展历程　　80\n13.6　拓展阅读　　80\n13.7　词汇表　　81\n13.8　练习　　81\n第14章　好莱坞风格　　82\n14.1　约束　　82\n14.2　代码　　83\n14.3　注解　　85\n14.4　系统设计中的应用　　86\n14.5　发展历程　　86\n14.6　拓展阅读　　86\n14.7　词汇表　　87\n14.8　练习　　87\n第15章　公告板风格　　88\n15.1　约束　　88\n15.2　代码　　89\n15.3　注解　　91\n15.4　系统设计中的应用　　92\n15.5　发展历程　　92\n15.6　拓展阅读　　92\n15.7　词汇表　　93\n15.8　练习　　93\n第五部分　反射与元编程\n第16章　内省风格　　96\n16.1　约束　　96\n16.2　代码　　97\n16.3　注解　　98\n16.4　系统设计中的应用　　98\n16.5　词汇表　　98\n16.6　练习　　99\n第17章　反射风格　　100\n17.1　约束　　100\n17.2　代码　　101\n17.3　注解　　102\n17.4　系统设计中的应用　　103\n17.5　发展历程　　103\n17.6　拓展阅读　　104\n17.7　词汇表　　104\n17.8　练习　　105\n第18章　切面风格　　106\n18.1　约束　　106\n18.2　代码　　107\n18.3　注解　　108\n18.4　发展历程　　108\n18.5　拓展阅读　　109\n18.6　词汇表　　109\n18.7　练习　　109\n第19章　插件风格　　111\n19.1　约束　　111\n19.2　代码　　112\n19.3　注解　　113\n19.4　系统设计中的应用　　114\n19.5　发展历程　　115\n19.6　拓展阅读　　115\n19.7　词汇表　　116\n19.8　练习　　116\n第六部分　异常处理\n第20章　构建风格　　118\n20.1　约束　　118\n20.2　代码　　119\n20.3　注解　　120\n20.4　系统设计中的应用　　121\n20.5　练习　　121\n第21章　Tantrum风格　　122\n21.1　约束　　122\n21.2　代码　　123\n21.3　注解　　124\n21.4　系统设计中的应用　　125\n21.5　拓展阅读　　125\n21.6　词汇表　　125\n21.7　练习　　125\n第22章　消极攻击风格　　126\n22.1　约束　　126\n22.2　代码　　127\n22.3　注解　　128\n22.4　发展历程　　128\n22.5　拓展阅读　　128\n22.6　词汇表　　129\n22.7　练习　　129\n22.8　构建风格 VS. Tantrum VS.消极攻击风格　　130\n第23章　声明意图风格　　131\n23.1　约束　　131\n23.2　代码　　132\n23.3　注解　　133\n23.4　发展历程　　134\n23.5　拓展阅读　　135\n23.6　词汇表　　135\n23.7　练习　　136\n第24章　隔离风格　　137\n24.1　约束　　137\n24.2　代码　　138\n24.3　注解　　139\n24.4　系统设计中的应用　　142\n24.5　发展历程　　143\n24.6　拓展阅读　　143\n24.7　词汇表　　143\n24.8　练习　　143\n第七部分　以数据为中心\n第25章　持久表风格　　146\n25.1　约束　　146\n25.2　代码　　147\n25.3　注解　　148\n25.4　系统设计中的应用　　149\n25.5　发展历程　　149\n25.6　拓展阅读　　150\n25.7　词汇表　　150\n25.8　练习　　150\n第26章　试算表风格　　151\n26.1　约束　　151\n26.2　代码　　152\n26.3　注解　　153\n26.4　系统设计中的应用　　153\n26.5　发展历程　　154\n26.6　拓展阅读　　154\n26.7　词汇表　　154\n26.8　练习　　154\n第27章　漂流风格　　155\n27.1　约束　　155\n27.2　代码　　156\n27.3　注解　　157\n27.4　系统设计中的应用　　158\n27.5　发展历程　　158\n27.6　拓展阅读　　158\n27.7　词汇表　　159\n27.8　练习　　159\n第八部分　并发\n第28章　参与者风格　　162\n28.1　约束　　162\n28.2　代码　　163\n28.3　注解　　165\n28.4　系统设计中的应用　　167\n28.5　发展历程　　167\n28.6　拓展阅读　　167\n28.7　词汇表　　167\n28.8　练习　　168\n第29章　数据空间风格　　169\n29.1　约束　　169\n29.2　代码　　170\n29.3　注解　　171\n29.4　系统设计中的应用　　171\n29.5　发展历程　　171\n29.6　拓展阅读　　172\n29.7　词汇表　　172\n29.8　练习　　172\n第30章　Map Reduce风格　　173\n30.1　约束　　173\n30.2　代码　　174\n30.3　注解　　175\n30.4　系统设计中的应用　　176\n30.5　发展历程　　177\n30.6　拓展阅读　　177\n30.7　词汇表　　177\n30.8　练习　　177\n第31章　双重Map Reduce风格　　179\n31.1　约束　　179\n31.2　代码　　180\n31.3　注解　　181\n31.4　系统设计中的应用　　182\n31.5　发展历程　　182\n31.6　拓展阅读　　183\n31.7　练习　　183\n第九部分　交互\n第32章　三层架构风格　　186\n32.1　约束　　186\n32.2　代码　　187\n32.3　注解　　188\n32.4　系统设计中的应用　　191\n32.5　发展历程　　191\n32.6　拓展阅读　　191\n32.7　词汇表　　191\n32.8　练习　　191\n第33章　RESTful风格　　193\n33.1　约束　　193\n33.2　代码　　194\n33.3　注解　　196\n33.4　系统设计中的应用　　199\n33.5　发展历程　　199\n33.6　拓展阅读　　199\n33.7　词汇表　　200\n33.8　练习　　200",
        "pages": "220",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s29507161.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s29507161.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s29507161.jpg"
        },
        "alt": "https://book.douban.com/subject/27102599/",
        "id": "27102599",
        "publisher": "人民邮电出版社",
        "isbn10": "7115460353",
        "isbn13": "9787115460356",
        "title": "Exercises in Programming Style",
        "url": "https://api.douban.com/v2/book/27102599",
        "alt_title": "Exercises in Programming Style",
        "author_intro": "Cristina Videira Lopes\n是美国加州大学欧文分校，唐纳德•布伦信息与计算机科学学院信息学专业教授，研究方向是大规模数据和系统下的软件工程。在其职业生涯早年，曾是施乐帕罗奧多研究中心（Xerox PARC）面向方向编程及AspectJ编程语言团队的初创成员。除其研究项目以外，Cristina也是一位多产的软件开发者。她对于开源项目的贡献包括水下声纳调制解调软件和虚拟世界服务OpenSimulator。她是一家专注于为早期可持续城市重建项目提供在线虚拟现实服务的公司的联合创始人。她开发并维护了一款基于OpenSimulator虚拟世界的搜索引擎。",
        "summary": "本书对一个常见的编程问题定义了不同的约束，分别使用33种方法实现了同一个词频统计任务，从而形成了风格迥异的编程风格。作者以惯用的计算机语言与简单的任务为画笔，描绘了一次生动难忘的编程之旅，帮助读者加深了对语言的理解，也提供了崭新的编程思路。",
        "price": "55.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "9fa886a3ea1f70ad7ebcfad07b4d73c34629fc06966ef0c6d4fd0dc1655b0993",
        "file": "Exercises in Programming Style - [Mei ] Cristina Videira Lopes.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 330,
          "average": "8.2",
          "min": 0
        },
        "subtitle": "像google一样进行软件测试",
        "author": [
          "James A. Whittaker",
          "Jason Arbon",
          "Jeff Carollo"
        ],
        "pubdate": "2013-10",
        "tags": [
          {
            "count": 515,
            "name": "软件测试",
            "title": "软件测试"
          },
          {
            "count": 208,
            "name": "测试",
            "title": "测试"
          },
          {
            "count": 160,
            "name": "Google",
            "title": "Google"
          },
          {
            "count": 121,
            "name": "测试方法",
            "title": "测试方法"
          },
          {
            "count": 100,
            "name": "软件工程",
            "title": "软件工程"
          },
          {
            "count": 94,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 69,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 45,
            "name": "计算机科学",
            "title": "计算机科学"
          }
        ],
        "origin_title": "How Google Tests Software",
        "image": "https://img3.doubanio.com/view/subject/m/public/s27082506.jpg",
        "binding": "平装",
        "translator": [
          "黄利",
          "李中杰",
          "薛明"
        ],
        "catalog": "《google软件测试之道》\n第1章　google软件测试介绍　1\n1.1　质量不等于测试　5\n1.2　角色　6\n1.2.1　软件开发工程师(swe)　7\n1.2.2　软件测试开发工程师(set)　7\n1.2.3　测试工程师(te)　8\n1.3　组织结构　9\n1.4　爬、走、跑　10\n1.5　测试类型　12\n第2章　软件测试开发工程师　15\n2.1　set的工作　17\n2.1.1　开发和测试流程　17\n2.1.2　set究竟是谁　21\n2.1.3　项目的早期阶段　22\n2.1.4　团队结构　23\n2.1.5　设计文档　24\n2.1.6　接口与协议　26\n2.1.7　自动化计划　27\n2.1.8　可测试性　28\n.2.1.9　set的工作流程：一个实例　31\n2.1.10　测试执行　41\n2.1.11　测试大小的定义　42\n2.1.12　测试规模在共享测试平台中的使用　45\n2.1.13　测试规模的益处　46\n2.1.14　测试运行要求　48\n2.2　测试认证　54\n2.3　set的招聘　62\n2.4　与工具开发工程师ted mao的访谈　68\n2.5　与web driver的创建者simon stewart的对话　70\n第3章　测试工程师　75\n3.1　一种面向用户的测试角色　75\n3.2　测试工程师的工作　76\n3.2.1　测试计划　79\n3.2.2　风险　94\n3.2.3　测试用例的生命周期　104\n3.2.4　bug的生命周期　109\n3.2.5　te的招聘　121\n3.2.6　google的测试领导和管理工作　128\n3.2.7　维护模式的测试(maintenance mode testing)　131\n3.2.8　质量机器人(quality bot)实验　134\n3.2.9　bite实验　145\n3.2.10　google test analytics　154\n3.2.11　零成本测试流程　159\n3.2.12　外部供应商　163\n3.3　与google docs测试工程师林赛·韦伯斯特(lindsay webster)的访谈　165\n3.4　与youtube测试工程师安普·周(apple chow)的访谈　170\n第4章　测试工程经理　177\n4.1　测试工程经理的工作　177\n4.2　获得项目和人员　179\n4.3　影响力　180\n4.4　gmail测试工程经理ankit mehta的访谈　182\n4.5　android测试工程经理hung dang的访谈　188\n4.6　chrome测试工程经理joel hynoski的访谈　192\n4.7　测试总监　197\n4.8　搜索和地理信息测试总监shelton mar的访谈　198\n4.9　工程工具总监ashish kumar的访谈　201\n4.10　印度google测试总监sujaysahni访谈　205\n4.11　工程经理brad green访谈　209\n4.12　james whittaker访谈　212\n第5章　google软件测试改进　219\n5.1　google流程中的致命缺陷　219\n5.2　set的未来　221\n5.3　te的未来　222\n5.4　测试总监和经理的未来　223\n5.5　未来的测试基础设施　224\n5.6　结论　225\n附录a　chrome os测试计划　227\na.1　测试主题概述　227\na.2　风险分析　228\na.3　每次构建版本的基线测试　228\na.4　最新可测试版本(last known good，lkg)的每日测试　229\na.5　发布版本测试　229\na.6　手工测试与自动化测试　229\na.7　开发和测试的质量关注点　230\na.8　发布通道　230\na.9　用户输入　230\na.10　测试用例库　231\na.11　测试仪表盘　231\na.12　虚拟化　231\na.13　性能　231\na.14　压力、长时运行和稳定性测试　231\na.15　测试执行框架(autotest)　232\na.16　oem厂商　232\na.17　硬件实验田　232\na.18　端到端测试自动化集群　232\na.19　测试浏览器的应用管理器　232\na.20　浏览器的可测试性　233\na.21　硬件　234\na.22　时间线　234\na.23　主要的测试驱动力　236\na.24　相关文档　236\n附录b　chrome的漫游测试　239\nb.1　购物漫游　239\nb.2　学生漫游　240\nb.3　国际长途电话漫游　241\nb.4　地标漫游　241\nb.5　通宵漫游　242\nb.6　公务漫游测试　243\nb.7　危险地带漫游　243\nb.8　个性化漫游　244\n附录c　有关工具和代码的博客文章　245\nc.1　使用bite从bug和冗余的工作中解脱出来　245\nc.2　发布qualitybot　247\nc.3　rpf：google的录制回放框架　249\nc.4　google测试分析系统(google test analytics)——现在开源了　251\n附录d　术语表　257",
        "pages": "258",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s27082506.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s27082506.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s27082506.jpg"
        },
        "alt": "https://book.douban.com/subject/25742200/",
        "id": "25742200",
        "publisher": "人民邮电出版社",
        "isbn10": "7115330247",
        "isbn13": "9787115330246",
        "title": "Google软件测试之道",
        "url": "https://api.douban.com/v2/book/25742200",
        "alt_title": "How Google Tests Software",
        "author_intro": "james whittaker 是google的工程总监 ，负责部分google产品的测试，包括chrome、地图、google web apps。在加盟google之前，james在microsoft工作，再之前是一名大学教授。james在全球测试领域闻名遐迩。\njason arbon 是google的一名测试工程师te ，曾参与负责google桌面、chrome和chrome os的测试。同时jason也是一系列开源测试工具和个性化实验的开发负责人。在加入google之前，他也曾在microsoft工作过。\njeff carollo 是google的一名测试开发工程师set，曾参与负责google voice、工具框、chrome、chrome os产品 的测试。jeff为许多google内部的开发团队提供咨询服务，帮助提升这些团队初期的代码质量。之后在2010年，jeff转岗为软件开发工程师（se），并领导负责google+ apis的开发。在加入google之前，jeff也曾经在microsoft工作过。",
        "summary": "每天，google都要测试和发布数百万个源文件、亿万行的代码。数以亿计的构建动作会触发几百万次的自动化测试，并在好几十万个浏览器实例上执行。面对这些看似不可能完成的任务，谷歌是如何测试的呢？\n《google软件测试之道》从内部视角告诉你这个世界上知名的互联网公司是如何应对21世纪软件测试的独特挑战的。《google软件测试之道》抓住了google做测试的本质，抓住了google测试这个时代最复杂软件的精华。《google软件测试之道》描述了测试解决方案，揭示了测试架构是如何设计、实现和运行的，介绍了软件测试工程师的角色；讲解了技术测试人员应该具有的技术技能；阐述了测试工程师在产品生命周期中的职责；讲述了测试管理及在google的测试历史或在主要产品上发挥了重要作用的工程师的访谈，这对那些试图建立类似google的测试流程或团队的人受益很大。\n最后，《google软件测试之道》还介绍了作者对于google测试如何继续演进的见解、google乃至整个业界的测试方向的一些预言，相信很多读者都会感受到其中的洞察力，甚至感到震惊。本书可以作为任何从事软件测试人员到达目标的指南。\n《google软件测试之道》适合开发人员、测试人员、测试管理人员使用，也适合大中专院校相关专业师生的学习用书，以及培训学校的教材。",
        "price": "59.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "e2bbebe039ceddd5a92e2ecbca1ce2a97a73a33c3e20631a454eaccee1bb5824",
        "file": "Google软件测试之道.epub"
      },
      {
        "title_sort": "微服务：从设计到部署",
        "timestamp": "2017-10-20T08:42:50.982773+00:00",
        "publisher": "GitBook",
        "description": "Nginx 经典微服务电子书中文翻译版本 —— http://oopsguy.com",
        "language": "zh",
        "creator": "oopsguy.com",
        "title": "微服务：从设计到部署",
        "date": "2017-10-10T13:08:15.861000+00:00",
        "contributor": "calibre (3.8.0) [https://calibre-ebook.com]",
        "identifier": {
          "mobi-asin": "3bb63576-e8e8-4c15-b055-40ec9b556c6b",
          "uuid": "e001ac9a-f533-42d3-906b-2c0d84629b23",
          "calibre": "e001ac9a-f533-42d3-906b-2c0d84629b23"
        },
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "48a9391762d3a320d7ced9d7a6d25700a566666d70fa09e68ac35073757b5968",
        "file": "esigning-and-deploying-microservices.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 2884,
          "average": "8.4",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[美] 弗雷德里克·布鲁克斯"
        ],
        "pubdate": "2002-11",
        "tags": [
          {
            "count": 2473,
            "name": "软件工程",
            "title": "软件工程"
          },
          {
            "count": 1785,
            "name": "项目管理",
            "title": "项目管理"
          },
          {
            "count": 918,
            "name": "人月神话",
            "title": "人月神话"
          },
          {
            "count": 846,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 652,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 562,
            "name": "管理",
            "title": "管理"
          },
          {
            "count": 433,
            "name": "IT",
            "title": "IT"
          },
          {
            "count": 417,
            "name": "经典",
            "title": "经典"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/view/subject/m/public/s1086045.jpg",
        "binding": "平装",
        "translator": [
          "汪颖"
        ],
        "catalog": "",
        "pages": "369",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s1086045.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s1086045.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s1086045.jpg"
        },
        "alt": "https://book.douban.com/subject/1102259/",
        "id": "1102259",
        "publisher": "清华大学出版社",
        "isbn10": "7302059322",
        "isbn13": "9787302059325",
        "title": "人月神话",
        "url": "https://api.douban.com/v2/book/1102259",
        "alt_title": "",
        "author_intro": "弗雷德里克·布鲁克斯（Frederick P. Brooks, Jr.）是北卡罗莱纳大学Kenan-Flagler商学院的计算机科学教授。他曾荣获图灵奖，美国计算机协会（ACM）称赞他“对计算机体系结构、操作系统和软件工程做出了里程碑式的贡献。”\n布鲁克斯被认为是IBM 360系统之父，他曾担任360系统的项目经理、360操作系统项目设计阶段的经理。因在这两个项目中的杰出贡献，布鲁克斯和Bob Evans、Erich Bloch在1985年获得美国国家技术奖（National Medal of Technology）。布鲁克斯早期还曾担任IBM公司Stretch和Harvest计算机的体系结构设计师。布鲁克斯创立了北卡罗莱纳大学的计算机科学系，在1964-1984年期间担任系主任。他还曾任职于美国国家科技局和国防科学技术委员会。他目前的教学和研究方向是计算机体系结构、分子模型绘图和虚拟环境设计。\nUMLChina翻译组的成员汪颖（Adams Wang）翻译了这本《人月神话》。UMLChina是中文世界访问量最大的软件工程网站。译者汪颖毕业于华中理工大学，从事软件开发以及流程改进方面的工作。",
        "summary": "作者为人们管理复杂项目提供了颇具洞察力的见解，既有很多发人深省的观点，也有大量的软件工程实践。书中的内容来自布鲁克斯在IBM公司System 360家族和OS 360中的项目管理经验。初版的20年后，布鲁克斯重新审视了他原先的观点，增加了一些新的想法和建议。新增加的章节包括：原著中一些核心观点的精华；在经过了一个时代以后，Brooks博士对原先观点新的认识；1986年的经典文章《没有银弹》；对1986年所下论断（在10年内不会出现银弹）现在的认识。",
        "price": "29.80元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "fab5f64ca8bd41ab3d7fd2450cd8d60c39d8cd7c92c403fbc61ed8b18f2e089c",
        "file": "人月神话-二十周年.epub"
      },
      {
        "title": "代码整洁之道",
        "subtitle": "英文版",
        "author": [
          "（美）马丁（Martin,R.C）"
        ],
        "summary": "从《代码整洁之道(英文版)》中可以学到：\n好代码和糟糕的代码之间的区别；\n如何编写好代码。如何将糟糕的代码转化为好代码；\n如何创建好名称、好函数、好对象和好类；\n如何格式化代码以实现其可读性的最大化；\n如何在不妨碍代码逻辑的前提下充分实现错误处理；\n如何进行单元测试和测试驱动开发。\nRobert C．Martin(Bob大叔)自1970进入软件行业。从1990年起成为国际软件咨询师。他是ObjectMentor公司的创始人和总裁。Object Mentor是由一群经验丰富的咨询师组成的公司，他们的客户遍及全世界。\n业务涉及C++、Java、C＃、Ruby、面向对象、设计模式、UML、敏捷方法论和极限编程等领域。\n尽管糟糕的代码也能运行，但如果代码不整洁，会使整个开发团队泥足深陷，写得不好的代码每年都要耗费难以计数的时间和资源。然而这种情况并非无法避免。\n著名软件专家Robert C．Martin在《代码整洁之道(英文版)》中为你呈现出了革命性的视野。Martin携同Object Menlor公司的同事，从他们有关整洁代码的最佳敏捷实践中提炼出软件技艺的价值观，以飨读者，让你成为更优秀的程序员——只要你着手研读《代码整洁之道(英文版)》。\n阅读《代码整洁之道(英文版)》需要你做些什么呢?你将阅读代码——大量代码。《代码整洁之道(英文版)》促使你思考代码中何谓正确，何谓错误。更重要的是。《代码整洁之道(英文版)》将促使你重新评估自己的专业价值观，以及对自己技艺的承诺。",
        "publisher": "人民邮电出版社",
        "isbn13": "9787115210487",
        "isbn10": "7115210489",
        "tags": [
          {
            "title": "编程",
            "name": "编程",
            "count": 30
          },
          {
            "title": "程序设计",
            "name": "程序设计",
            "count": 22
          },
          {
            "title": "软件开发",
            "name": "软件开发",
            "count": 16
          },
          {
            "title": "编码之道",
            "name": "编码之道",
            "count": 11
          },
          {
            "title": "programming",
            "name": "programming",
            "count": 10
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 9
          },
          {
            "title": "代码",
            "name": "代码",
            "count": 6
          },
          {
            "title": "英文原版",
            "name": "英文原版",
            "count": 5
          }
        ],
        "pubdate": "2009-8-1",
        "translator": [],
        "binding": "平装",
        "author_intro": null,
        "rating": {
          "average": 8.2,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 43.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "45da713f5a7dc7d57654570e1fe3d60e4d4e9a8ee8094e85cc1395cf5f5bce35",
        "file": "代码整洁之道.epub"
      },
      {
        "title": "企业it架构转型之道：阿里巴巴中台战略思想与架构实战",
        "subtitle": "阿里巴巴中台战略思想与架构实战",
        "author": [
          "钟华"
        ],
        "summary": "在当今整个中国社会都处于互联网转型的浪潮中，不管是政府职能单位、业务规模庞大的央企，还是面临最激烈竞争的零售行业都处于一个重要的转折点，这个转折对企业业务模式带来了冲击，当然也给企业的信息中心部门带来了挑战：如何构建IT系统架构更好地满足互联网时代下企业业务发展的需要。阿里巴巴的共享服务理念以及企业级互联网架构建设的思路，给这些企业带来了不少新的思路，这也是我最终决定写这本书的最主要原因。本书从阿里巴巴启动中台战略说起，详细阐述了共享服务理念给企业业务发展带来的业务价值。接着会分享阿里巴巴在建设共享服务体系时如何进行技术框架的选择，哪些重要的技术平台支撑起了共享服务体系，这也是迄今为止对阿里巴巴集团中间件体系对外最全面系统的介绍。除了技术层面之外，本书还分享了阿里巴巴内部的一些经验和实践，如组织的架构和体制如何更好地支持共享服务体系的持续发展。",
        "publisher": "机械工业出版社",
        "isbn13": "9787111564805",
        "isbn10": "7111564804",
        "tags": [
          {
            "title": "架构",
            "name": "架构",
            "count": 278
          },
          {
            "title": "互联网",
            "name": "互联网",
            "count": 191
          },
          {
            "title": "中台",
            "name": "中台",
            "count": 189
          },
          {
            "title": "IT架构",
            "name": "IT架构",
            "count": 160
          },
          {
            "title": "系统架构",
            "name": "系统架构",
            "count": 139
          },
          {
            "title": "阿里巴巴",
            "name": "阿里巴巴",
            "count": 133
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 90
          },
          {
            "title": "分布式",
            "name": "分布式",
            "count": 82
          }
        ],
        "pubdate": "2017-4-1",
        "translator": [],
        "binding": "平装",
        "author_intro": "钟华（花名：古谦）阿里巴巴中间件首席架构师，15年中间件领域行业经验。对传统企业IT建设和互联网架构都有较为深入的理解，有着扎实的理论基础和丰富的实战经验，多次作为总架构师协助大型传统企业打造业务中台项目，为企业实现“互联网+”转型提供了科学的发展方向和强有力的技术支持，项目涉及政府、制造业、金融、交通、媒体等多个领域。",
        "rating": {
          "average": 8.2,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 527.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "b515c1551b0797dcaace2a70c72df4a0258fb8c1351340ae98e1bc7b12ed58f5",
        "file": "企业IT架构转型之道：阿里巴巴中台战略思想与架构实战.epub"
      },
      {
        "title": "修改软件的艺术 - 构建易维护代码的9条最佳实践",
        "subtitle": "构建易维护代码的9条最佳实践",
        "author": [
          "[美] David Scott Bernstein"
        ],
        "summary": "本书会帮你降低构建与维护软件的成本。如果你是软件开发者，将学到一套实践方法以构建易修改的代码，因为在应用当中代码经常需要修改。对于和软件开发者合作的管理者来说，本书会向你展示为何引入这九个基本的实践方法，会使你的团队更加有效地交付软件而不至于让软件演变成遗留代码。",
        "publisher": "人民邮电出版社",
        "isbn13": "9787115467768",
        "isbn10": "7115467765",
        "tags": [
          {
            "title": "软件工程",
            "name": "软件工程",
            "count": 18
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 18
          },
          {
            "title": "编程",
            "name": "编程",
            "count": 13
          },
          {
            "title": "软件开发",
            "name": "软件开发",
            "count": 9
          },
          {
            "title": "重构",
            "name": "重构",
            "count": 8
          },
          {
            "title": "敏捷",
            "name": "敏捷",
            "count": 6
          },
          {
            "title": "遗漏代码",
            "name": "遗漏代码",
            "count": 4
          },
          {
            "title": "[技术.软件工程]",
            "name": "[技术.软件工程]",
            "count": 3
          }
        ],
        "pubdate": "2017-10",
        "translator": [
          "李满庆"
        ],
        "binding": "平装",
        "author_intro": "David Scott Bernstein\n敏捷教练，曾为IBM、微软、Yahoo等企业提供敏捷实践指导。",
        "rating": {
          "average": 7.4,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 21.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "84d4b19bde898bd9570e0a5b2337cee53c4867ad88067663bb3757b048e5f614",
        "file": "修改软件的艺术.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 201,
          "average": "8.0",
          "min": 0
        },
        "subtitle": "事多到事少,拖延变高效",
        "author": [
          "史蒂夫·诺特伯格 (Staffan Nöteberg)"
        ],
        "pubdate": "2017-10-1",
        "tags": [
          {
            "count": 161,
            "name": "时间管理",
            "title": "时间管理"
          },
          {
            "count": 119,
            "name": "自我管理",
            "title": "自我管理"
          },
          {
            "count": 99,
            "name": "效率",
            "title": "效率"
          },
          {
            "count": 54,
            "name": "管理",
            "title": "管理"
          },
          {
            "count": 45,
            "name": "方法论",
            "title": "方法论"
          },
          {
            "count": 43,
            "name": "工作",
            "title": "工作"
          },
          {
            "count": 35,
            "name": "自我成长",
            "title": "自我成长"
          },
          {
            "count": 32,
            "name": "成长",
            "title": "成长"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/view/subject/m/public/s29602754.jpg",
        "binding": "平装",
        "translator": [
          "大胖"
        ],
        "catalog": "果壳中的单核工作法　　1\n第1章　削减待办任务　　18\n一分钟：如何做到削减待办任务？　　18\n黄瓜和洋蓟在商店门口相遇　　20\n忙碌谬论　　21\n本周目的　　22\n快捷清单　　23\n集草器清单　　24\n除草　　25\n硬时间和软时间　　26\n可支配时间的稀缺　　27\n单核工作法的工具　　28\n健康的邮件摄入量　　29\n收件箱是厨房水槽还是书架　　30\n全部清空　　31\n选择性阅读　　32\n限制任务清单的容量　　33\n有效的“不”　　34\n选择退出的条件　　35\n优雅地选择退出　　36\n日历与任务清单　　37\n委托　　38\n关键的少数，有用的多数　　39\n精要主义　　40\n动态优先级三法则　　41\n削减待办任务：小结　　42\n第2章　现在专注一件事　　45\n一分钟：如何做到现在专注一件事？　　45\n黄瓜和洋蓟在马戏团相遇　　47\n工作记忆容量　　48\n多任务的误区　　49\n任务切换的代价　　50\n注意力类型　　51\n恶性反馈循环　　52\n戒绝通知　　53\n正确执行　　54\n前瞻记忆　　55\n注意力瞬脱障碍　　56\n不速之客　　57\n志愿者小时　　58\n有利工作的音乐　　59\n过渡时间　　60\n核对单　　61\n康奈尔笔记法　　62\n心不在焉　　63\n时间压力　　64\n现在专注一件事：小结　　65\n第3章　永不拖延　　 69\n一分钟：如何做到永不拖延？　　69\n黄瓜和洋蓟在游艇俱乐部相遇　　71\n时间不一致　　72\n心流和拖延　　73\n可支配时间的浪费　　74\n拖延的征兆　　75\n服务生效应　　76\n艾维•李方法　　77\n自动坚持任务　　78\n批量处理　　79\n晨间流程　　80\n手边管理法　　81\n专心模型　　82\n专注于单一目标　　83\n硬时间拖延　　84\n规划过度也是拖延　　85\n反射思维与反省思维　　86\n杂乱无章　　87\n棘手问题　　88\n先视觉化再开始　　89\n内在动力　　90\n脑力预算　　91\n永不拖延：小结　　92\n第4章　循序渐进　　96\n一分钟：如何做到循序渐进？　　96\n黄瓜和洋蓟相约在森林散步　　98\n任务分解　　99\n拉金问题　　100\n开发-测量-认知　　101\n截止期限、目标日期和交付日期　　102\n时间盒子　　103\n虚假紧急　　104\n危机式管理　　106\n施行力　　107\nSMART　　108\n幼鸟先飞　　109\n不定度锥形　　110\n帕金森定律　　111\n优先级分配方式　　112\n透支未来　　113\n循序渐进：小结　　114\n第5章　简化协作　　117\n一分钟：如何做到简化协作？　　117\n黄瓜和洋蓟在步行街广场见面　　119\n富足心态　　120\n幸运的方法　　121\n相处的责任　　122\n有效聆听　　123\n议会场合　　124\n本杰明•富兰克林效应　　125\n沟通带宽　　126\n鸡尾酒会问题　　127\n组织会议　　128\n接受邀请的条件　　129\n打电话　　130\n如实预估　　131\n一图胜千言　　132\n问题排队时间　　133\n临场失误　　134\n认知失调　　135\n简化协作：小结　　136\n第6章　给创意充电　　139\n一分钟：如何做到给创意充电？　　139\n黄瓜和洋蓟在素食餐厅相遇　　141\n特克斯勒消逝效应　　142\n基本休息-活动周期　　143\n坐以待毙怎么行　　144\n充氧的大脑　　145\n创意散步　　146\n不对路的午餐　　147\n八小时外的压力　　148\n社交激励　　149\n加班的恶性循环　　150\n停一步海阔天空　　151\n快速眼动与记忆编码　　152\n瞌睡的危害　　153\n自律　　154\n习惯的脑科学　　155\n坚持习惯　　156\n思维导图　　157\n给创意充电：小结　　158\n附录　大脑地图　　163\n大脑地图是如何绘制的　　163\n大脑皮层　　165\n前额叶皮层　　166\n丘脑和基底核　　167\n边缘系统　　168\n后记　　170",
        "ebook_url": "https://read.douban.com/ebook/41363709/",
        "pages": "188",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s29602754.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s29602754.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s29602754.jpg"
        },
        "alt": "https://book.douban.com/subject/27177909/",
        "id": "27177909",
        "publisher": "人民邮电出版社,中国工信出版集团",
        "isbn10": "7115448604",
        "isbn13": "9787115448606",
        "title": "单核工作法图解",
        "url": "https://api.douban.com/v2/book/27177909",
        "alt_title": "",
        "author_intro": "Staffan Nöteberg\n超级畅销书《番茄工作法图解》作者。拥有IT产业、特别是软件开发方面的背景。帮助许多大中型组织以敏捷、精益的步伐成长，教授数万人如何提高个人生产力。目前主要居住地是瑞典斯德哥尔摩和土耳其伊斯坦布尔。",
        "summary": "本书的主题是管理时间，战胜拖延。作者通过自身多年的经验，首创了一套简单、灵活而又强大的单核工作法，能行之有效地帮助你加强自制力、集中精力。全书分为6章，从削减待办任务、现在专注一件事、永不拖延、循序渐进、简化协作和给创意充电等方面详述这一方法，助你在日常生活中轻松完成各项任务。\n本书不仅适用于高管和上班族，还适用于学生等一般人群。所有想提高做事效率的人，都能从本书中获益。",
        "ebook_price": "19.50",
        "price": "CNY 39.00",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "83cd06d253159c6bb3074e4917c87f7943ec72b305b597e932e6faba77c1f759",
        "file": "单核工作法.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 18,
          "average": "8.6",
          "min": 0
        },
        "subtitle": "构建高效团队",
        "author": [
          "[美] Andrew Stellman",
          "[美] Jennifer Greene"
        ],
        "pubdate": "2017-3",
        "tags": [
          {
            "count": 22,
            "name": "敏捷",
            "title": "敏捷"
          },
          {
            "count": 15,
            "name": "项目管理",
            "title": "项目管理"
          },
          {
            "count": 10,
            "name": "scrum",
            "title": "scrum"
          },
          {
            "count": 7,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 6,
            "name": "敏捷开发",
            "title": "敏捷开发"
          },
          {
            "count": 4,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 3,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 2,
            "name": "软件工程",
            "title": "软件工程"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/view/subject/m/public/s29358619.jpg",
        "binding": "平装",
        "translator": [
          "段志岩",
          "郑思遥"
        ],
        "catalog": "序　　xv\n前言　　xvii\n第1章　学习敏捷　　1\n1.1　什么是敏捷　　2\n1.2　本书的读者对象　　5\n1.3　本书的目标　　6\n1.4　努力建立敏捷思维　　6\n1.5　本书结构　　9\n第2章　理解敏捷价值观　　11\n2.1　团队主管、架构师和项目经理走进了一间酒吧……　　12\n2.2　没有银弹　　14\n2.3　敏捷可以拯救乱局吗　　16\n2.3.1　引入敏捷，带来变化　　17\n2.3.2　“聊胜于无”的结果　　18\n2.4　视角割裂　　19\n2.4.1　视角割裂带来的问题　　21\n2.4.2　为什么视角割裂只能做到“聊胜于无”　　22\n2.5　敏捷宣言帮助团队认识实践的目的　　24\n2.5.1　个体和互动高于流程和工具　　25\n2.5.2　可工作的软件高于详尽的文档　　25\n2.5.3　客户协作高于合同谈判　　26\n2.5.4　响应变化高于遵循计划　　26\n2.5.5　原则高于实践　　27\n2.6　理解敏捷的“大象”　　28\n2.7　着手采用一套新方法　　32\n第3章　敏捷原则　　37\n3.1　敏捷软件开发的12 条原则　　38\n3.2　客户总是对的吗　　38\n3.3　交付项目　　40\n3.3.1　原则1：最优先要做的是尽早、持续地交付有价值的软件，让客户满意　　40\n3.3.2　原则2：欣然面对需求变化，即使是在开发后期。敏捷过程利用变化为\n客户维持竞争优势　　41\n3.3.3　原则3：频繁交付可工作的软件，从数周到数月，交付周期越短越好　　42\n3.3.4　改进电子书阅读器团队的项目交付计划　　44\n3.4　沟通和合作　　46\n3.4.1　原则4：在团队内外，面对面交谈是最有效、也是最高效的沟通方式　　48\n3.4.2　原则5：在整个项目过程中，业务人员和开发人员必须每天都在一起工作　　49\n3.4.3　原则6：以受激励的个体为核心构建项目，为他们提供环境和支持，\n相信他们可以把工作做好　　51\n3.4.4　在电子书阅读器项目中采用更好的沟通方式　　52\n3.5　项目实施——推进项目　　53\n3.5.1　原则7：可工作的软件是衡量进度的首要标准　　53\n3.5.2　原则8：敏捷过程倡导可持续开发。赞助商、开发人员和用户要能够\n共同、长期维持其步调，稳定向前　　54\n3.5.3　原则9：坚持不懈地追求技术卓越和设计优越，以此增强敏捷的能力　　55\n3.5.4　改善电子书阅读器团队的工作环境　　55\n3.6　项目和团队的持续改进　　56\n3.6.1　原则10：简单是尽最大可能减少不必要工作的艺术，是敏捷的根本　　56\n3.6.2　原则11：最好的架构、需求和设计来自自组织的团队　　57\n3.6.3　原则12：团队定期反思如何提升效率，并依此调整　　57\n3.7　敏捷项目：整合所有原则　　58\n第4章　Scrum和自组织团队　　62\n4.1　Scrum的规则　　64\n4.2　第1幕：Scrum的适用条件　　65\n4.3　Scrum团队中每个人都要对项目负责　　67\n4.3.1　Scrum主管指导团队的决策　　67\n4.3.2　产品所有者帮助团队了解软件的价值　　68\n4.3.3　每个人都对项目负责　　69\n4.3.4　Scrum有一组自己的价值观　　75\n4.4　第2幕：状态更新只是社交网络的玩法　　78\n4.5　整个团队参与每日Scrum例会　　80\n4.5.1　反馈和“可见− 检查− 调整”周期　　80\n4.5.2　最后责任时刻　　81\n4.5.3　召开有效的每日Scrum例会　　83\n4.6　第3幕：将冲刺计划写到墙上　　86\n4.7　冲刺、计划和回顾会议　　87\n4.7.1　迭代式与增量式　　87\n4.7.2　冲刺成也在于产品所有者，败也在于产品所有者　　89\n4.7.3　可见性和价值观　　89\n4.7.4　计划并执行有效的Scrum冲刺　　93\n4.8　第4幕：尽力之后　　94\n第5章　Scrum计划和集体承诺　　99\n5.1　第5幕：出乎意料　　100\n5.2　用户故事、速度和普遍接受的Scrum实践　　102\n5.2.1　提升软件价值　　102\n5.2.2　以用户故事构建用户真正会用到的功能　　103\n5.2.3　满意条件　　105\n5.2.4　故事点和速度　　106\n5.2.5　燃尽图　　108\n5.2.6　通过用户故事、故事点、任务和任务板来计划并实施冲刺　　 111\n5.2.7　广受认可的Scrum实践　　115\n5.3　第6幕：第一次胜利　　116\n5.4　回顾Scrum价值观　　116\n5.4.1　具体实践没有价值观也有效果（只是别管它叫Scrum）　　117\n5.4.2　你的公司文化与Scrum的价值观兼容吗　　119\n第6章　极限编程与拥抱变化　　128\n6.1　第1幕：开始加班　　129\n6.2　极限编程的主要实践　　130\n6.2.1　编程实践　　130\n6.2.2　集成实践　　131\n6.2.3　计划实践　　132\n6.2.4　团队实践　　133\n6.2.5　为什么开发团队抵制变化，上述实践如何提供帮助　　134\n6.3　第2幕：计划有变，但我们还是看不到希望　　137\n6.4　极限编程的价值观帮助团队改变心态　　139\n6.4.1　极限编程帮助开发人员学会与用户协作　　141\n6.4.2　开发团队的怀疑会破坏实践的效用　　142\n6.5　正确的思维从极限编程的价值观开始　　144\n6.5.1　极限编程的价值观　　144\n6.5.2　以善意铺就　　144\n6.6　第3幕：势头的变换　　147\n6.7　理解极限编程价值观，拥抱变化　　148\n6.7.1　极限编程的指导原则　　149\n6.7.2　极限编程指导原则可以加深对计划的理解　　151\n6.7.3　极限编程指导原则与实践相互促进　　152\n6.7.4　反馈循环　　154\n第7章　极限编程、简化和增量式设计　　163\n7.1　第4幕：再次加班　　164\n7.2　代码和设计　　165\n7.2.1　代码异味和反模式（如何判断你是不是聪明过头了）　　166\n7.2.2　极限编程团队主动寻找和修复代码异味　　168\n7.2.3　钩子、边界情况以及功能过多的代码　　170\n7.2.4　代码异味会增加复杂性　　175\n7.3　把编码和设计决定留到最后责任时刻　　175\n7.3.1　决然重构，偿还技术债务　　177\n7.3.2　持续集成，排查设计问题　　179\n7.3.3　避免一体式设计　　180\n7.4　增量式设计与极限编程的整体实践　　182\n7.4.1　有时间进行思考，团队才能做好工作　　184\n7.4.2　团队成员彼此信任并共同作出决定　　186\n7.4.3　极限编程的设计、计划、团队和整体实践形成了一个带动创新的系统　　186\n7.4.4　增量式设计与为了复用而设计　　188\n7.4.5　简化单元交互，系统实现增量式成长　　190\n7.4.6　优秀的设计源自简单的交互　　190\n7.5　第5幕：最终得分　　192\n第8章　精益、消除浪费和着眼全局　　200\n8.1　精益思维　　201\n8.1.1　你已经理解了很多精益价值观　　201\n8.1.2　承诺、选择意识和集合式开发　　203\n8.2　第1幕：还有一件事……　　207\n8.3　创造英雄与神奇思维　　209\n8.4　消除浪费　　210\n8.5　加深对产品的理解　　214\n8.5.1　着眼全局　　216\n8.5.2　找到问题的根本原因　　218\n8.6　尽快交付　　219\n8.6.1　使用面积图可视化工作进度　　221\n8.6.2　限制进行中的工作，控制瓶颈　　225\n8.6.3　拉动式系统帮助团队消除约束　　226\n第9章　看板方法、流程和持续改进　　233\n9.1　第2幕：紧赶慢赶的游戏　　234\n9.2　看板方法的原则　　236\n9.2.1　找到一个出发点并由此进行实验性的演进　　236\n9.2.2　用户故事进去，代码出来　　238\n9.3　用看板方法改进流程　　240\n9.3.1　将工作流程可视化　　241\n9.3.2　限制进行中的工作　　246\n9.4　测量并管理流量　　251\n9.4.1　用CFD 和进行中工作面积图测量并管理流量　　252\n9.4.2　用利特尔法则控制系统的流量　　259\n9.4.3　用进行中工作上限管理流量，自然地创造缓冲　　263\n9.4.4　让过程策略明确统一　　265\n9.5　看板方法下自然发生的行为　　266\n第10章　敏捷教练　　275\n10.1　第3幕：还有一件事（又来了？！）……　　276\n10.2　教练要理解人们为什么不想改变　　277\n10.3　教练要理解人们如何学习　　280\n10.4　教练清楚如何让一套方法起作用　　284\n10.5　进行敏捷指导时的原则　　285\n关于作者　　288\n关于封面　　288",
        "pages": "308",
        "images": {
          "small": "https://img1.doubanio.com/view/subject/s/public/s29358619.jpg",
          "large": "https://img1.doubanio.com/view/subject/l/public/s29358619.jpg",
          "medium": "https://img1.doubanio.com/view/subject/m/public/s29358619.jpg"
        },
        "alt": "https://book.douban.com/subject/26979886/",
        "id": "26979886",
        "publisher": "人民邮电出版社",
        "isbn10": "7115447551",
        "isbn13": "9787115447555",
        "title": "学习敏捷",
        "url": "https://api.douban.com/v2/book/26979886",
        "alt_title": "",
        "author_intro": "Andrew Stellman\n是O'Reilly畅销书作者、敏捷教练、项目领导人、软件工程项目经理、开发人员和系统架构师。具有20多年的软件开发项目管理经验，是公认的软件开发专家。\nJennifer Greene\n是一位优秀的软件测试人员，曾与不同的软件开发团队共事，并且构建了很多相当酷的工程。她还是一位畅销书作者，曾撰写过Head First PMP、Head First C#。其中Head First C#为她与Andrew Stellman合著。",
        "summary": "本书以敏捷软件开发为中心，系统阐述了敏捷原则和实践的先进理念和重要意义，并分别讲解了Scrum、极限编程、精益和看板四套敏捷实践的应用。作者从开发团队的日常困境入手，用讲故事的形式展开问题，由表及里，层层讲解，并在每一章最后附上参考书，便于读者进一步查找学习。本书内容生动，语言通俗易懂，集趣味性和实用性于一体，是学习敏捷开发、提升团队效率的极佳参考书。",
        "price": "79.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "3f8c50bcb6e2d803f203768ca466c84ba464be6d469f888f29e1e22b3f688122",
        "file": "学习敏捷.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 295,
          "average": "8.2",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[英] Sam Newman"
        ],
        "pubdate": "2016-5",
        "tags": [
          {
            "count": 297,
            "name": "微服务",
            "title": "微服务"
          },
          {
            "count": 230,
            "name": "架构",
            "title": "架构"
          },
          {
            "count": 149,
            "name": "软件架构",
            "title": "软件架构"
          },
          {
            "count": 84,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 71,
            "name": "软件工程",
            "title": "软件工程"
          },
          {
            "count": 56,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 55,
            "name": "技术",
            "title": "技术"
          },
          {
            "count": 53,
            "name": "互联网",
            "title": "互联网"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/mpic/s28626997.jpg",
        "binding": "平装",
        "translator": [
          "崔力强",
          "张　骏"
        ],
        "catalog": "前言　　xiv\n第1章　微服务　　1\n1.1　什么是微服务　　2\n1.1.1　很小，专注于做好一件事　　2\n1.1.2　自治性　　3\n1.2　主要好处　　3\n1.2.1　技术异构性　　3\n1.2.2　弹性　　4\n1.2.3　扩展　　5\n1.2.4　简化部署　　5\n1.2.5　与组织结构相匹配　　6\n1.2.6　可组合性　　6\n1.2.7　对可替代性的优化　　6\n1.3　面向服务的架构　　7\n1.4　其他分解技术　　7\n1.4.1　共享库　　8\n1.4.2　模块　　8\n1.5　没有银弹　　9\n1.6　小结　　10\n第2章　演化式架构师　　11\n2.1　不准确的比较　　11\n2.2　架构师的演化视角　　12\n2.3　分区　　14\n2.4　一个原则性的方法　　15\n2.4.1　战略目标　　15\n2.4.2　原则　　15\n2.4.3　实践　　16\n2.4.4　将原则和实践相结合　　16\n2.4.5　真实世界的例子　　16\n2.5　要求的标准　　17\n2.5.1　监控　　18\n2.5.2　接口　　18\n2.5.3　架构安全性　　18\n2.6　代码治理　　18\n2.6.1　范例　　19\n2.6.2　裁剪服务代码模板　　19\n2.7　技术债务　　20\n2.8　例外管理　　21\n2.9　集中治理和领导　　21\n2.10　建设团队　　22\n2.11　小结　　23\n第3章　如何建模服务　　24\n3.1　MusicCorp简介　　24\n3.2　什么样的服务是好服务　　25\n3.2.1　松耦合　　25\n3.2.2　高内聚　　25\n3.3　限界上下文　　26\n3.3.1　共享的隐藏模型　　26\n3.3.2　模块和服务　　27\n3.3.3　过早划分　　28\n3.4　业务功能　　28\n3.5　逐步划分上下文　　29\n3.6　关于业务概念的沟通　　30\n3.7　技术边界　　30\n3.8　小结　　31\n第4章　集成　　32\n4.1　寻找理想的集成技术　　32\n4.1.1　避免破坏性修改　　32\n4.1.2　保证API的技术无关性　　32\n4.1.3　使你的服务易于消费方使用　　33\n4.1.4　隐藏内部实现细节　　33\n4.2　为用户创建接口　　33\n4.3　共享数据库　　33\n4.4　同步与异步　　35\n4.5　编排与协同　　35\n4.6　远程过程调用　　38\n4.6.1　技术的耦合　　38\n4.6.2　本地调用和远程调用并不相同　　39\n4.6.3　脆弱性　　39\n4.6.4　RPC很糟糕吗　　40\n4.7　REST　　41\n4.7.1　REST和HTTP　　41\n4.7.2　超媒体作为程序状态的引擎　　42\n4.7.3　JSON、XML还是其他　　44\n4.7.4　留心过多的约定　　44\n4.7.5　基于HTTP的REST的缺点　　45\n4.8　实现基于事件的异步协作方式　　46\n4.8.1　技术选择　　46\n4.8.2　异步架构的复杂性　　47\n4.9　服务即状态机　　48\n4.10　响应式扩展　　48\n4.11　微服务世界中的DRY和代码重用的危险　　49\n4.12　按引用访问　　50\n4.13　版本管理　　51\n4.13.1　尽可能推迟　　51\n4.13.2　及早发现破坏性修改　　52\n4.13.3　使用语义化的版本管理　　53\n4.13.4　不同的接口共存　　53\n4.13.5　同时使用多个版本的服务　　54\n4.14　用户界面　　55\n4.14.1　走向数字化　　56\n4.14.2　约束　　56\n4.14.3　API组合　　57\n4.14.4　UI片段的组合　　57\n4.14.5　为前端服务的后端　　59\n4.14.6　一种混合方式　　60\n4.15　与第三方软件集成　　61\n4.15.1　缺乏控制　　61\n4.15.2　定制化　　62\n4.15.3　意大利面式的集成　　62\n4.15.4　在自己可控的平台进行定制化　　62\n4.15.5　绞杀者模式　　64\n4.16　小结　　65\n第5章　分解单块系统　　66\n5.1　关键是接缝　　66\n5.2　分解MusicCorp　　67\n5.3　分解单块系统的原因　　68\n5.3.1　改变的速度　　68\n5.3.2　团队结构　　68\n5.3.3　安全　　68\n5.3.4　技术　　68\n5.4　杂乱的依赖　　69\n5.5　数据库　　69\n5.6　找到问题的关键　　69\n5.7　例子：打破外键关系　　70\n5.8　例子：共享静态数据　　71\n5.9　例子：共享数据　　72\n5.10　例子：共享表　　73\n5.11　重构数据库　　74\n5.12　事务边界　　75\n5.12.1　再试一次　　76\n5.12.2　终止整个操作　　77\n5.12.3　分布式事务　　77\n5.12.4　应该怎么办呢　　78\n5.13　报告　　78\n5.14　报告数据库　　78\n5.15　通过服务调用来获取数据　　80\n5.16　数据导出　　81\n5.17　事件数据导出　　82\n5.18　数据导出的备份　　83\n5.19　走向实时　　84\n5.20　修改的代价　　84\n5.21　理解根本原因　　84\n5.22　小结　　85\n第6章　部署　　86\n6.1　持续集成简介　　86\n6.2　把持续集成映射到微服务　　87\n6.3　构建流水线和持续交付　　90\n6.4　平台特定的构建物　　91\n6.5　操作系统构建物　　92\n6.6　定制化镜像　　93\n6.6.1　将镜像作为构建物　　94\n6.6.2　不可变服务器　　95\n6.7　环境　　95\n6.8　服务配置　　96\n6.9　服务与主机之间的映射　　97\n6.9.1　单主机多服务　　97\n6.9.2　应用程序容器　　99\n6.9.3　每个主机一个服务　　100\n6.9.4　平台即服务　　101\n6.10　自动化　　101\n6.11　从物理机到虚拟机　　102\n6.11.1　传统的虚拟化技术　　103\n6.11.2　Vagrant　　104\n6.11.3　Linux容器　　104\n6.11.4　Docker　　106\n6.12　一个部署接口　　107\n6.13　小结　　109\n第7章　测试　　110\n7.1　测试类型　　110\n7.2　测试范围　　111\n7.2.1　单元测试　　112\n7.2.2　服务测试　　113\n7.2.3　端到端测试　　114\n7.2.4　权衡　　114\n7.2.5　比例　　115\n7.3　实现服务测试　　115\n7.3.1　mock还是打桩　　115\n7.3.2　智能的打桩服务　　116\n7.4　微妙的端到端测试　　117\n7.5　端到端测试的缺点　　118\n7.6　脆弱的测试　　118\n7.6.1　谁来写这些测试　　119\n7.6.2　测试多长时间　　119\n7.6.3　大量的堆积　　120\n7.6.4　元版本　　120\n7.7　测试场景，而不是故事　　121\n7.8　拯救消费者驱动的测试　　121\n7.8.1　Pact　　123\n7.8.2　关于沟通　　124\n7.9　还应该使用端到端测试吗　　124\n7.10　部署后再测试　　125\n7.10.1　区分部署和上线　　125\n7.10.2　金丝雀发布　　126\n7.10.3　平均修复时间胜过平均故障间隔时间　　127\n7.11　跨功能的测试　　128\n7.12　小结　　129\n第8章　监控　　131\n8.1　单一服务，单一服务器　　132\n8.2　单一服务，多个服务器　　132\n8.3　多个服务，多个服务器　　133\n8.4　日志，日志，更多的日志　　134\n8.5　多个服务的指标跟踪　　135\n8.6　服务指标　　135\n8.7　综合监控　　136\n8.8　关联标识　　137\n8.9　级联　　139\n8.10　标准化　　139\n8.11　考虑受众　　140\n8.12　未来　　140\n8.13　小结　　141\n第9章　安全　　143\n9.1　身份验证和授权　　143\n9.1.1　常见的单点登录实现　　144\n9.1.2　单点登录网关　　145\n9.1.3　细粒度的授权　　146\n9.2　服务间的身份验证和授权　　146\n9.2.1　在边界内允许一切　　146\n9.2.2　HTTP(S) 基本身份验证　　147\n9.2.3　使用SAML或OpenID Connect　　148\n9.2.4　客户端证书　　148\n9.2.5　HTTP之上的HMAC　　149\n9.2.6　API密钥　　149\n9.2.7　代理问题　　150\n9.3　静态数据的安全　　152\n9.3.1　使用众所周知的加密算法　　152\n9.3.2　一切皆与密钥相关　　153\n9.3.3　选择你的目标　　153\n9.3.4　按需解密　　153\n9.3.5　加密备份　　153\n9.4　深度防御　　154\n9.4.1　防火墙　　154\n9.4.2　日志　　154\n9.4.3　入侵检测（和预防）系统　　154\n9.4.4　网络隔离　　155\n9.4.5　操作系统　　155\n9.5　一个示例　　156\n9.6　保持节俭　　158\n9.7　人的因素　　158\n9.8　黄金法则　　158\n9.9　内建安全　　159\n9.10　外部验证　　159\n9.11　小结　　159\n第10章　康威定律和系统设计　　161\n10.1　证据　　161\n10.1.1　松耦合组织和紧耦合组织　　162\n10.1.2　Windows Vista　　162\n10.2　Netflix和Amazon　　162\n10.3　我们可以做什么　　163\n10.4　适应沟通途径　　163\n10.5　服务所有权　　164\n10.6　共享服务的原因　　164\n10.6.1　难以分割　　164\n10.6.2　特性团队　　164\n10.6.3　交付瓶颈　　165\n10.7　内部开源　　166\n10.7.1　守护者的角色　　166\n10.7.2　成熟　　166\n10.7.3　工具　　167\n10.8　限界上下文和团队结构　　167\n10.9　孤儿服务　　167\n10.10　案例研究：RealEstate.com.au　　168\n10.11　反向的康威定律　　169\n10.12　人　　170\n10.13　小结　　170\n第11章　规模化微服务　　171\n11.1　故障无处不在　　171\n11.2　多少是太多　　172\n11.3　功能降级　　173\n11.4　架构性安全措施　　174\n11.5　反脆弱的组织　　175\n11.5.1　超时　　176\n11.5.2　断路器　　176\n11.5.3　舱壁　　178\n11.5.4　隔离　　179\n11.6　幂等　　179\n11.7　扩展　　180\n11.7.1　更强大的主机　　181\n11.7.2　拆分负载　　181\n11.7.3　分散风险　　181\n11.7.4　负载均衡　　182\n11.7.5　基于worker的系统　　184\n11.7.6　重新设计　　184\n11.8　扩展数据库　　185\n11.8.1　服务的可用性和数据的持久性　　185\n11.8.2　扩展读取　　185\n11.8.3　扩展写操作　　186\n11.8.4　共享数据库基础设施　　187\n11.8.5　CQRS　　187\n11.9　缓存　　188\n11.9.1　客户端、 代理和服务器端缓存　　188\n11.9.2　HTTP缓存　　189\n11.9.3　为写使用缓存　　190\n11.9.4　为弹性使用缓存　　190\n11.9.5　隐藏源服务　　191\n11.9.6　保持简单　　191\n11.9.7　缓存中毒：一个警示　　192\n11.10　自动伸缩　　192\n11.11　CAP定理　　193\n11.11.1　牺牲一致性　　194\n11.11.2　牺牲可用性　　195\n11.11.3　牺牲分区容忍性　　195\n11.11.4　AP还是CP　　196\n11.11.5　这不是全部或全不　　196\n11.11.6　真实世界　　197\n11.12　服务发现　　197\n11.13　动态服务注册　　199\n11.13.1　Zookeeper　　199\n11.13.2　Consul　　200\n11.13.4　构造你自己的系统　　201\n11.13.5　别忘了人　　201\n11.14　文档服务　　201\n11.14.1　Swagger　　202\n11.14.2　HAL 和HAL浏览器　　202\n11.15　自描述系统　　203\n11.16　小结　　203\n第12章　总结　　204\n12.1　微服务的原则　　204\n12.1.1　围绕业务概念建模　　205\n12.1.2　接受自动化文化　　205\n12.1.3　隐藏内部实现细节　　205\n12.1.4　让一切都去中心化　　206\n12.1.5　可独立部署　　206\n12.1.6　隔离失败　　206\n12.1.7　高度可观察　　207\n12.2　什么时候你不应该使用微服务　　207\n12.3　临别赠言　　208\n关于作者　　209\n关于封面　　209",
        "pages": "228",
        "images": {
          "small": "https://img1.doubanio.com/spic/s28626997.jpg",
          "large": "https://img1.doubanio.com/lpic/s28626997.jpg",
          "medium": "https://img1.doubanio.com/mpic/s28626997.jpg"
        },
        "alt": "https://book.douban.com/subject/26772677/",
        "id": "26772677",
        "publisher": "人民邮电出版社",
        "isbn10": "7115420262",
        "isbn13": "9787115420268",
        "title": "微服务设计",
        "url": "https://api.douban.com/v2/book/26772677",
        "alt_title": "",
        "author_intro": "作者简介：\nSam Newman\n是ThoughtWorks公司的技术专家、ThoughtWorks内部系统架构师，同时还为全球的客户提供咨询服务。他在开发和IT运维方面与全球多个领域的公司有过合作。\n译者简介：\n崔力强\n阿里巴巴技术专家，目前专注于持续交付相关的产品开发。曾在ThoughtWorks任职多年，从事软件定制开发、敏捷软件开发的相关咨询等工作，帮助过数个团队和项目进行精益需求管理、软件设计、自动化测试和持续集成等实践。微信号：blade_1986\n张骏\n2010年加入ThoughtWorks公司。作为开发人员、项目经理、资深敏捷教练和资深咨询师，在金融、电信和能源服务行业的大型复杂业务系统的设计、开发、管理、咨询等方面有丰富的经验。曾为国内外诸多客户提供软件设计、开发以及咨询服务。拥有10年工作经验，在Scrum、看板、规模化敏捷等方法论，以及精益需求管理、自动化测试、持续集成、领域驱动设计、微服务等具体实践方面都有丰富的积累。微信号：zhangjun695339",
        "summary": "本书全面介绍了微服务的建模、集成、测试、部署和监控，通过一个虚构的公司讲解了如何建立微服务架构。主要内容包括认识微服务在保证系统设计与组织目标统一上的重要性，学会把服务集成到已有系统中，采用递增手段拆分单块大型应用，通过持续集成部署微服务，等等。",
        "price": "69.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "cc26af5862efa017cb665f39b63ca820162043174077c1e10ff413f6849ff4e7",
        "file": "微服务设计-SamNewman.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 309,
          "average": "8.6",
          "min": 0
        },
        "subtitle": "发布可靠软件的系统方法",
        "author": [
          "Jez Humble",
          "David Farley"
        ],
        "pubdate": "2011-10",
        "tags": [
          {
            "count": 452,
            "name": "软件工程",
            "title": "软件工程"
          },
          {
            "count": 396,
            "name": "持续交付",
            "title": "持续交付"
          },
          {
            "count": 284,
            "name": "敏捷开发",
            "title": "敏捷开发"
          },
          {
            "count": 238,
            "name": "项目管理",
            "title": "项目管理"
          },
          {
            "count": 126,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 68,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 55,
            "name": "IT",
            "title": "IT"
          },
          {
            "count": 53,
            "name": "agile",
            "title": "agile"
          }
        ],
        "origin_title": "Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation",
        "image": "https://img3.doubanio.com/view/subject/m/public/s27996261.jpg",
        "binding": "平装",
        "translator": [
          "乔梁"
        ],
        "catalog": "第一部分  基础篇\n第1 章  软件交付的问题　　 2\n1.1  引言　　2\n1.2  一些常见的发布反模式　　 3\n1.2.1  反模式：手工部署软件　　 4\n1.2.2  反模式：开发完成之后才向类生产环境部署　　 5\n1.2.3  反模式：生产环境的手工配置管理　　7\n1.2.4  我们能做得更好吗　　 8\n1.3  如何实现目标　　 9\n1.3.1  每次修改都应该触发反馈流程　　10\n1.3.2  必须尽快接收反馈　　 11\n1.3.3  交付团队必须接收反馈并作出反应　　 12\n1.3.4  这个流程可以推广吗　　12\n1.4  收效　　12\n1.4.1  授权团队　　13\n1.4.2  减少错误　　13\n1.4.3  缓解压力　　15\n1.4.4  部署的灵活性　　16\n1.4.5  多加练习，使其完美　　17\n1.5  候选发布版本　　17\n1.6  软件交付的原则　　19\n1.6.1  为软件的发布创建一个可重复且可靠的过程　　19\n1.6.2  将几乎所有事情自动化　　19\n1.6.3  把所有的东西都纳入版本控制　　20\n1.6.4  提前并频繁地做让你感到痛苦的事　　20\n1.6.5  内建质量　　21\n1.6.6  “DONE”意味着“已发布” 　　 21\n1.6.7  交付过程是每个成员的责任　　 22\n1.6.8  持续改进　　22\n1.7  小结　　 23\n第2 章  配置管理　　24\n2.1  引言　　24\n2.2  使用版本控制　　25\n2.2.1  对所有内容进行版本控制　　26\n2.2.2  频繁提交代码到主干　　28\n2.2.3  使用意义明显的提交注释　　29\n2.3  依赖管理　　30\n2.3.1  外部库文件管理　　30\n2.3.2  组件管理　　30\n2.4  软件配置管理　　31\n2.4.1  配置与灵活性　　31\n2.4.2  配置的分类　　 33\n2.4.3  应用程序的配置管理　　33\n2.4.4  跨应用的配置管理　　36\n2.4.5  管理配置信息的原则　　 37\n2.5  环境管理　　 38\n2.5.1  环境管理的工具　　41\n2.5.2  变更过程管理　　41\n2.6  小结　　 42\n第3 章  持续集成　　43\n3.1  引言　　43\n3.2  实现持续集成　　44\n3.2.1  准备工作　　44\n3.2.2  一个基本的持续集成系统　　45\n3.3  持续集成的前提条件　　46\n3.3.1  频繁提交　　46\n3.3.2  创建全面的自动化测试套件　　47\n3.3.3  保持较短的构建和测试过程　　47\n3.3.4  管理开发工作区　　 49\n3.4  使用持续集成软件　　49\n3.4.1  基本操作　　 49\n3.4.2  铃声和口哨　　 50\n3.5  必不可少的实践　　 52\n3.5.1  构建失败之后不要提交新代码　　52\n3.5.2  提交前在本地运行所有的提交测试，或者让持续集成服务器完成此事　　53\n3.5.3  等提交测试通过后再继续工作　　54\n3.5.4  回家之前，构建必须处于成功状态　　 54\n3.5.5  时刻准备着回滚到前一个版本　　55\n3.5.6  在回滚之前要规定一个修复时间　　56\n3.5.7  不要将失败的测试注释掉　　 56\n3.5.8  为自己导致的问题负责　　56\n3.5.9  测试驱动的开发　　57\n3.6  推荐的实践　　 57\n3.6.1  极限编程开发实践　　57\n3.6.2  若违背架构原则，就让构建失败　　 58\n3.6.3  若测试运行变慢，就让构建失败　　 58\n3.6.4  若有编译警告或代码风格问题，就让测试失败　　59\n3.7  分布式团队　　60\n3.7.1  对流程的影响　　60\n3.7.2  集中式持续集成　　 61\n3.7.3  技术问题　　61\n3.7.4  替代方法　　 62\n3.8  分布式版本控制系统　　63\n3.9  小结　　66\n第4 章  测试策略的实现　　 67\n4.1  引言　　 67\n4.2  测试的分类　　 68\n4.2.1  业务导向且支持开发过程的测试　　69\n4.2.2  技术导向且支持开发过程的测试　　72\n4.2.3  业务导向且评价项目的测试　　72\n4.2.4  技术导向且评价项目的测试　　73\n4.2.5  测试替身　　74\n4.3  现实中的情况与应对策略　　75\n4.3.1  新项目　　75\n4.3.2  项目进行中　　 76\n4.3.3  遗留系统　　 77\n4.3.4  集成测试　　78\n4.4  流程　　80\n4.5  小结　　82\n第二部分  部署流水线\n第5 章  部署流水线解析　　84\n5.1  引言　　 84\n5.2  什么是部署流水线　　85\n5.3  部署流水线的相关实践　　91\n5.3.1  只生成一次二进制包　　 91\n5.3.2  对不同环境采用同一部署方式　　93\n5.3.3  对部署进行冒烟测试　　 94\n5.3.4  向生产环境的副本中部署　　94\n5.3.5  每次变更都要立即在流水线中传递　　 95\n5.3.6  只要有环节失败，就停止整个流水线　　96\n5.4  提交阶段　　96\n5.5  自动化验收测试之门　　99\n5.6  后续的测试阶段　　102\n5.6.1  手工测试　　 103\n5.6.2  非功能测试　　103\n5.7  发布准备　　104\n5.7.1  自动部署与发布　　 104\n5.7.2  变更的撤销　　106\n5.7.3  在成功的基础上构建　　 107\n5.8  实现一个部署流水线　　 107\n5.8.1  对价值流进行建模并创建简单的可工作框架　　 107\n5.8.2  构建和部署过程的自动化　　108\n5.8.3  自动化单元测试和代码分析　　109\n5.8.4  自动化验收测试　　 109\n5.8.5  部署流水线的演进　　 110\n5.9  度量　　111\n5.10  小结　　113\n第6 章  构建与部署的脚本化　　 115\n6.1  引言　　115\n6.2  构建工具概览　　116\n6.2.1  Make　　118\n6.2.2  Ant　　118\n6.2.3  NAnt 与 MSBuild　　119\n6.2.4  Maven　　120\n6.2.5  Rake 　　121\n6.2.6  Buildr 　　121\n6.2.7  Psake 　　121\n6.3  构建部署脚本化的原则与实践　　 122\n6.3.1  为部署流水线的每个阶段创建脚本　　122\n6.3.2  使用恰当的技术部署应用程序　　 122\n6.3.3  使用同样的脚本向所有环境部署　　123\n6.3.4  使用操作系统自带的包管理工具　　124\n6.3.5  确保部署流程是幂等的（Idempotent）　　125\n6.3.6  部署系统的增量式演进　　126\n6.4  面向JVM 的应用程序的项目结构　　126\n6.5  部署脚本化　　129\n6.5.1  多层的部署和测试　　130\n6.5.2  测试环境配置　　131\n6.6  小贴士　　132\n6.6.1  总是使用相对路径　　132\n6.6.2  消除手工步骤　　132\n6.6.3  从二进制包到版本控制库的内建可追溯性　　133\n6.6.4  不要把二进制包作为构建的一部分放到版本控制库中　　133\n6.6.5  “test”不应该让构建失败　　134\n6.6.6  用集成冒烟测试来限制应用程序　　134\n6.6.7  .NET 小贴士　　135\n6.7  小结　　135\n第7 章  提交阶段　　137\n7.1  引言　　137\n7.2  提交阶段的原则和实践　　138\n7.2.1  提供快速有用的反馈　　138\n7.2.2  何时令提交阶段失败　　139\n7.2.3  精心对待提交阶段　　140\n7.2.4  让开发人员也拥有所有权　　140\n7.2.5  在超大项目团队中指定一个构建负责人　　141\n7.3  提交阶段的结果　　141\n7.4  提交测试套件的原则与实践　　144\n7.4.1  避免用户界面　　145\n7.4.2  使用依赖注入　　145\n7.4.3  避免使用数据库　　145\n7.4.4  在单元测试中避免异步　　146\n7.4.5  使用测试替身　　 146\n7.4.6  最少化测试中的状态　　 149\n7.4.7  时间的伪装　　150\n7.4.8  蛮力　　150\n7.5  小结　　 151\n第8 章  自动化验收测试　　152\n8.1  引言　　 152\n8.2  为什么验收测试是至关重要的　　 153\n8.2.1  如何创建可维护的验收测试套件　　155\n8.2.2  GUI 上的测试　　 156\n8.3  创建验收测试　　157\n8.3.1  分析人员和测试人员的角色　　157\n8.3.2  迭代开发项目中的分析工作　　157\n8.3.3  将验收条件变成可执行的规格说明书　　 158\n8.4  应用程序驱动层　　161\n8.4.1  如何表述验收条件　　 163\n8.4.2  窗口驱动器模式：让测试与GUI 解耦　　164\n8.5  实现验收测试　　166\n8.5.1  验收测试中的状态　　 166\n8.5.2  过程边界、封装和测试　　 168\n8.5.3  管理异步与超时问题　　 169\n8.5.4  使用测试替身对象　　 171\n8.6  验收测试阶段　　174\n8.6.1  确保验收测试一直处于通过状态　　175\n8.6.2  部署测试　　177\n8.7  验收测试的性能　　178\n8.7.1  重构通用任务　　 178\n8.7.2  共享昂贵资源　　 179\n8.7.3  并行测试　　180\n8.7.4  使用计算网格　　 180\n8.8  小结　　181\n第9 章  非功能需求的测试　　183\n9.1  引言　　183\n9.2  非功能需求的管理　　184\n9.3  如何为容量编程　　186\n9.4  容量度量　　188\n9.5  容量测试环境　　191\n9.6  自动化容量测试　　194\n9.6.1  通过UI 的容量测试　　195\n9.6.2  基于服务或公共API 来录制交互操作　　196\n9.6.3  使用录制的交互模板　　 197\n9.6.4  使用容量测试桩开发测试　　198\n9.7  将容量测试加入到部署流水线中　　199\n9.8  容量测试系统的附加价值　　 201\n9.9  小结　　 202\n第10 章  应用程序的部署与发布　　 203\n10.1  引言　　203\n10.2  创建发布策略　　 204\n10.2.1  发布计划　　205\n10.2.2  发布产品　　205\n10.3  应用程序的部署和晋级　　 206\n10.3.1  首次部署　　206\n10.3.2  对发布过程进行建模并让构建晋级　　 207\n10.3.3  配置的晋级　　209\n10.3.4  联合环境　　209\n10.3.5  部署到试运行环境　　 210\n10.4  部署回滚和零停机发布　　211\n10.4.1  通过重新部署原有的正常版本来进行回滚　　211\n10.4.2  零停机发布　　212\n10.4.3  蓝绿部署　　 212\n10.4.4  金丝雀发布　　213\n10.5  紧急修复　　216\n10.6  持续部署　　216\n10.7  小贴士和窍门　　 219\n10.7.1  真正执行部署操作的人应该参与部署过程的创建　　219\n10.7.2  记录部署活动　　 220\n10.7.3  不要删除旧文件，而是移动到别的位置　　 220\n10.7.4  部署是整个团队的责任　　 220\n10.7.5  服务器应用程序不应该有GUI 　　220\n10.7.6  为新部署留预热期　　 221\n10.7.7  快速失败　　 221\n10.7.8  不要直接对生产环境进行修改　　222\n10.8  小结　　222\n第三部分  交付生态圈\n第11 章  基础设施和环境管理　　 224\n11.1  引言　　 224\n11.2  理解运维团队的需要　　 225\n11.2.1  文档与审计　　 226\n11.2.2  异常事件的告警　　 227\n11.2.3  保障IT 服务持续性的计划　　227\n11.2.4  使用运维团队熟悉的技术　　 228\n11.3  基础设施的建模和管理　　229\n11.3.1  基础设施的访问控制　　 230\n11.3.2  对基础设施进行修改　　 231\n11.4  服务器的准备及其配置的管理　　 232\n11.4.1  服务器的准备　　 233\n11.4.2  服务器的持续管理　　 234\n11.5  中间件的配置管理　　239\n11.5.1  管理配置项　　 239\n11.5.2  产品研究　　 241\n11.5.3  考查中间件是如何处理状态的　　 242\n11.5.4  查找用于配置的API 　　 242\n11.5.5  使用更好的技术　　 243\n11.6  基础设施服务的管理　　243\n11.7  虚拟化　　245\n11.7.1  虚拟环境的管理　　 247\n11.7.2  虚拟环境和部署流水线　　249\n11.7.3  用虚拟环境做高度的并行测试　　251\n11.8  云计算　　252\n11.8.1  云中基础设施　　253\n11.8.2  云中平台　　254\n11.8.3  没有普适存在　　255\n11.8.4  对云计算的批评　　256\n11.9  基础设施和应用程序的监控　　256\n11.9.1  收集数据　　257\n11.9.2  记录日志　　259\n11.9.3  建立信息展示板　　259\n11.9.4  行为驱动的监控　　261\n11.10  小结　　261\n第12 章  数据管理　　263\n12.1  引言　　263\n12.2  数据库脚本化　　264\n12.3  增量式修改　　265\n12.3.1  对数据库进行版本控制　　265\n12.3.2  联合环境中的变更管理　　267\n12.4  数据库回滚和无停机发布　　268\n12.4.1  保留数据的回滚　　268\n12.4.2  将应用程序部署与数据库迁移解耦　　269\n12.5  测试数据的管理　　270\n12.5.1  为单元测试进行数据库模拟　　271\n12.5.2  管理测试与数据之间的耦合　　272\n12.5.3  测试独立性　　272\n12.5.4  建立和销毁　　273\n12.5.5  连贯的测试场景　　273\n12.6  数据管理和部署流水线　　274\n12.6.1  提交阶段的测试数据　　274\n12.6.2  验收测试中的数据　　275\n12.6.3  容量测试的数据　　276\n12.6.4  其他测试阶段的数据　　277\n12.7  小结　　278\n第13 章  组件和依赖管理　　280\n13.1  引言　　280\n13.2  保持应用程序可发布　　281\n13.2.1  将新功能隐蔽起来，直到它完成为止　　282\n13.2.2  所有修改都是增量式的　　 283\n13.2.3  通过抽象来模拟分支　　 284\n13.3  依赖　　285\n13.3.1  依赖地狱　　 286\n13.3.2  库管理　　 287\n13.4  组件　　289\n13.4.1  如何将代码库分成多个组件　　289\n13.4.2  将组件流水线化　　 292\n13.4.3  集成流水线　　 293\n13.5  管理依赖关系图　　295\n13.5.1  构建依赖图　　 295\n13.5.2  为依赖图建立流水线　　 297\n13.5.3  什么时候要触发构建　　 299\n13.5.4  谨慎乐观主义　　 300\n13.5.5  循环依赖　　302\n13.6  管理二进制包　　303\n13.6.1  制品库是如何运作的　　 303\n13.6.2  部署流水线如何与制品库相结合　　 304\n13.7  用Maven 管理依赖　　304\n13.8  小结　　 308\n第14 章  版本控制进阶　　 309\n14.1  引言　　309\n14.2  版本控制的历史　　310\n14.2.1  CVS 　　310\n14.2.2  SVN 　　311\n14.2.3  商业版本控制系统　　 312\n14.2.4  放弃悲观锁　　 313\n14.3  分支与合并　　 314\n14.3.1  合并　　 316\n14.3.2  分支、流和持续集成　　 317\n14.4  DVCS 　　319\n14.4.1  什么是DVCS 　　 319\n14.4.2  DVCS 简史　　 321\n14.4.3  企业环境中的DVCS　　 321\n14.4.4  使用DVCS　　 322\n14.5  基于流的版本控制系统　　 324\n14.5.1  什么是基于流的版本控制系统　　324\n14.5.2  使用流的开发模型　　 326\n14.5.3  静态视图和动态视图　　 327\n14.5.4  使用基于流的版本控制系统做持续集成　　 328\n14.6  主干开发　　329\n14.7  按发布创建分支　　332\n14.8  按功能特性分支　　333\n14.9  按团队分支　　335\n14.10  小结　　338\n第15 章  持续交付管理　　340\n15.1  引言　　 340\n15.2  配置与发布管理成熟度模型　　341\n15.3  项目生命周期　　 343\n15.3.1  识别阶段　　344\n15.3.2  启动阶段　　345\n15.3.3  初始阶段　　346\n15.3.4  开发与发布　　347\n15.3.5  运营阶段　　 349\n15.4  风险管理流程　　 350\n15.4.1  风险管理基础篇　　 350\n15.4.2  风险管理时间轴　　 351\n15.4.3  如何做风险管理的练习　　352\n15.5  常见的交付问题、症状和原因　　353\n15.5.1  不频繁的或充满缺陷的部署　　353\n15.5.2  较差的应用程序质量　　 354\n15.5.3  缺乏管理的持续集成工作流程　　355\n15.5.4  较差的配置管理　　 355\n15.6  符合度与审计　　356\n15.6.1  文档自动化　　356\n15.6.2  加强可跟踪性　　 357\n15.6.3  在筒仓中工作　　 358\n15.6.4  变更管理　　358\n15.7  小结　　360\n参考书目　　361",
        "pages": "362",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s27996261.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s27996261.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s27996261.jpg"
        },
        "alt": "https://book.douban.com/subject/6862062/",
        "id": "6862062",
        "publisher": "人民邮电出版社",
        "isbn10": "7115264597",
        "isbn13": "9787115264596",
        "title": "持续交付",
        "url": "https://api.douban.com/v2/book/6862062",
        "alt_title": "Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation",
        "author_intro": "Jez Humble ToughtWorks公司首席咨询顾问，致力于帮助企业快速、可靠地交付高质量软件，经常在各种敏捷技术大会上发表演讲，拥有牛津大学物理学学士学位和 伦敦大学民族音乐学的 硕士学位。2000年至今，他曾在各行业和不同技术领域担任系统管理员、开发人员、培训人员、咨询师和经理人员。\nDavid Farley 正在帮助构建伦敦多资产交易所（LMAE）。他具有20年的大型分布式系统开发经验，是采用敏捷开发技术的先行者，曾作为技术负责人参加了ThoughtWorks公司许多极具挑战性的软件项目。",
        "summary": "Jez Humble编著的《持续交付(发布可靠软件的系统方法)》讲述如何实现更快、更可靠、低成本的自动化软件交付，描述了如何通过增加反馈，并改进开发人员、测试人员、运维人员和项目经理之间的协作来达到这个目标。《持续交付(发布可靠软件的系统方法)》由三部分组成。第一部分阐述了持续交付背后的一些原则，以及支持这些原则的实践。第二部分是本书的核心，全面讲述了部署流水线。第三部分围绕部署流水线的投入产出讨论了更多细节，包括增量开发技术、高级版本控制模式，以及基础设施、环境和数据的管理和组织治理。    《持续交付(发布可靠软件的系统方法)》适合所有开发人员、测试人员、运维人员和项目经理学习参考。",
        "series": {
          "id": "660",
          "title": "图灵程序设计丛书"
        },
        "price": "89.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "b4cf09ce3beec371ef95cfb60ba7ae29cc6e40aa80fc1738c88ce5eb9efa002e",
        "file": "持续交付-发布可靠软件的系统方法(图灵文字版).epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 263,
          "average": "8.6",
          "min": 0
        },
        "subtitle": "发布可靠软件的系统方法",
        "author": [
          "Jez Humble",
          "David Farley"
        ],
        "pubdate": "2011-10",
        "tags": [
          {
            "count": 407,
            "name": "软件工程",
            "title": "软件工程"
          },
          {
            "count": 349,
            "name": "持续交付",
            "title": "持续交付"
          },
          {
            "count": 243,
            "name": "敏捷开发",
            "title": "敏捷开发"
          },
          {
            "count": 202,
            "name": "项目管理",
            "title": "项目管理"
          },
          {
            "count": 114,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 60,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 50,
            "name": "IT",
            "title": "IT"
          },
          {
            "count": 45,
            "name": "agile",
            "title": "agile"
          }
        ],
        "origin_title": "Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation",
        "image": "https://img3.doubanio.com/mpic/s27996261.jpg",
        "binding": "平装",
        "translator": [
          "乔梁"
        ],
        "catalog": "第一部分  基础篇\n第1 章  软件交付的问题　　 2\n1.1  引言　　2\n1.2  一些常见的发布反模式　　 3\n1.2.1  反模式：手工部署软件　　 4\n1.2.2  反模式：开发完成之后才向类生产环境部署　　 5\n1.2.3  反模式：生产环境的手工配置管理　　7\n1.2.4  我们能做得更好吗　　 8\n1.3  如何实现目标　　 9\n1.3.1  每次修改都应该触发反馈流程　　10\n1.3.2  必须尽快接收反馈　　 11\n1.3.3  交付团队必须接收反馈并作出反应　　 12\n1.3.4  这个流程可以推广吗　　12\n1.4  收效　　12\n1.4.1  授权团队　　13\n1.4.2  减少错误　　13\n1.4.3  缓解压力　　15\n1.4.4  部署的灵活性　　16\n1.4.5  多加练习，使其完美　　17\n1.5  候选发布版本　　17\n1.6  软件交付的原则　　19\n1.6.1  为软件的发布创建一个可重复且可靠的过程　　19\n1.6.2  将几乎所有事情自动化　　19\n1.6.3  把所有的东西都纳入版本控制　　20\n1.6.4  提前并频繁地做让你感到痛苦的事　　20\n1.6.5  内建质量　　21\n1.6.6  “DONE”意味着“已发布” 　　 21\n1.6.7  交付过程是每个成员的责任　　 22\n1.6.8  持续改进　　22\n1.7  小结　　 23\n第2 章  配置管理　　24\n2.1  引言　　24\n2.2  使用版本控制　　25\n2.2.1  对所有内容进行版本控制　　26\n2.2.2  频繁提交代码到主干　　28\n2.2.3  使用意义明显的提交注释　　29\n2.3  依赖管理　　30\n2.3.1  外部库文件管理　　30\n2.3.2  组件管理　　30\n2.4  软件配置管理　　31\n2.4.1  配置与灵活性　　31\n2.4.2  配置的分类　　 33\n2.4.3  应用程序的配置管理　　33\n2.4.4  跨应用的配置管理　　36\n2.4.5  管理配置信息的原则　　 37\n2.5  环境管理　　 38\n2.5.1  环境管理的工具　　41\n2.5.2  变更过程管理　　41\n2.6  小结　　 42\n第3 章  持续集成　　43\n3.1  引言　　43\n3.2  实现持续集成　　44\n3.2.1  准备工作　　44\n3.2.2  一个基本的持续集成系统　　45\n3.3  持续集成的前提条件　　46\n3.3.1  频繁提交　　46\n3.3.2  创建全面的自动化测试套件　　47\n3.3.3  保持较短的构建和测试过程　　47\n3.3.4  管理开发工作区　　 49\n3.4  使用持续集成软件　　49\n3.4.1  基本操作　　 49\n3.4.2  铃声和口哨　　 50\n3.5  必不可少的实践　　 52\n3.5.1  构建失败之后不要提交新代码　　52\n3.5.2  提交前在本地运行所有的提交测试，或者让持续集成服务器完成此事　　53\n3.5.3  等提交测试通过后再继续工作　　54\n3.5.4  回家之前，构建必须处于成功状态　　 54\n3.5.5  时刻准备着回滚到前一个版本　　55\n3.5.6  在回滚之前要规定一个修复时间　　56\n3.5.7  不要将失败的测试注释掉　　 56\n3.5.8  为自己导致的问题负责　　56\n3.5.9  测试驱动的开发　　57\n3.6  推荐的实践　　 57\n3.6.1  极限编程开发实践　　57\n3.6.2  若违背架构原则，就让构建失败　　 58\n3.6.3  若测试运行变慢，就让构建失败　　 58\n3.6.4  若有编译警告或代码风格问题，就让测试失败　　59\n3.7  分布式团队　　60\n3.7.1  对流程的影响　　60\n3.7.2  集中式持续集成　　 61\n3.7.3  技术问题　　61\n3.7.4  替代方法　　 62\n3.8  分布式版本控制系统　　63\n3.9  小结　　66\n第4 章  测试策略的实现　　 67\n4.1  引言　　 67\n4.2  测试的分类　　 68\n4.2.1  业务导向且支持开发过程的测试　　69\n4.2.2  技术导向且支持开发过程的测试　　72\n4.2.3  业务导向且评价项目的测试　　72\n4.2.4  技术导向且评价项目的测试　　73\n4.2.5  测试替身　　74\n4.3  现实中的情况与应对策略　　75\n4.3.1  新项目　　75\n4.3.2  项目进行中　　 76\n4.3.3  遗留系统　　 77\n4.3.4  集成测试　　78\n4.4  流程　　80\n4.5  小结　　82\n第二部分  部署流水线\n第5 章  部署流水线解析　　84\n5.1  引言　　 84\n5.2  什么是部署流水线　　85\n5.3  部署流水线的相关实践　　91\n5.3.1  只生成一次二进制包　　 91\n5.3.2  对不同环境采用同一部署方式　　93\n5.3.3  对部署进行冒烟测试　　 94\n5.3.4  向生产环境的副本中部署　　94\n5.3.5  每次变更都要立即在流水线中传递　　 95\n5.3.6  只要有环节失败，就停止整个流水线　　96\n5.4  提交阶段　　96\n5.5  自动化验收测试之门　　99\n5.6  后续的测试阶段　　102\n5.6.1  手工测试　　 103\n5.6.2  非功能测试　　103\n5.7  发布准备　　104\n5.7.1  自动部署与发布　　 104\n5.7.2  变更的撤销　　106\n5.7.3  在成功的基础上构建　　 107\n5.8  实现一个部署流水线　　 107\n5.8.1  对价值流进行建模并创建简单的可工作框架　　 107\n5.8.2  构建和部署过程的自动化　　108\n5.8.3  自动化单元测试和代码分析　　109\n5.8.4  自动化验收测试　　 109\n5.8.5  部署流水线的演进　　 110\n5.9  度量　　111\n5.10  小结　　113\n第6 章  构建与部署的脚本化　　 115\n6.1  引言　　115\n6.2  构建工具概览　　116\n6.2.1  Make　　118\n6.2.2  Ant　　118\n6.2.3  NAnt 与 MSBuild　　119\n6.2.4  Maven　　120\n6.2.5  Rake 　　121\n6.2.6  Buildr 　　121\n6.2.7  Psake 　　121\n6.3  构建部署脚本化的原则与实践　　 122\n6.3.1  为部署流水线的每个阶段创建脚本　　122\n6.3.2  使用恰当的技术部署应用程序　　 122\n6.3.3  使用同样的脚本向所有环境部署　　123\n6.3.4  使用操作系统自带的包管理工具　　124\n6.3.5  确保部署流程是幂等的（Idempotent）　　125\n6.3.6  部署系统的增量式演进　　126\n6.4  面向JVM 的应用程序的项目结构　　126\n6.5  部署脚本化　　129\n6.5.1  多层的部署和测试　　130\n6.5.2  测试环境配置　　131\n6.6  小贴士　　132\n6.6.1  总是使用相对路径　　132\n6.6.2  消除手工步骤　　132\n6.6.3  从二进制包到版本控制库的内建可追溯性　　133\n6.6.4  不要把二进制包作为构建的一部分放到版本控制库中　　133\n6.6.5  “test”不应该让构建失败　　134\n6.6.6  用集成冒烟测试来限制应用程序　　134\n6.6.7  .NET 小贴士　　135\n6.7  小结　　135\n第7 章  提交阶段　　137\n7.1  引言　　137\n7.2  提交阶段的原则和实践　　138\n7.2.1  提供快速有用的反馈　　138\n7.2.2  何时令提交阶段失败　　139\n7.2.3  精心对待提交阶段　　140\n7.2.4  让开发人员也拥有所有权　　140\n7.2.5  在超大项目团队中指定一个构建负责人　　141\n7.3  提交阶段的结果　　141\n7.4  提交测试套件的原则与实践　　144\n7.4.1  避免用户界面　　145\n7.4.2  使用依赖注入　　145\n7.4.3  避免使用数据库　　145\n7.4.4  在单元测试中避免异步　　146\n7.4.5  使用测试替身　　 146\n7.4.6  最少化测试中的状态　　 149\n7.4.7  时间的伪装　　150\n7.4.8  蛮力　　150\n7.5  小结　　 151\n第8 章  自动化验收测试　　152\n8.1  引言　　 152\n8.2  为什么验收测试是至关重要的　　 153\n8.2.1  如何创建可维护的验收测试套件　　155\n8.2.2  GUI 上的测试　　 156\n8.3  创建验收测试　　157\n8.3.1  分析人员和测试人员的角色　　157\n8.3.2  迭代开发项目中的分析工作　　157\n8.3.3  将验收条件变成可执行的规格说明书　　 158\n8.4  应用程序驱动层　　161\n8.4.1  如何表述验收条件　　 163\n8.4.2  窗口驱动器模式：让测试与GUI 解耦　　164\n8.5  实现验收测试　　166\n8.5.1  验收测试中的状态　　 166\n8.5.2  过程边界、封装和测试　　 168\n8.5.3  管理异步与超时问题　　 169\n8.5.4  使用测试替身对象　　 171\n8.6  验收测试阶段　　174\n8.6.1  确保验收测试一直处于通过状态　　175\n8.6.2  部署测试　　177\n8.7  验收测试的性能　　178\n8.7.1  重构通用任务　　 178\n8.7.2  共享昂贵资源　　 179\n8.7.3  并行测试　　180\n8.7.4  使用计算网格　　 180\n8.8  小结　　181\n第9 章  非功能需求的测试　　183\n9.1  引言　　183\n9.2  非功能需求的管理　　184\n9.3  如何为容量编程　　186\n9.4  容量度量　　188\n9.5  容量测试环境　　191\n9.6  自动化容量测试　　194\n9.6.1  通过UI 的容量测试　　195\n9.6.2  基于服务或公共API 来录制交互操作　　196\n9.6.3  使用录制的交互模板　　 197\n9.6.4  使用容量测试桩开发测试　　198\n9.7  将容量测试加入到部署流水线中　　199\n9.8  容量测试系统的附加价值　　 201\n9.9  小结　　 202\n第10 章  应用程序的部署与发布　　 203\n10.1  引言　　203\n10.2  创建发布策略　　 204\n10.2.1  发布计划　　205\n10.2.2  发布产品　　205\n10.3  应用程序的部署和晋级　　 206\n10.3.1  首次部署　　206\n10.3.2  对发布过程进行建模并让构建晋级　　 207\n10.3.3  配置的晋级　　209\n10.3.4  联合环境　　209\n10.3.5  部署到试运行环境　　 210\n10.4  部署回滚和零停机发布　　211\n10.4.1  通过重新部署原有的正常版本来进行回滚　　211\n10.4.2  零停机发布　　212\n10.4.3  蓝绿部署　　 212\n10.4.4  金丝雀发布　　213\n10.5  紧急修复　　216\n10.6  持续部署　　216\n10.7  小贴士和窍门　　 219\n10.7.1  真正执行部署操作的人应该参与部署过程的创建　　219\n10.7.2  记录部署活动　　 220\n10.7.3  不要删除旧文件，而是移动到别的位置　　 220\n10.7.4  部署是整个团队的责任　　 220\n10.7.5  服务器应用程序不应该有GUI 　　220\n10.7.6  为新部署留预热期　　 221\n10.7.7  快速失败　　 221\n10.7.8  不要直接对生产环境进行修改　　222\n10.8  小结　　222\n第三部分  交付生态圈\n第11 章  基础设施和环境管理　　 224\n11.1  引言　　 224\n11.2  理解运维团队的需要　　 225\n11.2.1  文档与审计　　 226\n11.2.2  异常事件的告警　　 227\n11.2.3  保障IT 服务持续性的计划　　227\n11.2.4  使用运维团队熟悉的技术　　 228\n11.3  基础设施的建模和管理　　229\n11.3.1  基础设施的访问控制　　 230\n11.3.2  对基础设施进行修改　　 231\n11.4  服务器的准备及其配置的管理　　 232\n11.4.1  服务器的准备　　 233\n11.4.2  服务器的持续管理　　 234\n11.5  中间件的配置管理　　239\n11.5.1  管理配置项　　 239\n11.5.2  产品研究　　 241\n11.5.3  考查中间件是如何处理状态的　　 242\n11.5.4  查找用于配置的API 　　 242\n11.5.5  使用更好的技术　　 243\n11.6  基础设施服务的管理　　243\n11.7  虚拟化　　245\n11.7.1  虚拟环境的管理　　 247\n11.7.2  虚拟环境和部署流水线　　249\n11.7.3  用虚拟环境做高度的并行测试　　251\n11.8  云计算　　252\n11.8.1  云中基础设施　　253\n11.8.2  云中平台　　254\n11.8.3  没有普适存在　　255\n11.8.4  对云计算的批评　　256\n11.9  基础设施和应用程序的监控　　256\n11.9.1  收集数据　　257\n11.9.2  记录日志　　259\n11.9.3  建立信息展示板　　259\n11.9.4  行为驱动的监控　　261\n11.10  小结　　261\n第12 章  数据管理　　263\n12.1  引言　　263\n12.2  数据库脚本化　　264\n12.3  增量式修改　　265\n12.3.1  对数据库进行版本控制　　265\n12.3.2  联合环境中的变更管理　　267\n12.4  数据库回滚和无停机发布　　268\n12.4.1  保留数据的回滚　　268\n12.4.2  将应用程序部署与数据库迁移解耦　　269\n12.5  测试数据的管理　　270\n12.5.1  为单元测试进行数据库模拟　　271\n12.5.2  管理测试与数据之间的耦合　　272\n12.5.3  测试独立性　　272\n12.5.4  建立和销毁　　273\n12.5.5  连贯的测试场景　　273\n12.6  数据管理和部署流水线　　274\n12.6.1  提交阶段的测试数据　　274\n12.6.2  验收测试中的数据　　275\n12.6.3  容量测试的数据　　276\n12.6.4  其他测试阶段的数据　　277\n12.7  小结　　278\n第13 章  组件和依赖管理　　280\n13.1  引言　　280\n13.2  保持应用程序可发布　　281\n13.2.1  将新功能隐蔽起来，直到它完成为止　　282\n13.2.2  所有修改都是增量式的　　 283\n13.2.3  通过抽象来模拟分支　　 284\n13.3  依赖　　285\n13.3.1  依赖地狱　　 286\n13.3.2  库管理　　 287\n13.4  组件　　289\n13.4.1  如何将代码库分成多个组件　　289\n13.4.2  将组件流水线化　　 292\n13.4.3  集成流水线　　 293\n13.5  管理依赖关系图　　295\n13.5.1  构建依赖图　　 295\n13.5.2  为依赖图建立流水线　　 297\n13.5.3  什么时候要触发构建　　 299\n13.5.4  谨慎乐观主义　　 300\n13.5.5  循环依赖　　302\n13.6  管理二进制包　　303\n13.6.1  制品库是如何运作的　　 303\n13.6.2  部署流水线如何与制品库相结合　　 304\n13.7  用Maven 管理依赖　　304\n13.8  小结　　 308\n第14 章  版本控制进阶　　 309\n14.1  引言　　309\n14.2  版本控制的历史　　310\n14.2.1  CVS 　　310\n14.2.2  SVN 　　311\n14.2.3  商业版本控制系统　　 312\n14.2.4  放弃悲观锁　　 313\n14.3  分支与合并　　 314\n14.3.1  合并　　 316\n14.3.2  分支、流和持续集成　　 317\n14.4  DVCS 　　319\n14.4.1  什么是DVCS 　　 319\n14.4.2  DVCS 简史　　 321\n14.4.3  企业环境中的DVCS　　 321\n14.4.4  使用DVCS　　 322\n14.5  基于流的版本控制系统　　 324\n14.5.1  什么是基于流的版本控制系统　　324\n14.5.2  使用流的开发模型　　 326\n14.5.3  静态视图和动态视图　　 327\n14.5.4  使用基于流的版本控制系统做持续集成　　 328\n14.6  主干开发　　329\n14.7  按发布创建分支　　332\n14.8  按功能特性分支　　333\n14.9  按团队分支　　335\n14.10  小结　　338\n第15 章  持续交付管理　　340\n15.1  引言　　 340\n15.2  配置与发布管理成熟度模型　　341\n15.3  项目生命周期　　 343\n15.3.1  识别阶段　　344\n15.3.2  启动阶段　　345\n15.3.3  初始阶段　　346\n15.3.4  开发与发布　　347\n15.3.5  运营阶段　　 349\n15.4  风险管理流程　　 350\n15.4.1  风险管理基础篇　　 350\n15.4.2  风险管理时间轴　　 351\n15.4.3  如何做风险管理的练习　　352\n15.5  常见的交付问题、症状和原因　　353\n15.5.1  不频繁的或充满缺陷的部署　　353\n15.5.2  较差的应用程序质量　　 354\n15.5.3  缺乏管理的持续集成工作流程　　355\n15.5.4  较差的配置管理　　 355\n15.6  符合度与审计　　356\n15.6.1  文档自动化　　356\n15.6.2  加强可跟踪性　　 357\n15.6.3  在筒仓中工作　　 358\n15.6.4  变更管理　　358\n15.7  小结　　360\n参考书目　　361",
        "pages": "362",
        "images": {
          "small": "https://img3.doubanio.com/spic/s27996261.jpg",
          "large": "https://img3.doubanio.com/lpic/s27996261.jpg",
          "medium": "https://img3.doubanio.com/mpic/s27996261.jpg"
        },
        "alt": "https://book.douban.com/subject/6862062/",
        "id": "6862062",
        "publisher": "人民邮电出版社",
        "isbn10": "7115264597",
        "isbn13": "9787115264596",
        "title": "持续交付",
        "url": "https://api.douban.com/v2/book/6862062",
        "alt_title": "Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation",
        "author_intro": "Jez Humble ToughtWorks公司首席咨询顾问，致力于帮助企业快速、可靠地交付高质量软件，经常在各种敏捷技术大会上发表演讲，拥有牛津大学物理学学士学位和 伦敦大学民族音乐学的 硕士学位。2000年至今，他曾在各行业和不同技术领域担任系统管理员、开发人员、培训人员、咨询师和经理人员。\nDavid Farley 正在帮助构建伦敦多资产交易所（LMAE）。他具有20年的大型分布式系统开发经验，是采用敏捷开发技术的先行者，曾作为技术负责人参加了ThoughtWorks公司许多极具挑战性的软件项目。",
        "summary": "Jez Humble编著的《持续交付(发布可靠软件的系统方法)》讲述如何实现更快、更可靠、低成本的自动化软件交付，描述了如何通过增加反馈，并改进开发人员、测试人员、运维人员和项目经理之间的协作来达到这个目标。《持续交付(发布可靠软件的系统方法)》由三部分组成。第一部分阐述了持续交付背后的一些原则，以及支持这些原则的实践。第二部分是本书的核心，全面讲述了部署流水线。第三部分围绕部署流水线的投入产出讨论了更多细节，包括增量开发技术、高级版本控制模式，以及基础设施、环境和数据的管理和组织治理。    《持续交付(发布可靠软件的系统方法)》适合所有开发人员、测试人员、运维人员和项目经理学习参考。",
        "price": "89.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "49b261cc087960cc500aca13c6df03676217078dc9b8351fc9a164a4753c3068",
        "file": "持续交付-发布可靠软件的系统方法.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 86,
          "average": "8.3",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "James Shore",
          "Shane Warden"
        ],
        "pubdate": "2009-8",
        "tags": [
          {
            "count": 105,
            "name": "敏捷开发",
            "title": "敏捷开发"
          },
          {
            "count": 53,
            "name": "软件工程",
            "title": "软件工程"
          },
          {
            "count": 45,
            "name": "项目管理",
            "title": "项目管理"
          },
          {
            "count": 26,
            "name": "敏捷",
            "title": "敏捷"
          },
          {
            "count": 23,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 20,
            "name": "agile",
            "title": "agile"
          },
          {
            "count": 16,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 9,
            "name": "programming",
            "title": "programming"
          }
        ],
        "origin_title": "The Art of Agile Development",
        "image": "https://img3.doubanio.com/mpic/s28273545.jpg",
        "binding": "平装",
        "translator": [
          "王江平"
        ],
        "catalog": "",
        "pages": "448",
        "images": {
          "small": "https://img3.doubanio.com/spic/s28273545.jpg",
          "large": "https://img3.doubanio.com/lpic/s28273545.jpg",
          "medium": "https://img3.doubanio.com/mpic/s28273545.jpg"
        },
        "alt": "https://book.douban.com/subject/4037534/",
        "id": "4037534",
        "publisher": "机械工业出版社",
        "isbn10": "7111268040",
        "isbn13": "9787111268048",
        "title": "敏捷开发的艺术",
        "url": "https://api.douban.com/v2/book/4037534",
        "alt_title": "The Art of Agile Development",
        "author_intro": "",
        "summary": "本书为那些正在考虑应用敏捷开发来构建有价值软件的人们提供了实用的指导。现在已经有大量的书籍描述敏捷开发是什么或者为什么它能帮助软件项目成功，但很少有哪一本书能把针对开发者、管理者、测试者和客户的信息合并成一个整体，从而使其能够直接应用。\n本书为敏捷的计划、开发、交付和管理提供了严谨的建议，这些建议来自于作者多年的极限编程(Extreme Programming，XP)经验。你将看到敏捷开发过程的全景图，包括为非技术类读者准备的全面指导，以及为开发者和测试人员准备的实用技术实践。\n本书为以下问题提供了明确的答案：\n怎样才能采用敏捷开发?\n我们真的需要结对编程吗?\n汇报应该详细到什么程度?\n如果无法让客户参与进来该怎么办?\n我们应该编写多少文档?\n何时进行设计和架构?\n作为一名非开发人员，我应如何同敏捷团队一起工作?\n产品的路线在哪里?\nQA应该如何参与进来?\n本书教你如何采用XP实践，详细描述了每一种实践，然后讨论了一些原则，使你可以更改XP并创建自己的敏捷方法。尤其是，本书为敏捷开发中一些较为困难的方面(合作的需要和团队成员之间的信任)提供了解决办法。\n不管你目前已经是敏捷团队的一部分，还是只对敏捷开发感兴趣，本书都为你提供了开始实践敏捷开发所需的实用技巧。随着你的经验的增长，内容也随之深入。本书教你首先理解敏捷开发的规则，然后打破这些规则，最后当你掌握了敏捷开发的艺术之后，再完全撇开这些规则。",
        "price": "78.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "854f0083d907c85be08d680d3eddad40958f6ab21e6905af2246eac9afb77d2d",
        "file": "敏捷开发的艺术.epub"
      },
      {
        "title": "构建之法",
        "subtitle": "现代软件工程",
        "author": [
          "邹欣"
        ],
        "summary": "内容简介：\n软件工程牵涉的范围很广, 同时也是一般院校的同学反映比较空洞乏味的课程。 但是软件工程的技术对于投身IT 产业的学生来说是非常重要的。作者邹欣有长达20年的一线软件开发经验，他利用业余时间在数所高校进行了长达6年的软件工程教学实践，总结出了在16周的时间内让 同学们通过 “做中学 (Learning By Doing)” 掌握实用的软件工程技术的教学计划，并得到高校师生的积极反馈。在此基础上，作者对软件工程的各个知识点和技能要求进行了系统性整理，形成教材。\n本书共分17章，对照美国ACM/IEEE2013年新出版的计算机科学教学指导（Computer ScienceCurricula 2013）中的软件工程相关部分，这本教材覆盖了其中大多数Core-Tier1和Core-Tier2的内容。可以说，全书对软件工程内容的覆盖不逊于任何一本现行的教材，同时讲述了业界最新实践方法。\n本书评论：\n推荐软件工程专业学子阅读，了解软件工程真正内涵，懂得“工程”二字真正含义，知道软件工程和计算机科学的区别。了解之后，就知道为何软件工程是就业含金量较高的行业了。\n——朝红阳（http://weibo.com/u/1794892070）/中山大学软件学院\n书中 设想了大量的场景“学”和“习”，并且用了大量的类比，非常生动有趣。这本教材也对软件工程课老师提出了更高的要求；对学生而言，同样面临着要付出怎样的努力才能学到“干货”的选择。\n——鞠小林（http://weibo.com/jukxy）/南通大学软件学院\n关于计算机科学与软件工程的差别？这是我们学生问的最多的，这下有解释啦！包括书中谈到的师生关系、软件工程师的职业发展、职业道德等，这些内容我上课时都可以用。\n——牛慧娟/华中科技大学软件学院\n面对在软件开发方面经验很少的学生，邹欣老师通过丰富生动的故事和隐喻帮助学生建立软件工程的思维习惯，通过严格扎实的动手训练与考核帮助学生总结归纳自己的“最佳实践经验”。读这本书，软件工程课不再枯燥沉闷，而是变得出乎意料的生动有趣。\n——王忠杰（http://weibo.com/travellingwithme）/哈尔滨工业大学计算机科学与技术学院\n读完《构建之法——现代软件工程》，不禁惊叹，软件工程的书还可以这样写！像团队和流程、敏捷流程、需求分析、设计与实现这些章节我看了又看，看完之后不禁拍大腿（书里说的“拍脑门、拍胸脯、拍屁股”的三拍有点不全，还差“拍大腿”）：为什么邹欣老师会把原本无趣的问题写得这么吸引人？我深深地感觉到，不会讲故事的软件工程老师不是好老师！这本书给我最大的感受是，作者能把一个个鲜活的例子（或故事）与软件工程的相关问题恰到好处地结合起来，让软件工程的理论和方法更好地落地。\n——王赞（http://weibo.com/scswz）/天津大学软件学院\n将对软件工程思想的理解内化为软件工程师的职业习惯，是软件工程教学的核心目标，本书的实验设计恰恰非常有助于这一内化过程。个人项目、两人项目和团队项目由易到难，循序渐进，不断总结。我在教学中借鉴这一思路，从学生较为熟悉的编程训练入手，以范例演示基本编码规范、 No Design时的代码、经过基\n本Modularity (also called separation of concerns)设计的代码、writing code to make it reusable on future projects以及一些特殊的接口设计……从编码实践中理解软件工程思想，就会跳出纸上谈兵的框框。\n——孟宁（http://staff.ustc.edu.cn/~mengning/，http://weibo.com/mengning997 ）\n/中国科技大学软件学院\n软件工程在大学是最难讲，也是最容易讲的一门课，容易在这门课涵盖的内容和外延特别丰富，这些内容学生基本没概念，短期也无法落到实处来验证有用没用，所以老师可以大讲特讲，人畜无害；难在你要在学生一片空白（没有很强的代码能力、没有团队概念、没有项目经验）的情况下去让他们懂得这些东西。在我认识的人中，能有丰富的项目经验又愿意花时间在教学实践上，最终能把各种知识理论体系化的人寥寥无几。邹欣老师恰好这几点都具备。快速翻完整本书，最大的感受是这本书出版得恰逢其时，传统的软件工程教材早就该翻新了！\n——徐亚波（http://ss.sysu.edu.cn/~xyb，http://weibo.com/arber）/中山大学软件学院",
        "publisher": "人民邮电出版社",
        "isbn13": "9787115369161",
        "isbn10": "711536916X",
        "tags": [
          {
            "title": "软件工程",
            "name": "软件工程",
            "count": 845
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 347
          },
          {
            "title": "编程",
            "name": "编程",
            "count": 238
          },
          {
            "title": "项目管理",
            "name": "项目管理",
            "count": 199
          },
          {
            "title": "程序设计",
            "name": "程序设计",
            "count": 168
          },
          {
            "title": "计算机科学",
            "name": "计算机科学",
            "count": 109
          },
          {
            "title": "programming",
            "name": "programming",
            "count": 71
          },
          {
            "title": "教育",
            "name": "教育",
            "count": 58
          }
        ],
        "pubdate": "2014-9",
        "translator": [],
        "binding": "平装",
        "author_intro": "邹欣现任微软Windows中国工程团队首席研发总监。\n1996年～2003年，邹欣在微软Outlook团队从事开发工作，2003年～2005年，他在微软内部质量工具团队和Visual Studio团队负责软件项目管理工具的开发。2005年～2012年，他担任微软亚洲研究院技术创新组研发主管，负责研究成果的产品化和创新项目。2012年～2014年，他担任微软亚洲互联网工程院首席研发总监，负责必应搜索客户端、必应输入法、必应词典等产品。加入微软前，邹欣从事过商用Unix系统、GPS/GIS软件开发及测试工作。\n他在2007年出版了《移山之道》，于2008年出版了《编程之美》 （合作）。\n他于1991年获北京大学计算机软件专业学士学位。1996年获美国韦恩州立大学（Wayne State University）计算机软件专业硕士学位。",
        "rating": {
          "average": 8.7,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 475.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "b09145ffd65383e928eaa93dae3bbad563eb4cbe55d1647cebfb6d12afa18d45",
        "file": "构建之法.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 12693,
          "average": "7.6",
          "min": 0
        },
        "subtitle": "简单易行的时间管理方法",
        "author": [
          "[瑞典] Staffan Nöteberg"
        ],
        "pubdate": "2011-2",
        "tags": [
          {
            "count": 9608,
            "name": "时间管理",
            "title": "时间管理"
          },
          {
            "count": 3592,
            "name": "个人管理",
            "title": "个人管理"
          },
          {
            "count": 2012,
            "name": "GTD",
            "title": "GTD"
          },
          {
            "count": 1806,
            "name": "自我成长",
            "title": "自我成长"
          },
          {
            "count": 1328,
            "name": "方法论",
            "title": "方法论"
          },
          {
            "count": 1236,
            "name": "管理",
            "title": "管理"
          },
          {
            "count": 1033,
            "name": "方法",
            "title": "方法"
          },
          {
            "count": 1005,
            "name": "自我管理",
            "title": "自我管理"
          }
        ],
        "origin_title": "Pomodoro Technique Illustrated: The Easy Way to Do More in Less Time",
        "image": "https://img1.doubanio.com/view/subject/m/public/s29823747.jpg",
        "binding": "平装",
        "translator": [
          "大胖"
        ],
        "catalog": "第1章 一次只做一件事　　1\n黄瓜和洋蓟在酒吧相遇 　　　　2\n开始之前 　　　3\n乘车时间 　　　4\n番茄计时器 　　　5\n自己动手：为活动限定时间段 　　　6\n我的太爷爷马克斯 　　　7\n为何要用番茄工作法 　　　　8\n问自己：一次只做一件事 　　13\n第2章 背景　　　14\n黄瓜和洋蓟在动物园相遇 　　5\n基础 　　　　　　16\n大脑结构 　　　17\n大脑性能 　　　18\n生物节律 　　　19\n是迷信还是专注的力量 　　20\n条件和非条件反射 　　21\n左脑与右脑 　　　22\n天才 　　23\n多动 　　　24\n工作记忆 　　　25\n联想机器 　　　26\n交替和持续　　27\n做梦　　28\n吸收　　29\n吃饭睡觉钟　　30\n心流　　31\n激励　　32\n拖延　　33\n英雄主义和内疚　　34\n调整过程　　35\n薄片撷取　　36\n拥抱变化　　37\n选择的悖论　　38\n问自己：背景　　39\n第3章 方法　　40\n黄瓜和洋蓟在图书馆相遇41\n学习工作法　　42\n阶段　　43\n戴明循环　　44\n工具　　45\n自己动手：做一张活动清单表格　　46\n寻找起点　　47\n早晨　　48\n自己动手：做一张今日待办表格　　49\n承诺　　50\n直接和立即反馈　　51\n前瞻记忆　　52\n当下清单　　53\n休息　　54\n放下　　55\n阶段性休息 　　56\n行程 　　59\n已完成的活动 　　60\n抽象时间单位 　　61\n记录和处理 　　62\n自己动手：记录 　　63\n精益 　　64\n此时此地 　　65\n问自己：方法 　　66\n第4章 中断　　67\n黄瓜和洋蓟通电话 　　68\n学会坚持 　　69\n注意力缺乏症候群 　　70\n避免LIFO和BPUF 　　71\n可持续发展的步伐 　　72\n中断策略 　　73\n内部中断 　　74\n接受、记录并继续 　　75\n扭转依赖 　　76\n原子性 　　77\n内部中断滚滚来 　　78\n外部中断 　　79\n保护番茄钟 　　80\n可视化然后强化 　　81\n作废 　　82\n外部中断策略 　　83\n中断标记 　　84\n认清界限 　　85\n问自己：中断 　　86\n第5章 预估　　87\n黄瓜和洋蓟在赛马场相遇88\n测量和猜测　　89\n活动清单表格中的预估90\n群体的智慧　　91\n活动的规模　　92\n选择　　93\n定量预估误差　　94\n昨日的天气　　95\n记录表格中的预估　　96\n鼓－缓冲区－绳子　　97\n问自己：预估　　98\n第6章 应变　　99\n黄瓜和洋蓟在电影院相遇　　100\n灵活对待　　101\n简单工具　　102\n索引卡片　　103\n事务番茄钟　　104\n声音和形状　　105\n番茄钟的长短　　106\n休息的长短　　107\n进度表格　　108\n优先级淘汰赛　　109\n收件箱清零　　110\n反复回顾　　111\n思维导图日记　　112\n守则和应变　　113\n闻铃色变　　114\n问自己：应变　　115\n第7章 团队　　116\n黄瓜和洋蓟在会议室相遇　　117\n与他人共事　　118\n限制时间的会议　　119\n跟踪会议　　120\n匹配工作节奏　　121\n授权番茄钟开始　　122\n匹配番茄钟长短　　123\n临时单飞　　124\n跟踪工作配搭　　125\n团队文化　　126\n问自己：团队　　127\n附录A 流程示意图　　128\n附录B 互联网资源　　129\n附录C 后记　　130\n附录D 参考书目　　133",
        "ebook_url": "https://read.douban.com/ebook/386670/",
        "pages": "148",
        "images": {
          "small": "https://img1.doubanio.com/view/subject/s/public/s29823747.jpg",
          "large": "https://img1.doubanio.com/view/subject/l/public/s29823747.jpg",
          "medium": "https://img1.doubanio.com/view/subject/m/public/s29823747.jpg"
        },
        "alt": "https://book.douban.com/subject/5916234/",
        "id": "5916234",
        "publisher": "人民邮电出版社",
        "isbn10": "7115246696",
        "isbn13": "9787115246691",
        "title": "番茄工作法图解",
        "url": "https://api.douban.com/v2/book/5916234",
        "alt_title": "Pomodoro Technique Illustrated: The Easy Way to Do More in Less Time",
        "author_intro": "番茄工作法是弗朗西斯科•西里洛于1992年创立了。他在大学生活的头几年，曾一度苦于学习效率低下，“于是我和自己打赌，下猛药，狠狠鄙视自己说：‘我能学一会儿习吗？真正学上10分钟？’我得找个计时教练，谁来替我掐表呢？后来我找到了，是一枚厨房定时器，形状像‘西红柿’（Pomodoro ，意大利语的“番茄”）。就这样，我邂逅了我的番茄钟。”\n番茄工作法是一套简单的工具和流程，用以提升你个人和所在团队的生产力，从而做到：\n减轻时间焦虑\n提升集中力和注意力，减少中断\n增强决策意识\n唤醒激励和持久激励\n巩固达成目标的决心\n完善预估流程，精确地保质保量\n改进工作学习流程\n强化决断力，快刀斩乱麻",
        "summary": "本书介绍了时下最流行的时间管理方法之一——番茄工作法。作者根据亲身运用番茄工作法的经历，以生动的语言，传神的图画，将番茄工作法的具体理论和实践呈现在读者面前。番茄工作法简约而不简单，本书亦然。在番茄工作法一个个短短的25分钟内，你收获的不仅仅是效率，还会有意想不到的成就感。\n本书适合所有志在提高工作效率的人员，尤其是软件工作人员和办公人员。",
        "ebook_price": "12.00",
        "price": "29.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "90e70df208cf2fae8911d01c5e31dc54d85d4e99d04f0a233b74129f9e60b6c7",
        "file": "番茄工作法图解.epub"
      },
      {
        "timestamp": "2016-09-17T13:12:41.573671+00:00",
        "identifier": {
          "uuid": "9e369f33-cffc-4e75-bfe6-df7e1c6ad80e"
        },
        "description": "我所认为的程序员的自我养成手册。",
        "title": "程序员的自我修养",
        "language": "zh",
        "contributor": "GitBook",
        "creator": "Leo Hui",
        "publisher": "GitBook",
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "e6c526102fc3b5128704794bf6f39feba06d612030a36a0a9633112fb4beed85",
        "file": "程序员的自我修养.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 360,
          "average": "7.5",
          "min": 0
        },
        "subtitle": "打造应对不确定性的敏捷团队",
        "author": [
          "斯坦利•麦克里斯特尔",
          "坦吐姆•科林斯",
          "戴维•西尔弗曼",
          "克里斯•富塞尔"
        ],
        "pubdate": "2017-11-11",
        "tags": [
          {
            "count": 253,
            "name": "管理",
            "title": "管理"
          },
          {
            "count": 167,
            "name": "团队",
            "title": "团队"
          },
          {
            "count": 146,
            "name": "领导力",
            "title": "领导力"
          },
          {
            "count": 91,
            "name": "赋能",
            "title": "赋能"
          },
          {
            "count": 78,
            "name": "思维",
            "title": "思维"
          },
          {
            "count": 49,
            "name": "美军",
            "title": "美军"
          },
          {
            "count": 47,
            "name": "好书，值得一读",
            "title": "好书，值得一读"
          },
          {
            "count": 42,
            "name": "敏捷",
            "title": "敏捷"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/view/subject/m/public/s29615316.jpg",
        "binding": "平装",
        "translator": [
          "林爽喆"
        ],
        "catalog": "推荐序\n自序\n第一部分    应对不确定性\n\n第一章\t不确定性已经显现\n一场行动为我们敲响了“不确定性”的警钟\n优势也会失去掌控\n小团队与大组织\n伊拉克“基地”组织\n在无序中寻找关系\n环境因素的改变\n管理方式需要创新\n限制性因素\n第二章\t还原论的时代与全新的时代\n还原论的隐痛\n泰勒还原论的发轫\n“科学管理”大行其通\n还原论思想深入社会肌理\n新世界需要重写游戏规则\n马奇诺防线的启示\n第三章\t从复杂到错综复杂\n小“因”的非线性运行\n深陷不确定性旋涡\n错综复杂体系的不可控性\n不可预测的世界\n错综复杂的环境需要新的管理方法\n第四章\t建立有效组织\n用韧性思维应对不确定性\n获得并提高调整适应能力\n打破层级架构，构建网状组织\n\n第二部分    化繁为简\n第五章  建立互信和目标共享的团队\n调整适应能力的差别\n信任基础上的一致行动\n海豹突击队魔鬼训练的核心并非生产超级士兵\n打造互信和有明确目标的超级团队\n团队目标决定个人成败\n以互信的组织架构战略应对不确定性\n锻造团队的自发智慧\n以灵活的体系来杜绝未知的灾难\n小团队的调整适应能力是搭建组织架构的基础\n第六章\t突破“深井”，建立关系\n无法预测的危机“临界点”\n团队的调整适应能力被组织系统所束缚\n小团队的扩展阻力\n高效敏捷的小团队是一把双刃剑\n小团队构成的大团队\n调整组织架构势在必行\n\n第三部分    信息共享\n第七章\t打造体系思维\n信息“空隙”是无效组织的根源\n控制信息与分享信息\n打破信息阻隔的壁垒\n连接信息断点，了解系统全貌\n用体系管理应对不确定性\n将信息沟通机制扩展到整个体系\n第八章\t培养共享意识\n打破物理空间阻隔的启发\n文化的变革要与组织的变革相匹配\n信息共享是体系变革的心脏\n信息交叉分享使信息价值升值\n信息共享利远大于弊\n信息泄露与信息分享\n第九章\t击败“囚徒困境”\n“囚徒困境”提供的关系法则\n直接断点的交换制度：嵌入计划\n互信关系的建立：联络官计划\n系统理解和充分互信是培养共享意识的基石\n用共享意识革新“深井”式架构\n\n第四部分    赋能\n第十章\t应对不确定性的关键：赋能\n组织领导的能见度与控制力\n赋能已经不可避免\n赋能 = 做正确的事情\n找到赋能的平衡点\n共享意识是赋能的基础\n领导者在快速决策中发挥的作用\n第十一章  像园丁一样去领导\n“英雄式领袖”已经成为新时代的“濒危物种”\n领导者应是组织环境的缔造者\n维系组织氛围是领导者的首要职责\n领导者的使命\n\n第五部分    走在时代前面\n第十二章  新的时代需要新的组织架构\n新的组织蜕变带来的辉煌战果\n重新定义组织的要素\n沟通基础上的网状关系\n致谢\n注释",
        "ebook_url": "https://read.douban.com/ebook/43738282/",
        "pages": "384",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s29615316.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s29615316.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s29615316.jpg"
        },
        "alt": "https://book.douban.com/subject/27204181/",
        "id": "27204181",
        "publisher": "中信出版社",
        "isbn10": "7508676556",
        "isbn13": "9787508676555",
        "title": "赋能：打造应对不确定性的敏捷团队",
        "url": "https://api.douban.com/v2/book/27204181",
        "alt_title": "",
        "author_intro": "斯坦利•麦克里斯特尔：\n美国陆军四星上将，美军驻阿富汗以及国际安全援助部队的指挥官，曾担任联合参谋部主任和联合特种作战司令部的指挥官。在他的领导下，联合特种作战司令部迅速崛起，成为一个可在全球许多国家开展战地外小规模（反恐、反暴、救援等）行动的组织。\n坦吐姆•科林斯：马歇尔奖学金学者，在剑桥大学任教。\n戴维•西尔弗曼：克里斯•富塞尔：CrossLead公司高级执行官，也曾经是美国海军海豹突击队军官。",
        "summary": "在错综复杂的新生态下，预测已经成为不可能，运营的关键已从控制—命令式转变为赋能——分布式，唯有如此才能在新生态下取得成功。\n一手打造了全球最强战斗力的美军特种作战司令部指挥官的斯坦利•麦克里斯特尔，摒弃掉存在了一个多世纪的常规思维，在一场残酷的战争中对特遣部队进行重塑，将其打造成新物种：一张在沟通上极度透明、在决策上去中心化的网络。“深井”间的壁垒被摧毁。领导者们看着运转最小团队的最佳操作方式，并且找到方法把这些操作方式推广到上成千上万的人身上，同时运用一些10年前还无法想象的技术将这些人捏合成一个整体。\n就像华为的任正非号召华为17万员工向美军学习一样，你也一定需要这样一部经过战火和鲜血考验的管理运营法则，在错综复杂的环境下取得成功。",
        "ebook_price": "34.80",
        "price": "58",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "393e72441487a72c9ceca0b8bf4497902600bd6eca9b30f93a080ebf9b96d1a8",
        "file": "赋能-打造应对不确定性的敏捷团队.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 70,
          "average": "7.5",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "Dave Hendricksen"
        ],
        "pubdate": "2012-5-1",
        "tags": [
          {
            "count": 109,
            "name": "软件架构",
            "title": "软件架构"
          },
          {
            "count": 67,
            "name": "架构",
            "title": "架构"
          },
          {
            "count": 35,
            "name": "软件工程",
            "title": "软件工程"
          },
          {
            "count": 25,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 24,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 14,
            "name": "架构师",
            "title": "架构师"
          },
          {
            "count": 13,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 13,
            "name": "修炼",
            "title": "修炼"
          }
        ],
        "origin_title": "Essential Skills for Software Architects",
        "image": "https://img3.doubanio.com/mpic/s9109455.jpg",
        "binding": "平装",
        "translator": [
          "张菲"
        ],
        "catalog": "译者序\n前  言\n致  谢\n第一部分   关系技能修炼\n第1章　文雅的举止\t3\n1.1　别人怎样评价你\t3\n1.2　技术之天花板\t4\n1.3　变得文雅、专业的途径\t6\n1.3.1　注重关系甚于争执孰对孰错\t6\n1.3.2　学会委派\t8\n1.3.3　生活是有反作用的\t9\n1.3.4　有效沟通之生与死\t11\n1.3.5　要正直诚实而不是率直\t13\n1.3.6　不要掩盖问题—它们以后还会冒出来的\t14\n1.3.7　提供专业的服务\t16\n1.3.8　忘掉以前的冒犯\t17\n1.4　小结\t19\n1.5　参考资料\t19\n第2章　沟通\t22\n2.1　沟通原则\t23\n2.1.1　先听后说\t24\n2.1.2　专心致志\t24\n2.1.3　正面思考\t25\n2.1.4　尽早道歉\t25\n2.1.5　不要在缺陷上招致恼羞成怒\t26\n2.2　沟通策略\t27\n2.2.1　多说“是”，少说“不是”\t27\n2.2.2　在销售过程中建立起信任关系\t28\n2.2.3　特殊场合才说“不”\t29\n2.2.4　抑制想自卫的冲动\t31\n2.2.5　倾听建议来改善合作\t31\n2.2.6　了解别人和自己的沟通需求\t32\n2.2.7　才思敏捷\t34\n2.3　与执行官沟通\t35\n2.3.1　执行官需要信任、忠诚和连贯性\t35\n2.3.2　清晰性甚于完整性\t36\n2.3.3　不要让执行官感到惊讶\t37\n2.4　小结\t38\n2.5　参考资料\t39\n第3章　协商\t41\n3.1　协商原则\t42\n3.1.1　不要让人惊讶\t42\n3.1.2　不要模棱两可\t43\n3.1.3　委派权威而不是义务\t43\n3.1.4　有困难时寻求帮助\t44\n3.1.5　不要掩盖问题\t44\n3.1.6　即使很难，也要坚持做正确的事\t45\n3.2　协商策略\t45\n3.2.1　倾听你的内心呼唤\t45\n3.2.2　设法同意\t45\n3.2.3　不要找分歧\t47\n3.2.4　寻找共同点\t47\n3.2.5　如果无法达到一致，就让所有人稍微不满吧\t48\n3.2.6　将协商作为一种改进措施\t49\n3.3　协商前的工作\t49\n3.3.1　知道哪些是可协商的\t49\n3.3.2　了解如何在单位里游刃有余\t51\n3.3.3　关键决定上寻求合作氛围\t52\n3.3.4　学习文化\t53\n3.3.5　让别人明白你的想法\t53\n3.4　协商的收尾\t54\n3.4.1　捍卫决策的执行\t54\n3.4.2　维护架构决定记录\t54\n3.4.3　你有时会赢，有时会输\t55\n3.4.4　从委派中学习\t56\n3.5　小结\t56\n3.6　参考资料\t58\n第4章　领导力\t60\n4.1　领导力的原则\t61\n4.1.1　建立信任关系\t61\n4.1.2　建立共识\t62\n4.1.3　建立战略伙伴关系（通过关系带来安全）\t62\n4.1.4　要身体力行（为你所说的话带来安全）\t63\n4.1.5　感知风险、评估影响、做出行动（明确风险的清晰度）\t64\n4.1.6　适当处理风险：什么是鞭炮，什么是原子弹（明确影响的清晰度）\t65\n4.2　领导策略\t66\n4.2.1　奥卡姆剃刀法\t66\n4.2.2　展现可视化信息\t66\n4.2.3　领导者要确保事情不跑题\t67\n4.2.4　基于环境推销\t68\n4.2.5　随大流（找机会利用已有的资源）\t69\n4.2.6　关注执行官于认知，而非解决冲突\t69\n4.3　领导的时机\t70\n4.3.1　利用单位的动量\t70\n4.3.2　知道何时伸出援手\t71\n4.3.3　允许其他人学习\t71\n4.3.4　知道何时该卓尔不群\t72\n4.3.5　请求原谅还是征求允许\t73\n4.4　领导别人\t73\n4.4.1　允许别人奉献（不要命令）\t74\n4.4.2　通过影响力激励别人\t76\n4.4.3　确保别人能做主\t76\n4.4.4　处理冲突\t77\n4.5　小结\t77\n4.6　参考资料\t79\n第5章　政治\t81\n5.1　政治的定义\t81\n5.2　政治市场\t82\n5.3　政治环境\t85\n5.3.1　与公司的战略方向保持一致\t85\n5.3.2　理解你所处的文化环境\t86\n5.3.3　及早处理别人关注的问题\t87\n5.3.4　相信你所推销的东西\t89\n5.3.5　不关我的事\t90\n5.3.6　关系很重要（与别人的关系）\t90\n5.4　政治原则\t91\n5.4.1　宽宏大量\t91\n5.4.2　不要为你的价值妥协\t92\n5.4.3　光明正大地竞争\t92\n5.4.4　透明地操作\t92\n5.4.5　你是怎样的人就怎样表现\t93\n5.4.6　帮助别人，不求回报\t93\n5.4.7　认识到生活是反身的\t93\n5.5　政治策略\t94\n5.5.1　帮助别人达成其目标\t94\n5.5.2　学会享受过程而不是目标\t94\n5.5.3　在关键之处力争出色\t95\n5.5.4　愿意就低优先级目标妥协\t95\n5.5.5　不要对别人的糟糕举止采取冒犯的行动\t96\n5.5.6　私下处理人际问题\t97\n5.6　政治时机\t97\n5.6.1　以适时的作风执行事情\t97\n5.6.2　今天失利并不代表明天不会成功\t98\n5.6.3　要认识到政治上你不会是常胜将军\t99\n5.6.4　积极参与政治游戏\t99\n5.7　成为一名好的政治人物\t100\n5.8　参考资料\t101\n第二部分　个人技能修炼\n第6章　透明化\t105\n6.1　住在玻璃房中的架构师\t105\n6.2　透明化的类型\t106\n6.3　自我透明化\t107\n6.3.1　表现自然真诚\t107\n6.3.2　承认自己的弱点\t108\n6.3.3　承认你的实力和兴趣\t109\n6.3.4　赶在人前与上司沟通\t110\n6.4　项目透明化\t111\n6.4.1　让执行官看到你手里所有的扑克牌\t111\n6.4.2　架构师把透明化和清晰性带到许多领域\t112\n6.4.3　架构师将“发现”变成“收获”\t113\n6.5　关系透明化\t116\n6.5.1　该信任时就给别人信任\t116\n6.5.2　你说的话长久不变\t117\n6.5.3　道歉表明你的透明化\t118\n6.5.4　学会在做出反应前倾听（寻求透明化）\t118\n6.5.5　允许别人对你透明化\t119\n6.6　成为一名透明的架构师\t119\n6.7　参考资料\t120\n第7章　激情\t122\n7.1　什么是激情\t123\n7.2　发现激情\t124\n7.2.1　如何找到激情\t124\n7.2.2　恒心与激情：终极的杀手组合\t125\n7.2.3　岗位上的激情\t126\n7.2.4　重新点燃激情\t127\n7.3　将激情作为向导\t127\n7.3.1　等待机遇：它经常在找你，说话非常轻\t128\n7.3.2　跟着直觉走\t129\n7.3.3　选择你有激情的领域\t129\n7.3.4　改变会督促你前行\t130\n7.3.5　缺乏激情会成为你事业上升的天花板\t131\n7.3.6　把难事做好，尽心尽力投入\t131\n7.3.7　激情是提供动力的内在燃料\t132\n7.4　保护你的激情\t132\n7.4.1　忽略批评：这是你的激情、你的认知，不是他们的\t132\n7.4.2　不要分神\t133\n7.5　今天能做什么来追求你的激情\t134\n7.6　学会投入并享受过程\t135\n7.7　成为一名激情四射的架构师\t135\n7.8　参考资料\t136\n第8章　语境切换\t138\n8.1　自我意识语境\t140\n8.1.1　专心致志\t140\n8.1.2　明白你的弱项\t141\n8.1.3　生命中不仅仅有工作\t141\n8.1.4　多任务工作的效率奥秘\t141\n8.1.5　控制你的肾上腺素：慢下来\t142\n8.2　架构意识语境\t142\n8.2.1　使用“可/有…性”的字眼\t142\n8.2.2　寻求适当的耦合性和内聚性\t142\n8.2.3　持续构建你的语境\t143\n8.3　“大象”语境\t144\n8.3.1　哪些事没有提到\t144\n8.3.2　提问一些难题\t145\n8.3.3　早些发出坏消息\t145\n8.3.4　如果他们拥有这个公司，他们会怎么做\t146\n8.4　决策意识语境\t146\n8.4.1　他们真的已经把问题解决了\t146\n8.4.2　他们知道哪些替代方案可行吗\t147\n8.4.3　别人是否已经权衡过此技术\t147\n8.4.4　作为中立的第三方，即便这样做是个缺点\t147\n8.5　交谈语境\t148\n8.5.1　不要开会和用电子邮件\t148\n8.5.2　如果需要，（马上）让别人参与进来\t148\n8.6　谈话者语境\t148\n8.6.1　了解你的谈话对象\t148\n8.6.2　中庸之道\t149\n8.6.3　有时要唱红脸，有时要唱白脸\t149\n8.6.4　提供背景信息\t149\n8.7　项目语境\t150\n8.7.1　提出预算\t150\n8.7.2　带来实用性\t151\n8.7.3　学会在雪崩中冲浪\t151\n8.7.4　挑出专门的资源\t151\n8.7.5　你做出了哪些假设条件\t152\n8.8　成为一名善于察言观色、见风使舵的架构师\t152\n8.9　参考资料\t154\n第三部分　商务技能修炼\n第9章　商务知识\t157\n9.1　了解商务\t159\n9.1.1　营销、财务（投入产出比）和销售\t159\n9.1.2　考虑拿一个商务学位\t161\n9.2　了解你的公司\t162\n9.2.1　了解产品对客户的价值所在\t162\n9.2.2　知道你的公司如何赚钱\t163\n9.2.3　了解你公司的历史、文化\t163\n9.3　了解你的顾客\t164\n9.3.1　考虑拜访顾客、打电话给销售或者在门面上帮员工干活\t164\n9.3.2　考虑参与可用性研究，参与产品概念访谈或其他客户产品评估\t167\n9.3.3　考虑使用敏捷技术\t167\n9.4　了解你的领域\t167\n9.4.1　收集领域知识\t168\n9.4.2　在商务环境中了解你的领域\t169\n9.5　帮助公司更好地了解技术\t169\n9.6　成为一名谙熟商务的架构师\t170\n9.7　参考资料\t171\n第10章　创新\t173\n10.1　创新的定义\t174\n10.2　建立边界条件\t175\n10.2.1　找出边界条件\t175\n10.2.2　在边界内创新\t176\n10.2.3　你会做什么（假如没有约束条件，不必故作姿态）\t178\n10.2.4　鼓励别人思考、开放\t178\n10.2.5　应对那些唱反调的人\t179\n10.2.6　避开唱反调的人，找个安全的地方来思考\t179\n10.3　发展内心准则\t179\n10.3.1　顺从你的直觉\t179\n10.3.2　学会信任自己\t180\n10.3.3　认真倾听客户的声音，但要保持自己的认知\t180\n10.3.4　听听别人的话（协作）\t181\n10.3.5　你今天能迈出一小步吗\t181\n10.3.6　今天不行没关系：继续埋头苦干，早晚会成功的\t182\n10.4　组合基本概念\t182\n10.4.1　阅读、阅读、还是阅读\t183\n10.4.2　疯狂的主意让你发现真正的边界\t183\n10.4.3　要有大眼光\t184\n10.4.4　创新者的困难抉择\t184\n10.4.5　创新与集聚：将事情按正确分组整合在一起\t184\n10.4.6　选择简洁\t185\n10.4.7　简洁性是知识产权的根本\t185\n10.4.8　在着手解决前先思考问题\t186\n10.4.9　定义问题\t186\n10.4.10　睡觉时思考\t187\n10.4.11　战略问题还是战术问题\t187\n10.5　成为一名能创新的架构师\t187\n10.6　参考资料\t189\n第11章　实用主义\t191\n11.1　实用型架构的定义\t191\n11.2　范围管理\t192\n11.2.1　与商务伙伴一起确定特性的优先级\t192\n11.2.2　帮助执行官做出正确决策\t193\n11.2.3　处理不确定性\t193\n11.2.4　有些时候，你只需要一个概念就能开始干了\t193\n11.2.5　使用敏捷过程作为一种实用主义方法\t194\n11.3　风险管理\t194\n11.3.1　区分可能性和可行性\t194\n11.3.2　对于每个决定，都自问一些重要的问题\t196\n11.3.3　应对可能的风险\t197\n11.3.4　架构刺探\t197\n11.3.5　与运营人员一起确定效率\t197\n11.3.6　观察其他项目，决定有哪些地方是可牺牲的\t198\n11.4　沟通\t198\n11.4.1　记录下大家一致同意的决议\t199\n11.4.2　提供多种替代方案，并推荐其中一种\t199\n11.4.3　用透明性拉平期望值\t199\n11.4.4　发展经验方法来估量项目\t200\n11.5　成为一名实用主义的架构师\t200\n11.6　参考资料\t201\n第12章　认知\t203\n12.1　认知之定义\t204\n12.2　找寻和创立引人注目的目标\t204\n12.2.1　发现认知\t204\n12.2.2　从混沌现实编造出有说服力的故事\t206\n12.2.3　克服障碍\t207\n12.3　开发与建立战略路线图\t208\n12.3.1　将路线映射至认知\t208\n12.3.2　制定支持认知的战略\t209\n12.4　确定志同道合的伙伴\t210\n12.4.1　认知需要齐心协力\t210\n12.4.2　认知要求有关键的利益相关者\t211\n12.4.3　认知需要资金支持\t212\n12.5　实践认知\t213\n12.5.1　将认知当做增加投入产出比的战略\t213\n12.5.2　使用认知灌输目标感\t213\n12.5.3　在项目评估时就应用认知\t214\n12.5.4　采用支出信封（界定认知范围）\t215\n12.6　成为一名有远见的架构师\t215\n12.7　参考资料\t216",
        "pages": "216",
        "images": {
          "small": "https://img3.doubanio.com/spic/s9109455.jpg",
          "large": "https://img3.doubanio.com/lpic/s9109455.jpg",
          "medium": "https://img3.doubanio.com/mpic/s9109455.jpg"
        },
        "alt": "https://book.douban.com/subject/10746257/",
        "id": "10746257",
        "publisher": "机械工业出版社华章公司",
        "isbn10": "7111378601",
        "isbn13": "9787111378600",
        "title": "软件架构师的12项修炼",
        "url": "https://api.douban.com/v2/book/10746257",
        "alt_title": "Essential Skills for Software Architects",
        "author_intro": "Dave Hendricksen是Thomson Reuters公司的一名架构工程师。他与公司的新产品开发团队紧密合作，为Westlaw.com等大型在线平台设计创新性产品。他最近还出席了卡内基•梅隆大学强力软件工程学院的“在敏捷世界里设计与构建大型系统”研讨会。",
        "summary": "每一位软件开发人员都有一个架构师的梦，但为何真正的软件架构师却寥寥无几？软件开发人员更容易在技术上有所积累和突破，但是技术上的精湛并不足以使你成为一位优秀的软件架构师。合格的软件架构师究竟应该具备哪些能力和素养？本书科学而系统地归纳出软件架构师应该具备的完整能力模型，该能力模型呈一金字塔结构，共分为4层：位于最底层的是技术技能，是软件架构师的基石，属于硬技能；从下往上的三层分别是关系技能、个人技能和商务技能，这些都属于软技能。由于硬技能会随着具体技术领域的不同而千差万别，因此本书假定读者已经具备了这方面的技能；但其他3大方面的软技能却在每个技术领域都适用，是每一位软件架构师的必修课，这是本书的核心内容。\n为了便于认知和实践，本书将3大方面的软技能分为12项：关系技能包含文雅的举止（在任何环境下都能与人文雅相处的能力）、沟通（与人有效交互的能力）、协商（将事情办成的能力）、领导力（通过施加影响力将事情办成的能力）和政治（“政治场合”与人交互的能力）等5项；个人技能包含透明化（使自我、团队关系和项目透明化的能力）、激情（激发和保护激情的能力）和语境切换（将注意力迅速切换到新语境并保持专注的能力）等3项；商务技能包括商务知识（读懂商务语言的能力和了解产品与顾客的能力）、创新（如何通过学习和思考来创新的能力）、实用主义（抓住关键问题的能力）、认知（认知目标、战略及合作伙伴的能力）等4项。\n本书不仅帮助软件开发人员系统地学习如何修炼这12项软技能，而且还能让他们进一步理解软件架构师的角色和本质，使他们最终突破技术的“天花板”，成为一名合格的软件架构师。",
        "series": {
          "id": "12919",
          "title": "华章程序员书库"
        },
        "price": "59.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "22a45f77ac450d5faab530fe0d1d19a6c2cc5715a65ad546421caf675304a4d2",
        "file": "软件构架师的12项修炼.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 441,
          "average": "8.0",
          "min": 0
        },
        "subtitle": "代码之外的生存指南",
        "author": [
          "John Sonmez"
        ],
        "pubdate": "2016-7",
        "tags": [
          {
            "count": 269,
            "name": "软技能",
            "title": "软技能"
          },
          {
            "count": 222,
            "name": "程序员",
            "title": "程序员"
          },
          {
            "count": 215,
            "name": "个人管理",
            "title": "个人管理"
          },
          {
            "count": 131,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 115,
            "name": "自我管理",
            "title": "自我管理"
          },
          {
            "count": 70,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 69,
            "name": "软件工程",
            "title": "软件工程"
          },
          {
            "count": 55,
            "name": "互联网",
            "title": "互联网"
          }
        ],
        "origin_title": "Soft Skills: The software developer's life manual",
        "image": "https://img3.doubanio.com/mpic/s28889106.jpg",
        "binding": "平装",
        "translator": [
          "王小刚"
        ],
        "catalog": "第1章 为何这本书与你先前读过的任何书籍都迥然不同 1\n篇 职业 5\n第2章 从非同凡响开始：绝不要做他人都在做的事 7\n第3章 思考未来：你的目标是什么 10\n第4章 人际交往能力：远比你想象的重要 14\n第5章 破解面试之道 18\n第6章 就业选择：列出你的选择 23\n第7章 你是哪类软件开发人员 28\n第8章 公司与公司是不一样的 33\n第9章 攀登晋升阶梯 38\n第10章 成为专业人士 42\n第11章 赢得自由——如何辞职 47\n第12章 成为自由职业者：开启自己的一片天地 54\n第13章 创建你的一个产品 60\n第14章 你打算开始创业吗 65\n第15章 远程工作的生存策略 70\n第16章 假装自己能成功 74\n第17章 单调乏味的简历——如何修改 77\n第18章 请勿陷入对技术的狂热之中 81\n第二篇 自我营销 85\n第19章 针对“码农”的营销基础课 87\n第20章 打造引人注目的品牌 92\n第21章 创建大获成功的博客 97\n第22章 你的主要目标：为他人增加价值 104\n第23章 善于运用社交媒体 107\n第24章 演讲、报告和培训：做“说话的极客” 112\n第25章 著书立说，吸引追随者 117\n第26章 百折不挠，越挫越勇 121\n第三篇 学习 125\n第27章 学习怎样学习：如何自我教育 127\n第28章 我的“十步学习法” 130\n第29章 第 1 步到第 6 步：这些步骤只做一次 133\n第30章 第7步到第10步：循环往复 140\n第31章 寻找导师：找到你的尤达 145\n第32章 开山收徒：成为尤达一样的大师 150\n第33章 传道授业：若要学知识，必得为人师 153\n第34章 你需要一个学位吗，还是可以对此忽略不计 157\n第35章 发现自己的知识短板 161\n第四篇 生产力 165\n第36章 一切始于专注 167\n第37章 我的私房“生产力提升计划” 171\n第38章 番茄工作法 177\n第39章 我的“定额工作法”：我是如何做到超额完成工作的 183\n第40章 对自己负责 187\n第41章 要不要多任务并行 191\n第42章 职业倦怠：我已找到解药 195\n第43章 时间是怎样被浪费掉的 200\n第44章 形成惯例的重要性 205\n第45章 培养习惯：刷新你的代码 209\n第46章 分解任务：如何吃掉一头大象 214\n第47章 努力工作的价值，以及为什么你总是逃避努力工作 219\n第48章 任何行动都比不采取行动好 223\n第五篇 理财 229\n第49章 怎样支配你的薪水 231\n第50章 怎样进行薪酬谈判 236\n第51章 期权：所有乐趣之所在 243\n第52章 房地产投资面面观 250\n第53章 你真的了解自己的退休计划吗 256\n第54章 债务的危害：社保债务代价昂贵 263\n第55章 额外馈赠：我是如何做到33岁退休的 267\n第六篇 健身 279\n第56章 为什么需要破解自己的健康密码 281\n第57章 设定你的健身标准 285\n第58章 热力学、热量和你 289\n第59章 动力：让你的屁股离开椅子 294\n第60章 如何增长肌肉：书呆子也能拥有强健的肌肉 298\n第61章 如何获得完美腹肌 305\n第62章 启动跑步程序 308\n第63章 站立式办公及其他窍门 311\n第64章 高科技健身装备：极客现身 315\n第七篇 精神 319\n第65章 心灵是如何影响身体的 321\n第66章 拥有正确的心态：重新启动 325\n第67章 构建一个积极的自我形象——规划你的大脑 330\n第68章 爱情与恋爱：计算机无法牵着你的手 335\n第69章 我的私房成功书单 339\n第70章 积极面对失败 344\n第71章 结束语 348\n附录A 如果你能写代码，你就能理解金融 350\n附录B 股市是如何运作的：系统的游戏规则 356\n附录C 垃圾进来，垃圾出去：饮食和营养基础知识 362\n附录D 如何吃出健康来：比萨并不是一个食物组 366",
        "pages": "480",
        "images": {
          "small": "https://img3.doubanio.com/spic/s28889106.jpg",
          "large": "https://img3.doubanio.com/lpic/s28889106.jpg",
          "medium": "https://img3.doubanio.com/mpic/s28889106.jpg"
        },
        "alt": "https://book.douban.com/subject/26835090/",
        "id": "26835090",
        "publisher": "人民邮电出版社",
        "isbn10": "7115429472",
        "isbn13": "9787115429476",
        "title": "软技能",
        "url": "https://api.douban.com/v2/book/26835090",
        "alt_title": "Soft Skills: The software developer's life manual",
        "author_intro": "John Z. Sonmez是“Simple Programmer”网站的创始人，他不辞辛劳地追求着“将复杂问题转化为简单解决方案”的梦想。他为在线培训机构Pluralsight开发了50多门在线课程，涉及iOS、Android、.NET、Java和游戏开发等多个主题。\n他是“Get Up and CODE”播客的主持人，在这里他讨论程序员健身；他还是“Entreprogrammers”播客的主持人，在这里他和其他三位开发者/企业家分享他们构建在线业务的真实故事。\nJohn是软件开发人员的人生导师，他帮助软件工程师、程序员和其他专业技术人员推动事业进步，过上更充实的生活。他通过“化繁为简”的方法，赋予他们达成自身目标的力量。",
        "summary": "这是一本真正从“人”（而非技术也非管理）的角度关注软件开发人员自身发展的书。书中论述的内容既涉及生活习惯，又包括思维方式，凸显技术中“人”的因素，全面讲解软件行业从业人员所需知道的所有“软技能”。本书聚焦于软件开发人员生活的方方面面，从揭秘面试的流程到精耕细作出一份杀手级简历，从创建大受欢迎的博客到打造你，从提高自己工作效率到与如何与“拖延症”做斗争，甚至包括如何投资不动产，如何关注自己的健康。本书共分为职业篇、自我营销篇、学习篇、生产力篇、理财篇、健身篇、精神篇等七篇，概括了软件行业从业人员所需的“软技能”。通过阅读本书，软件工程人员、编程人员和其他技术人员能够积极思考自己的职业生涯，丰富自己的生活，让自己更接近成功。",
        "price": "59.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "813a7d66d9dc83caabeea8acad99c3a875a4f2b11b8588ed526a5ff7d432a334",
        "file": "软技能-代码之外的生存指南.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 229,
          "average": "9.1",
          "min": 0
        },
        "subtitle": "改善既有代码的设计",
        "author": [
          "Martin Fowler"
        ],
        "pubdate": "2003-7-1",
        "tags": [
          {
            "count": 131,
            "name": "重构",
            "title": "重构"
          },
          {
            "count": 91,
            "name": "软件工程",
            "title": "软件工程"
          },
          {
            "count": 64,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 46,
            "name": "设计模式",
            "title": "设计模式"
          },
          {
            "count": 43,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 33,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 25,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 24,
            "name": "refactoring",
            "title": "refactoring"
          }
        ],
        "origin_title": "Refactoring: Improving the Design of Existing Code",
        "image": "https://img3.doubanio.com/view/subject/m/public/s1298590.jpg",
        "binding": "平装(无盘)",
        "translator": [],
        "catalog": "\n      ",
        "pages": "460",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s1298590.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s1298590.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s1298590.jpg"
        },
        "alt": "https://book.douban.com/subject/1229901/",
        "id": "1229901",
        "publisher": "中国电力出版社",
        "isbn10": "7508315014",
        "isbn13": "9787508315010",
        "title": "重构",
        "url": "https://api.douban.com/v2/book/1229901",
        "alt_title": "Refactoring: Improving the Design of Existing Code",
        "author_intro": "",
        "summary": "随着对象技术应用越来越普及，软件开发社区出现了一个新的问题。缺乏经验的开发者编写出了大批设计较差的程序，导致这些应用程序非常低效，且难于维护和扩展。本书除了讨论重构的各种技巧之外，还提供了超过70个可行重构的详细编目，对如何应用它们给出了有用的提示；并以step by step的形式给出了应用每一种重构的指南；而且用实例展示了重构的工作原理。这些示例都是用Java语言写成的，但其中的思想却可以运用于任何面向对象编程语言。\t\n本书是软件工程领域的超级经典巨著，与另一巨著《设计模式》并称\"软工双雄\"，全美销量超过100000册，亚马逊书店五星书。在本书中，作者Martin Fowler充分展示了何处可能需要重构，以及如何将不好的设计改造为良好的设计。重构的每一步可能都非常简单、非常基础，但这些轻微的改变的累积效果却可以在极大程度上改进我们的设计。事实证明，重构是防止软件没落的可行方式。 \n\n本书除了讨论重构的各种技巧之外，还提供了超过70个可行重构的详细目录，给出了重构的工作原理，并以step by step的形式给出了应用每一种重构的指南。这些示例都是用Java语言写成的，但其中的思想却可以运用到任何面对象的编程语言中。  \n\n第一作者Martin Fowler，除了是对象技术方面的专家外，还是UML和模式方面的专家。他撰写的Analysis Patterns、UML Distilled、Patterns of Enterprise Application Architecture和Planning Extreme Programming几本书也广受赞誉，在亚马逊上的评价也极高（最低星级为4星），从这些也足可见其在业内的显赫地位。相信这本书以影印版的形式在国内推出，巨匠巨著，原汁原味，无疑是给国内广大软件开发人员提供了一盏前进路上的明灯。 \n\n读者对象：软件开发人员，项目管理人员，高等院校计算机及相关专业师生，其他相关人员",
        "price": "49.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "fac6b60f20ae19d829f99f67b8310b6b005fa6e53421497cc8753115cc87fc24",
        "file": "重构.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 1006,
          "average": "8.2",
          "min": 0
        },
        "subtitle": "敏捷开发修炼之道",
        "author": [
          "Venkat Subramaniam",
          "Andy Hunt"
        ],
        "pubdate": "2010-01",
        "tags": [
          {
            "count": 667,
            "name": "敏捷开发",
            "title": "敏捷开发"
          },
          {
            "count": 418,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 374,
            "name": "程序员",
            "title": "程序员"
          },
          {
            "count": 301,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 203,
            "name": "软件工程",
            "title": "软件工程"
          },
          {
            "count": 197,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 196,
            "name": "方法论",
            "title": "方法论"
          },
          {
            "count": 113,
            "name": "programming",
            "title": "programming"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/mpic/s4073509.jpg",
        "binding": "平装",
        "translator": [
          "钱安川",
          "郑柯"
        ],
        "catalog": "第1章　敏捷——高效软件开发之道\n第2章　态度决定一切\n1. 做事\n2. 欲速则不达\n3. 对事不对人\n4. 排除万难，奋勇前进\n第3章　学无止境\n5. 跟踪变化\n6. 对团队投资\n7. 懂得丢弃\n8. 打破砂锅问到底\n9. 把握开发节奏\n第4章　交付用户想要的软件\n10. 让客户做决定\n11. 让设计指导而不是操纵开发\n12. 合理地使用技术\n13. 保持可以发布\n14. 提早集成，频繁集成\n15. 提早实现自动化部署\n16. 使用演示获得频繁反馈\n17. 使用短迭代，增量发布\n18. 固定的价格就意味着背叛承诺\n第5章　敏捷反馈\n19. 守护天使\n20. 先用它再实现它\n21. 不同环境，就有不同问题\n22. 自动验收测试\n23. 度量真实的进度\n24. 倾听用户的声音\n第6章　敏捷编码\n25. 代码要清晰地表达意图\n26. 用代码沟通\n27. 动态评估取舍\n28. 增量式编程\n29. 保持简单\n30. 编写内聚的代码\n31. 告知，不要询问\n32. 根据契约进行替换\n第7章　敏捷调试\n33. 记录问题解决日志\n34. 警告就是错误\n35. 对问题各个击破\n36. 报告所有的异常\n37. 提供有用的错误信息\n第8章　敏捷协作\n38. 定期安排会面时间\n39. 架构师必须写代码\n40. 实行代码集体所有制\n41. 成为指导者\n42. 允许大家自己想办法\n43. 准备好后再共享代码\n44. 做代码复查\n45. 及时通报进展与问题\n第9章　尾声：走向敏捷\n9.1　只要一个新的习惯\n9.2　拯救濒临失败的项目\n9.3　引入敏捷：管理者指南\n9.4　引入敏捷：程序员指南\n9.5　结束了吗\n附录A　资源\n索引",
        "ebook_url": "https://read.douban.com/ebook/379531/",
        "pages": "204",
        "images": {
          "small": "https://img1.doubanio.com/spic/s4073509.jpg",
          "large": "https://img1.doubanio.com/lpic/s4073509.jpg",
          "medium": "https://img1.doubanio.com/mpic/s4073509.jpg"
        },
        "alt": "https://book.douban.com/subject/4164024/",
        "id": "4164024",
        "publisher": "人民邮电出版社",
        "isbn10": "7115215537",
        "isbn13": "9787115215536",
        "title": "高效程序员的45个习惯",
        "url": "https://api.douban.com/v2/book/4164024",
        "alt_title": "",
        "author_intro": "Venkat Subramaniam博士\nAgile Developer公司创始人，敏捷开发权威人士。他培训并指导了美国、加拿大、印度和欧洲多国的上千名软件开发人员，并多次在各种大会上发表演讲。他还是.NET Gotchas的作者。可以通过venkats@agiledeveloper.com与他联系。\nAndy Hunt\n敏捷开发权威人士，敏捷宣言的创始人，Pragmatic Programmers公司创始人。除了本书，他还是多本获奖和备受好评图书的合著者，这些图书包括Programming Ruby、《程序员修炼之道——从小工到专家》、《单元测试之道C#版——使用NUnit 》、《单元测试之道Java版——使用JUnit》、《版本控制之道——使用CVS 》等。",
        "summary": "“书中‘切身感受’的内容非常有价值——通过它我们可以做到学有所思，思有所悟，悟有所行。”\n——Nathaniel T. Schutta，《Ajax基础教程》作者\n“此书通过常理和经验，阐述了为什么你应该在项目中使用敏捷方法。最难得的是，这些行之有效的实战经验，竟然从一本书中得到了。”\n——Matthew Johnson，软件工程师\n十年来，软件行业发生了翻天覆地的变化。敏捷方法大行其道，测试和测试驱动开发在很多开发人员的工作中扮演着重要的角色。作为一名程序员，你应该培养怎样的素质，方能对多变的环境应对自如，始终立于不败之地？\n本书简明实用、见解深刻，总结了高效程序员在开发过程中的45个个人习惯、思想观念和方法，有助于开发人员在开发进程、编码工作、开发者态度、项目和团队管理，以及持续学习等5个方面积极修炼。通过学习这些内容，养成这些好的习惯，你可以极大地提升自己的编程实力，更快速、更可靠地交付更高质量的软件，从而成为真正的高效程序员。",
        "ebook_price": "18.00",
        "price": "35.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "be29da49e9a6c4d467e7863df821e1edbc95eb900fd8c3928953b2f64c27caba",
        "file": "高效程序员的45个习惯-敏捷开发修炼之道.epub"
      }
    ]
  },
  {
    "dir_name": "health",
    "name": "健康",
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 1602,
          "average": "7.6",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "伊恩·麦克尼尔",
          "加拿大不列颠哥伦比亚运动医学理事会"
        ],
        "pubdate": "2014-1",
        "tags": [
          {
            "count": 978,
            "name": "跑步",
            "title": "跑步"
          },
          {
            "count": 724,
            "name": "运动",
            "title": "运动"
          },
          {
            "count": 451,
            "name": "健康",
            "title": "健康"
          },
          {
            "count": 307,
            "name": "健身",
            "title": "健身"
          },
          {
            "count": 187,
            "name": "爱上跑步的13周",
            "title": "爱上跑步的13周"
          },
          {
            "count": 153,
            "name": "生活",
            "title": "生活"
          },
          {
            "count": 141,
            "name": "个人管理",
            "title": "个人管理"
          },
          {
            "count": 61,
            "name": "加拿大",
            "title": "加拿大"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/mpic/s27100718.jpg",
        "binding": "平装",
        "translator": [
          "潘小飞"
        ],
        "catalog": "序\n引言\n1 为什么跑步\n2 为跑步作好准备\n3 在路上\n4 让我们开始13周跑步行走计划吧\n5 跑步心理学\n6 在一起跑步的家庭\n7 成为一个更好的跑步者\n8 给身体补充营养\n9 常见的伤病及恢复\n10 为10公里赛事作准备\n11 接下来做什么？\n附录A\n附录B\n附录C",
        "pages": "234",
        "images": {
          "small": "https://img1.doubanio.com/spic/s27100718.jpg",
          "large": "https://img1.doubanio.com/lpic/s27100718.jpg",
          "medium": "https://img1.doubanio.com/mpic/s27100718.jpg"
        },
        "alt": "https://book.douban.com/subject/25750714/",
        "id": "25750714",
        "publisher": "南海出版公司",
        "isbn10": "7544267660",
        "isbn13": "9787544267663",
        "title": "爱上跑步的13周",
        "url": "https://api.douban.com/v2/book/25750714",
        "alt_title": "",
        "author_intro": "伊恩• 麦克尼尔( Ian Macneill )\n长居温哥华，运动员兼作家。通过13周训练计划，让4万加拿大人达成目标。\nSportMedBC(加拿大不列颠哥伦比亚运动医学理事会)\n非盈利性机构，由不列颠哥伦比亚州的600名医学护理人员组成。它立志于推进运动医学、运动科学和运动训练领域的教育和知识普及工作。\n",
        "summary": "★让从不跑步的人迈开双腿，从本书开始跑过一生！\n★坚持跑步的第一步：爱上跑步。\n★在一呼一吸中，感受最纯粹的自我。\n在爱上跑步的13周里，通过13周跑步行走计划，读者可以连续跑10公里而不受伤。\n除了计划，本书还向读者介绍了跑步前的准备工作、跑步心理、跑步营养学、受伤后的恢复方法、准备10公里赛事等方面的知识。\n本书内容涵盖跑步的方方面面，可以解答跑步初学者可能会出现的种种问题。\n本书告诉读者：在人生道路上，每个人也都是一名跑步者。",
        "price": "CNY 32.00",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "68119316164c75ab48645a890fc1115cb5c993e87a5b4147274a9cb5d89ca196",
        "file": "爱上跑步的13周.epub"
      }
    ]
  },
  {
    "dir_name": "java",
    "name": "Java",
    "books": [
      {
        "timestamp": "2017-03-21T13:49:54.356513+00:00",
        "language": "zh",
        "identifier": {
          "uuid": "ff3b5793-06ca-4931-95d8-127e981d2633"
        },
        "contributor": "GitBook",
        "title": "Gradle User Guide 中文版",
        "creator": "DONG",
        "description": "Gradle User Guide 中文版",
        "publisher": "GitBook",
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "2c947bbf2f8e8c57e40ca062b2855b76e99b9c597736102e5b0efcafbc410dc0",
        "file": "gradle用户手册.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 56,
          "average": "8.1",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[日]千叶 滋"
        ],
        "pubdate": "2014-6",
        "tags": [
          {
            "count": 122,
            "name": "编译原理",
            "title": "编译原理"
          },
          {
            "count": 56,
            "name": "编译器",
            "title": "编译器"
          },
          {
            "count": 55,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 46,
            "name": "脚本语言",
            "title": "脚本语言"
          },
          {
            "count": 38,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 23,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 15,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 13,
            "name": "编程艺术",
            "title": "编程艺术"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/mpic/s27306068.jpg",
        "binding": "平装",
        "translator": [
          "陈筱烟"
        ],
        "catalog": "第1部分 　基础篇\n第1天 来，我们一起做些什么吧　　1\n1.1 机器语言与汇编语言　　2\n1.2 解释器与编译器　　3\n1.3 开发语言处理器　　5\n1.4 语言处理器的结构与本书的框架　　6\n第2天 设计程序设计语言　　10\n2.1 麻雀虽小、五脏俱全的程序设计语言　　11\n2.2 句尾的分号　　12\n2.3 含糊不得的语言　　14\n第3天 分割单词　　17\n3.1 Token对象　　18\n3.2 通过正则表达式定义单词　　19\n3.3 借助java.util.regex设计词法分析器　　22\n3.4 词法分析器试运行　　27\n第4天 用于表示程序的对象　　30\n4.1 抽象语法树的定义　　31\n4.2 设计节点类　　34\n4.3 BNF　　38\n4.4 语法分析与抽象语法树　　42\n第5天 设计语法分析器　　44\n5.1 Stone语言的语法　　45\n5.2 使用解析器与组合子　　46\n5.3 由语法分析器生成的抽象语法树　　53\n5.4 测试语法分析器　　59\n第6天 通过解释器执行程序　　62\n6.1 eval方法与环境对象　　63\n6.2 各种类型的eval方法　　65\n6.3 关于GluonJ　　69\n6.4 执行程序　　72\n第7天 添加函数功能　　75\n7.1 扩充语法规则　　76\n7.2 作用域与生存周期　　81\n7.3 执行函数　　83\n7.4 计算斐波那契数　　89\n7.5 为闭包提供支持　　90\n7.6 实现闭包　　92\n第8天 关联Java语言　　95\n8.1 原生函数　　96\n8.2 编写使用原生函数的程序　　98\n第9天 设计面向对象语言　　101\n9.1 设计用于操作类与对象的语法　　102\n9.2 实现类所需的语法规则　　103\n9.3 实现eval方法　　104\n9.4 通过闭包表示对象　　110\n9.5 运行包含类的程序　　114\n第10天 无法割舍的数组　　115\n10.1 扩展语法分析器　　116\n10.2 仅通过修改器来实现数组　　119\n第2部分 　性能优化篇\n第11天 优化变量读写性能　　123\n11.1 通过简单数组来实现环境　　124\n11.2 用于记录全局变量的环境　　127\n11.3 事先确定变量值的存放位置　　130\n11.4 修正eval方法并最终完成性能优化　　134\n第12天 优化对象操作性能　　137\n12.1 减少内存占用　　138\n12.2 能否通过事先查找变量的保存位置来优化性能　　141\n12.3 定义lookup方法　　144\n12.4 整合所有修改并执行　　147\n12.5 内联缓存　　152\n第13天 设计中间代码解释器　　156\n13.1 中间代码与机器语言　　157\n13.2 Stone虚拟机　　158\n13.3 通过栈实现环境　　167\n13.4 寄存器的使用　　170\n13.5 引用变量的值　　173\n13.6 if语句与while语句　　173\n13.7 函数的定义与调用　　175\n13.8 转换为虚拟机器语言　　177\n13.9 通过虚拟机执行　　184\n第14天 为Stone语言添加静态类型支持以优化性能　　187\n14.1 指定变量类型　　188\n14.2 通过数据类型检查发现错误　　193\n14.3 运行程序时执行类型检查　　204\n14.4 对类型省略的变量进行类型推论　　208\n14.5 Java二进制代码转换　　214\n14.6 综合所有修改再次运行程序　　226\n第3部分 　解说篇（自习时间）\n第15天 手工设计词法分析器 229\n15.1 修改自动机　　230\n15.2 自动机程序　　233\n15.3 正则表达式的极限　　235\n第16天 语法分析方式　　236\n16.1 正则表达式与BNF　　237\n16.2 语法分析算法　　238\n16.3 LL语法分析　　239\n16.4 算符优先分析法与自底向上语法分析　　244\n第17天 Parser库的内部结构　　251\n17.1 组合子分析　　252\n17.2 解析器组合子的内部　　252\n第18天 GluonJ的使用方法　　263\n18.1 设定类路径　　264\n18.2 启动设定　　265\n18.3 GluonJ语言　　267\n18.4 功能总结　　268\n第19天 抽象语法树与设计模式　　271\n19.1 理想的设计　　272\n19.2 Interpreter模式　　273\n19.3 Visitor模式　　276\n19.4 使用反射　　282\n19.5 面向切面语言　　284",
        "ebook_url": "https://read.douban.com/ebook/12189111/",
        "pages": "300",
        "images": {
          "small": "https://img1.doubanio.com/spic/s27306068.jpg",
          "large": "https://img1.doubanio.com/lpic/s27306068.jpg",
          "medium": "https://img1.doubanio.com/mpic/s27306068.jpg"
        },
        "alt": "https://book.douban.com/subject/25908672/",
        "id": "25908672",
        "publisher": "人民邮电出版社",
        "isbn10": "7115355649",
        "isbn13": "9787115355645",
        "title": "两周自制脚本语言",
        "url": "https://api.douban.com/v2/book/25908672",
        "alt_title": "",
        "author_intro": "作者简介：\n千叶滋\n东京工业大学研究生院信息技术理工系研究科教授，兼任东京大学研究生院信息技术理工系研究科教授。著有《面向切面入门——从Java语言・面向对象步入AspectJ语言程序设计》《简明Java程序设计——Great Ideas for Java Programming》《GUI库机制——软件设计案例研习》等。\n译者简介：\n陈筱烟\n毕业于复旦大学计算机科学与技术系，主要研究方向为跨设备人机交互理论。从大学时期开始接触Java、JavaScript程序开发，目前对Web应用及智能手机应用开发有浓厚兴趣，并参与Android开发文档翻译项目。业余开发的移动应用在Google Play商店中已有数十万次下载。译作有《JavaScript编程全解》《App，这样设计才好卖》等。",
        "summary": "《两周自制脚本语言》是一本优秀的编译原理入门读物。全书穿插了大量轻松风趣的对话，读者可以随书中的人物一起从最简单的语言解释器开始，逐步添加新功能，最终完成一个支持函数、数组、对象等高级功能的语言编译器。本书与众不同的实现方式不仅大幅简化了语言处理器的复杂度，还有助于拓展读者的视野。\n《两周自制脚本语言》适合对编译原理及语言处理器设计有兴趣的读者以及正在学习相关课程的大中专院校学生。同时，已经学习过相关知识、有一定经验的开发者，也一定能从本书新颖的实现方式中受益良多。",
        "ebook_price": "29.99",
        "series": {
          "id": "34137",
          "title": "自制系列"
        },
        "price": "59.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "90ab81973e8cef423f11524ebc1c77eb9049c557745c47993db279e189e51fae",
        "file": "两周自制脚本语言.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 689,
          "average": "8.9",
          "min": 0
        },
        "subtitle": "JVM高级特性与最佳实践",
        "author": [
          "周志明"
        ],
        "pubdate": "2013-9-1",
        "tags": [
          {
            "count": 660,
            "name": "JVM",
            "title": "JVM"
          },
          {
            "count": 570,
            "name": "Java",
            "title": "Java"
          },
          {
            "count": 428,
            "name": "虚拟机",
            "title": "虚拟机"
          },
          {
            "count": 191,
            "name": "java",
            "title": "java"
          },
          {
            "count": 167,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 139,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 72,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 55,
            "name": "程序设计",
            "title": "程序设计"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s27458236.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "前言\n第一部分走近Java\n第1章走近Java2\n1.1概述2\n1.2Java技术体系3\n1.3Java发展史5\n1.4Java虚拟机发展史9\n1.4.1SunClassicExactVM9\n1.4.2SunHotSpotVM11\n1.4.3SunMobile—EmbeddedVMMeta—CircularVM12\n1.4.4BEAJRockitIBMJ9VM13\n1.4.5AzulVMBEALiquidVM14\n1.4.6ApacheHarmonyGoogleAndroidDalvikVM14\n1.4.7MicrosoftJVM及其他15\n1.5展望Java技术的未来16\n1.5.1模块化17\n1.5.2混合语言17\n1.5.3多核并行19\n1.5.4进一步丰富语法20\n1.5.564位虚拟机21\n1.6实战：自己编译JDK22\n1.6.1获取JDK源码22\n1.6.2系统需求24\n1.6.3构建编译环境25\n1.6.4进行编译26\n1.6.5在IDE工具中进行源码调试31\n1.7本章小结35\n第二部分自动内存管理机制\n第2章Java内存区域与内存溢出异常38\n2.1概述38\n2.2运行时数据区域38\n2.2.1程序计数器39\n2.2.2Java虚拟机栈39\n2.2.3本地方法栈40\n2.2.4Java堆41\n2.2.5方法区41\n2.2.6运行时常量池42\n2.2.7直接内存43\n2.3HotSpot虚拟机对象探秘43\n2.3.1对象的创建44\n2.3.2对象的内存布局47\n2.3.3对象的访问定位48\n2.4实战：OutOfMemoryError异常50\n2.4.1Java堆溢出51\n2.4.2虚拟机栈和本地方法栈溢出53\n2.4.3方法区和运行时常量池溢出56\n2.4.4本机直接内存溢出59\n2.5本章小结60\n第3章垃圾收集器与内存分配策略61\n3.1概述61\n3.2对象已死吗62\n3.2.1引用计数算法62\n3.2.2可达性分析算法64\n3.2.3再谈引用65\n3.2.4生存还是死亡66\n3.2.5回收方法区68\n3.3垃圾收集算法69\n3.3.1标记—清除算法69\n3.3.2复制算法70\n3.3.3标记—整理算法71\n3.3.4分代收集算法72\n3.4HotSpot的算法实现72\n3.4.1枚举根节点72\n3.4.2安全点73\n3.4.3安全区域74\n3.5垃圾收集器75\n3.5.1Serial收集器76\n3.5.2ParNew收集器77\n3.5.3ParallelScavenge收集器79\n3.5.4SerialOld收集器80\n3.5.5ParallelOld收集器80\n3.5.6CMS收集器81\n3.5.7G1收集器84\n3.5.8理解GC日志89\n3.5.9垃圾收集器参数总结90\n3.6内存分配与回收策略91\n3.6.1对象优先在Eden分配91\n3.6.2大对象直接进入老年代93\n3.6.3长期存活的对象将进入老年代95\n3.6.4动态对象年龄判定97\n3.6.5空间分配担保98\n3.7本章小结100\n第4章虚拟机性能监控与故障处理工具101\n4.1概述101\n4.2JDK的命令行工具101\n4.2.1jps：虚拟机进程状况工具104\n4.2.2jstat：虚拟机统计信息监视工具105\n4.2.3jinfo：Java配置信息工具106\n4.2.4jmap：Java内存映像工具107\n4.2.5jhat：虚拟机堆转储快照分析工具108\n4.2.6jstack：Java堆栈跟踪工具109\n4.2.7HSDIS：JIT生成代码反汇编111\n4.3JDK的可视化工具114\n4.3.1JConsole：Java监视与管理控制台115\n4.3.2VisualVM：多合一故障处理工具122\n4.4本章小结131\n第5章调优案例分析与实战132\n5.1概述132\n5.2案例分析132\n5.2.1高性能硬件上的程序部署策略132\n5.2.2集群间同步导致的内存溢出135\n5.2.3堆外内存导致的溢出错误136\n5.2.4外部命令导致系统缓慢137\n5.2.5服务器JVM进程崩溃138\n5.2.6不恰当数据结构导致内存占用过大139\n5.2.7由Windows虚拟内存导致的长时间停顿141\n5.3实战：Eclipse运行速度调优142\n5.3.1调优前的程序运行状态142\n5.3.2升级JDK1.6的性能变化及兼容问题145\n5.3.3编译时间和类加载时间的优化150\n5.3.4调整内存设置控制垃圾收集频率153\n5.3.5选择收集器降低延迟157\n5.4本章小结160\n第三部分虚拟机执行子系统\n第6章类文件结构162\n6.1概述162\n6.2无关性的基石162\n6.3Class类文件的结构164\n6.3.1魔数与Class文件的版本166\n6.3.2常量池167\n6.3.3访问标志173\n6.3.4类索引、父类索引与接口索引集合174\n6.3.5字段表集合175\n6.3.6方法表集合178\n6.3.7属性表集合180\n6.4字节码指令简介196\n6.4.1字节码与数据类型197\n6.4.2加载和存储指令199\n6.4.3运算指令200\n6.4.4类型转换指令202\n6.4.5对象创建与访问指令203\n6.4.6操作数栈管理指令203\n6.4.7控制转移指令204\n6.4.8方法调用和返回指令204\n6.4.9异常处理指令205\n6.4.10同步指令205\n6.5公有设计和私有实现206\n6.6Class文件结构的发展207\n6.7本章小结208\n第7章虚拟机类加载机制209\n7.1概述209\n7.2类加载的时机210\n7.3类加载的过程214\n7.3.1加载214\n7.3.2验证216\n7.3.3准备219\n7.3.4解析220\n7.3.5初始化225\n7.4类加载器227\n7.4.1类与类加载器228\n7.4.2双亲委派模型229\n7.4.3破坏双亲委派模型233\n7.5本章小结235\n第8章虚拟机字节码执行引擎236\n8.1概述236\n8.2运行时栈帧结构236\n8.2.1局部变量表238\n8.2.2操作数栈242\n8.2.3动态连接243\n8.2.4方法返回地址243\n8.2.5附加信息244\n8.3方法调用244\n8.3.1解析244\n8.3.2分派246\n8.3.3动态类型语言支持258\n8.4基于栈的字节码解释执行引擎269\n8.4.1解释执行269\n8.4.2基于栈的指令集与基于寄存器的指令集270\n8.4.3基于栈的解释器执行过程272\n8.5本章小结275\n第9章类加载及执行子系统的案例与实战276\n9.1概述276\n9.2案例分析276\n9.2.1Tomcat：正统的类加载器架构276\n9.2.2OSGi：灵活的类加载器架构279\n9.2.3字节码生成技术与动态代理的实现282\n9.2.4Retrotranslator：跨越JDK版本286\n9.3实战：自己动手实现远程执行功能289\n9.3.1目标290\n9.3.2思路290\n9.3.3实现291\n9.3.4验证298\n9.4本章小结299\n第四部分程序编译与代码优化\n第10章早期（编译期）优化302\n10.1概述302\n10.2Javac编译器303\n10.2.1Javac的源码与调试303\n10.2.2解析与填充符号表305\n10.2.3注解处理器307\n10.2.4语义分析与字节码生成307\n10.3Java语法糖的味道311\n10.3.1泛型与类型擦除311\n10.3.2自动装箱、拆箱与遍历循环315\n10.3.3条件编译317\n10.4实战：插入式注解处理器318\n10.4.1实战目标318\n10.4.2代码实现319\n10.4.3运行与测试326\n10.4.4其他应用案例327\n10.5本章小结328\n第11章晚期（运行期）优化329\n11.1概述329\n11.2HotSpot虚拟机内的即时编译器329\n11.2.1解释器与编译器330\n11.2.2编译对象与触发条件332\n11.2.3编译过程337\n11.2.4查看及分析即时编译结果339\n11.3编译优化技术345\n11.3.1优化技术概览346\n11.3.2公共子表达式消除350\n11.3.3数组边界检查消除351\n11.3.4方法内联352\n11.3.5逃逸分析354\n11.4Java与C/C++的编译器对比356\n11.5本章小结358\n第五部分高效并发\n第12章Java内存模型与线程360\n12.1概述360\n12.2硬件的效率与一致性361\n12.3Java内存模型362\n12.3.1主内存与工作内存363\n12.3.2内存间交互操作364\n12.3.3对于volatile型变量的特殊规则366\n12.3.4对于long和double型变量的特殊规则372\n12.3.5原子性、可见性与有序性373\n12.3.6先行发生原则375\n12.4Java与线程378\n12.4.1线程的实现378\n12.4.2Java线程调度381\n12.4.3状态转换383\n12.5本章小结384\n第13章线程安全与锁优化385\n13.1概述385\n13.2线程安全385\n13.2.1Java语言中的线程安全386\n13.2.2线程安全的实现方法390\n13.3锁优化397\n13.3.1自旋锁与自适应自旋398\n13.3.2锁消除398\n13.3.3锁粗化400\n13.3.4轻量级锁400\n13.3.5偏向锁402\n13.4本章小结403\n附录\n附录A编译Windows版的OpenJDK406\n附录B虚拟机字节码指令表414\n附录CHotSpot虚拟机主要参数表420\n附录D对象查询语言（OQL）简介424\n附录EJDK历史版本轨迹430",
        "ebook_url": "https://read.douban.com/ebook/15233695/",
        "pages": "433",
        "images": {
          "small": "https://img3.doubanio.com/spic/s27458236.jpg",
          "large": "https://img3.doubanio.com/lpic/s27458236.jpg",
          "medium": "https://img3.doubanio.com/mpic/s27458236.jpg"
        },
        "alt": "https://book.douban.com/subject/24722612/",
        "id": "24722612",
        "publisher": "机械工业出版社",
        "isbn10": "7111421906",
        "isbn13": "9787111421900",
        "title": "深入理解Java虚拟机（第2版）",
        "url": "https://api.douban.com/v2/book/24722612",
        "alt_title": "",
        "author_intro": "周志明，资深Java技术专家，对JavaEE企业级应用开发、OSGi、Java虚拟机和工作流等都有深入的研究，并在大量的实践中积累了丰富的经验。尤其精通Java虚拟机，撰写了大量与JVM相关的经典文章，被各大技术社区争相转载，是ITeye等技术社区公认的Java虚拟机方面的领袖人物之一。除本书外，还著有经典著作《深入理解OSGi：Equinox原理、应用与最佳实践》，广获读者好评。现任远光软件股份有限公司开发部总经理兼架构师，先后参与过国家电网、南方电网等多个国家级大型ERP项目的平台架构工作，对软件系统架构也有深刻的认识和体会。",
        "summary": "《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》内容简介：第1版两年内印刷近10次，4家网上书店的评论近4?000条，98%以上的评论全部为5星级的好评，是整个Java图书领域公认的经典著作和超级畅销书，繁体版在台湾也十分受欢迎。第2版在第1版的基础上做了很大的改进：根据最新的JDK 1.7对全书内容进行了全面的升级和补充；增加了大量处理各种常见JVM问题的技巧和最佳实践；增加了若干与生产环境相结合的实战案例；对第1版中的错误和不足之处的修正；等等。第2版不仅技术更新、内容更丰富，而且实战性更强。\n《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》共分为五大部分，围绕内存管理、执行子系统、程序编译与优化、高效并发等核心主题对JVM进行了全面而深入的分析，深刻揭示了JVM的工作原理。\n第一部分从宏观的角度介绍了整个Java技术体系、Java和JVM的发展历程、模块化，以及JDK的编译，这对理解书中后面内容有重要帮助。\n第二部分讲解了JVM的自动内存管理，包括虚拟机内存区域的划分原理以及各种内存溢出异常产生的原因；常见的垃圾收集算法以及垃圾收集器的特点和工作原理；常见虚拟机监控与故障处理工具的原理和使用方法。\n第三部分分析了虚拟机的执行子系统，包括类文件结构、虚拟机类加载机制、虚拟机字节码执行引擎。\n第四部分讲解了程序的编译与代码的优化，阐述了泛型、自动装箱拆箱、条件编译等语法糖的原理；讲解了虚拟机的热点探测方法、HotSpot的即时编译器、编译触发条件，以及如何从虚拟机外部观察和分析JIT编译的数据和结果；\n第五部分探讨了Java实现高效并发的原理，包括JVM内存模型的结构和操作；原子性、可见性和有序性在Java内存模型中的体现；先行发生原则的规则和使用；线程在Java语言中的实现原理；虚拟机实现高效并发所做的一系列锁优化措施。",
        "ebook_price": "25.00",
        "price": "79.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "c1aba608dd82d1890c2046caa38e9ffcd4cfe51251f288e1835db9c17c38937b",
        "file": "深入理解Java虚拟机(第2版).epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 67,
          "average": "8.1",
          "min": 0
        },
        "subtitle": "第3版",
        "author": [
          "李刚"
        ],
        "pubdate": "2014-7-1",
        "tags": [
          {
            "count": 54,
            "name": "Java",
            "title": "Java"
          },
          {
            "count": 19,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 19,
            "name": "入门",
            "title": "入门"
          },
          {
            "count": 12,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 12,
            "name": "编程语言",
            "title": "编程语言"
          },
          {
            "count": 10,
            "name": "java",
            "title": "java"
          },
          {
            "count": 6,
            "name": "李刚",
            "title": "李刚"
          },
          {
            "count": 5,
            "name": "程序设计",
            "title": "程序设计"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s27404471.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "第1章  Java语言概述与开发环境\t1\n1.1  Java语言的发展简史\t2\n1.2  Java的竞争对手及各自优势\t4\n1.2.1  C#简介和优势\t4\n1.2.2  Ruby简介和优势\t5\n1.2.3  Python简介和优势\t5\n1.3  Java程序运行机制\t6\n1.3.1  高级语言的运行机制\t6\n1.3.2  Java程序的运行机制和JVM\t6\n1.4  开发Java的准备\t8\n1.4.1  下载和安装Java 8的JDK\t8\n不是说JVM是运行Java程序的虚拟机吗？那JRE和JVM的关系是怎样的呢？\t8\n为什么不安装公共JRE呢？\t9\n1.4.2  设置PATH环境变量\t10\n为什么选择用户变量？用户变量与系统变量有什么区别？\t11\n1.5  第一个Java程序\t12\n1.5.1  编辑Java源代码\t12\n1.5.2  编译Java程序\t12\n当编译C程序时，不仅需要指定存放目标文件的位置，也需要指定目标文件的文件名，这里使用javac编译Java程序时怎么不需要指定目标文件的文件名呢？\t13\n1.5.3  运行Java程序\t13\n1.5.4  根据CLASSPATH环境变量定位类\t14\n1.6  Java程序的基本规则\t15\n1.6.1  Java程序的组织形式\t15\n1.6.2  Java源文件的命名规则\t16\n1.6.3  初学者容易犯的错误\t17\n1.7  垃圾回收机制\t19\n1.8  何时开始使用IDE工具\t20\n我想学习Java编程，到底是学习Eclipse好，还是学习NetBeans好呢？\t21\n1.9  本章小结\t21\n第2章　理解面向对象\t22\n2.1  面向对象\t23\n2.1.1  结构化程序设计简介\t23\n2.1.2  程序的三种基本结构\t24\n2.1.3  面向对象程序设计简介\t26\n2.1.4  面向对象的基本特征\t27\n2.2  UML（统一建模语言）介绍\t28\n2.2.1  用例图\t30\n2.2.2  类图\t30\n2.2.3  组件图\t32\n2.2.4  部署图\t33\n2.2.5  顺序图\t33\n2.2.6  活动图\t34\n2.2.7  状态机图\t35\n2.3  Java的面向对象特征\t36\n2.3.1  一切都是对象\t36\n2.3.2  类和对象\t36\n2.4  本章小结\t37\n第3章　数据类型和运算符\t38\n3.1  注释\t39\n3.1.1  单行注释和多行注释\t39\n3.1.2  文档注释\t40\nAPI文档是什么?\t40\n为什么要学习查看API文档的方法？\n3.2  标识符和关键字\t46\n3.2.1  分隔符\t46\n3.2.2  标识符规则\t47\n3.2.3  Java关键字\t47\n3.3  数据类型分类\t48\n什么是变量？变量有什么用？\t48\n3.4  基本数据类型\t49\n3.4.1  整型\t49\n3.4.2  字符型\t51\n什么是字符集？\t51\n3.4.3  浮点型\t53\n3.4.4  数值中使用下画线分隔\t54\n3.4.5  布尔型\t54\n3.5  基本类型的类型转换\t55\n3.5.1  自动类型转换\t55\n3.5.2  强制类型转换\t56\n3.5.3  表达式类型的自动提升\t58\n3.6  直接量\t59\n3.6.1  直接量的类型\t59\n3.6.2  直接量的赋值\t59\n3.7  运算符\t60\n3.7.1  算术运算符\t60\n3.7.2  赋值运算符\t63\n3.7.3  位运算符\t63\n3.7.4  扩展后的赋值运算符\t66\n3.7.5  比较运算符\t66\n3.7.6  逻辑运算符\t67\n3.7.7  三目运算符\t68\n3.7.8  运算符的结合性和优先级\t69\n3.8  本章小结\t70\n第4 章　流程控制与数组\t71\n4.1  顺序结构\t72\n4.2  分支结构\t72\n4.2.1  if条件语句\t72\n4.2.2  Java 7增强后的switch分支语句\t76\n4.3  循环结构\t78\n4.3.1  while循环语句\t78\n4.3.2  do while循环语句\t79\n4.3.3  for循环\t80\n4.3.4  嵌套循环\t83\n4.4  控制循环结构\t84\n4.4.1  使用break结束循环\t84\n4.4.2  使用continue忽略本次循环剩下语句\t85\n4.4.3  使用return结束方法\t86\n4.5  数组类型\t86\n4.5.1  理解数组：数组也是一种类型\t86\nint[]是一种类型吗？怎么使用这种类型呢？\t87\n4.5.2  定义数组\t87\n4.5.3  数组的初始化\t88\n能不能只分配内存空间，不赋初始值呢？\t88\n4.5.4  使用数组\t89\n为什么要我记住这些异常信息？\t89\n4.5.5  foreach循环\t90\n4.6  深入数组\t91\n4.6.1  内存中的数组\t91\n为什么有栈内存和堆内存之分？\t92\n4.6.2  基本类型数组的初始化\t94\n4.6.3  引用类型数组的初始化\t95\n4.6.4  没有多维数组\t97\n我是否可以让图4.13中灰色覆盖的数组元素再次指向另一个数组？这样不就可以扩展成三维数组，甚至扩展成更多维的数组吗？\t98\n4.6.5  Java 8增强的工具类：Arrays\t99\n4.6.6  数组的应用举例\t102\n4.7  本章小结\t105\n本章练习\t105\n第5 章　面向对象（上）\t106\n5.1  类和对象\t107\n5.1.1  定义类\t107\n构造器不是没有返回值吗？为什么不能用void声明呢？\t109\n5.1.2  对象的产生和使用\t110\n5.1.3  对象、引用和指针\t110\n5.1.4  对象的this引用\t111\n5.2  方法详解\t115\n5.2.1  方法的所属性\t115\n5.2.2  方法的参数传递机制\t116\n5.2.3  形参个数可变的方法\t119\n5.2.4  递归方法\t120\n5.2.5  方法重载\t122\n为什么方法的返回值类型不能用于区分重载的方法？\t122\n5.3  成员变量和局部变量\t123\n5.3.1  成员变量和局部变量\t123\n5.3.2  成员变量的初始化和内存中的运行机制\t126\n5.3.3  局部变量的初始化和内存中的\n运行机制\t128\n5.3.4  变量的使用规则\t129\n5.4  隐藏和封装\t130\n5.4.1  理解封装\t130\n5.4.2  使用访问控制符\t130\n5.4.3  package、import和import static\t133\n5.4.4  Java的常用包\t138\n5.5  深入构造器\t138\n5.5.1  使用构造器执行初始化\t138\n构造器是创建Java对象的途径，是不是说构造器完全负责创建Java对象？\t139\n5.5.2  构造器重载\t139\n为什么要用this来调用另一个重载的构造器？我把另一个构造器里的代码复制、粘贴到这个构造器里不就可以了吗？\t141\n5.6  类的继承\t141\n5.6.1  继承的特点\t141\n5.6.2  重写父类的方法\t142\n5.6.3  super限定\t144\n5.6.4  调用父类构造器\t146\n为什么我创建Java对象时从未感觉到java.lang. Object类的构造器被调用过？\t148\n5.7  多态\t148\n5.7.1  多态性\t148\n5.7.2  引用变量的强制类型转换\t150\n5.7.3  instanceof运算符\t151\n5.8  继承与组合\t152\n5.8.1  使用继承的注意点\t152\n5.8.2  利用组合实现复用\t153\n使用组合关系来实现复用时，需要创建两个Animal对象，是不是意味着使用组合关系时系统开销更大？\t156\n5.9  初始化块\t156\n5.9.1  使用初始化块\t156\n5.9.2  初始化块和构造器\t158\n5.9.3  静态初始化块\t159\n5.10  本章小结\t161\n第6 章　面向对象（下）\t162\n6.1  Java 8增强的包装类\t163\nJava为什么要对这些数据进行缓存呢?\t166\n6.2  处理对象\t167\n6.2.1  打印对象和toString方法\t167\n6.2.2  ==和equals方法\t169\n上面程序中判断obj是否为Person类的实例时，为何不用obj instanceof Person来判断呢？\t172\n6.3  类成员\t172\n6.3.1  理解类成员\t172\n6.3.2  单例（Singleton）类\t173\n6.4  final修饰符\t174\n6.4.1  final成员变量\t175\n6.4.2  final局部变量\t176\n6.4.3  final修饰基本类型变量和引用类型变量的区别\t177\n6.4.4  可执行“宏替换”的final变量\t178\n6.4.5  final方法\t180\n6.4.6  final类\t180\n6.4.7  不可变类\t181\n6.4.8  缓存实例的不可变类\t183\n6.5  抽象类\t186\n6.5.1  抽象方法和抽象类\t186\n6.5.2  抽象类的作用\t189\n6.6  Java 8改进的接口\t190\n6.6.1  接口的概念\t190\n6.6.2  Java 8中接口的定义\t190\n6.6.3  接口的继承\t193\n6.6.4  使用接口\t193\n6.6.5  接口和抽象类\t195\n6.6.6  面向接口编程\t195\n6.7  内部类\t199\n6.7.1  非静态内部类\t199\n非静态内部类对象和外部类对象的关系是怎样的？\t203\n6.7.2  静态内部类\t203\n为什么静态内部类的实例方法也不能访问外部类的实例属性呢？\t204\n接口里是否能定义内部接口？\t205\n6.7.3  使用内部类\t205\n既然内部类是外部类的成员，那么是否可以为外部类定义子类，在子类中再定义一个内部类来重写其父类中的内部类呢？\t208\n6.7.4  局部内部类\t208\n6.7.5  Java 8改进的匿名内部类\t209\n6.8  Java 8新增的Lambda表达式\t212\n6.8.1  Lambda表达式入门\t212\n6.8.2  Lambda表达式与函数式接口\t214\n6.8.3  方法引用与构造器引用\t216\n6.8.4  Lambda表达式与匿名内部类的联系和区别\t218\n6.8.5  使用Lambda表达式调用Arrays的类方法\t219\n6.9  枚举类\t220\n6.9.1  手动实现枚举类\t220\n6.9.2  枚举类入门\t221\n6.9.3  枚举类的成员变量、方法和构造器\t222\n6.9.4  实现接口的枚举类\t224\n枚举类不是用final修饰了吗？怎么还能派生子类呢？\t225\n6.9.5  包含抽象方法的枚举类\t225\n6.10  对象与垃圾回收\t226\n6.10.1  对象在内存中的状态\t227\n6.10.2  强制垃圾回收\t227\n6.10.3  finalize方法\t229\n6.10.4  对象的软、弱和虚引用\t230\n6.11  修饰符的适用范围\t233\n6.12  使用JAR文件\t234\n6.12.1  jar命令详解\t235\n6.12.2  创建可执行的JAR包\t236\n6.12.3  关于JAR包的技巧\t237\n6.13  本章小结\t238\n本章练习\t238\n第7 章　Java基础类库\t239\n7.1  与用户互动\t240\n7.1.1  运行Java程序的参数\t240\n7.1.2  使用Scanner获取键盘输入\t241\n7.2  系统相关\t243\n7.2.1  System类\t243\n7.2.2  Runtime类\t245\n7.3  常用类\t246\n7.3.1  Object类\t246\n7.3.2  Java 7新增的Objects类\t247\n7.3.3  String、StringBuffer和\nStringBuilder类\t248\n7.3.4  Math类\t251\n7.3.5  Java 7的ThreadLocalRandom与Random\t253\n7.3.6  BigDecimal类\t255\n7.4  Java 8的日期、时间类\t257\n7.4.1  Date类\t257\n7.4.2  Calendar类\t258\n7.4.3  Java 8新增的日期、时间包\t261\n7.5  正则表达式\t263\n7.5.1  创建正则表达式\t263\n7.5.2  使用正则表达式\t266\n7.6  国际化与格式化\t270\n7.6.1  Java国际化的思路\t270\n7.6.2  Java支持的国家和语言\t270\n7.6.3  完成程序国际化\t271\n7.6.4  使用MessageFormat处理包含占位符的字符串\t273\n7.6.5  使用类文件代替资源文件\t274\n7.6.6  使用NumberFormat格式化数字\t274\n7.6.7  使用DateFormat格式化日期、时间\t276\n7.6.8  使用SimpleDateFormat格式化日期\t277\n7.7  Java 8新增的日期、时间格式器\t278\n7.7.1  使用DateTimeFormatter完成格式化\t278\n7.7.2  使用DateTimeFormatter解析字符串\t279\n7.8  本章小结\t280\n本章练习\t280\n第8 章　Java集合\t281\n8.1  Java集合概述\t282\n8.2  Collection和Iterator接口\t283\n8.2.1  使用Lambda表达式遍历集合\t285\n8.2.2  使用Java 8增强的Iterator遍历集合元素\t286\n8.2.3  使用Lambda表达式遍历Iterator\t287\n8.2.4  使用foreach循环遍历集合元素\t288\n8.2.5  使用Java 8新增的Predicate操作集合\t288\n8.2.6  使用Java 8新增的Stream操作集合\t289\n8.3  Set集合\t291\n8.3.1  HashSet类\t292\nhashCode()方法对于HashSet是不是十分重要？\t293\n8.3.2  LinkedHashSet类\t295\n8.3.3  TreeSet类\t296\n8.3.4  EnumSet类\t302\n8.3.5  各Set实现类的性能分析\t303\n8.4  List集合\t304\n8.4.1  Java 8改进的List接口和ListIterator接口\t304\n8.4.2  ArrayList和Vector实现类\t307\n8.4.3  固定长度的List\t308\n8.5  Queue集合\t308\n8.5.1  PriorityQueue实现类\t309\n8.5.2  Deque接口与ArrayDeque实现类\t309\n8.5.3  LinkedList实现类\t311\n8.5.4  各种线性表的性能分析\t312\n8.6  Java 8增强的Map集合\t313\n8.6.1  Java 8为Map新增的方法\t315\n8.6.2  Java 8改进的HashMap和Hashtable实现类\t316\n8.6.3  LinkedHashMap实现类\t319\n8.6.4  使用Properties读写属性文件\t319\n8.6.5  SortedMap接口和TreeMap实现类\t320\n8.6.6  WeakHashMap实现类\t323\n8.6.7  IdentityHashMap实现类\t323\n8.6.8  EnumMap实现类\t324\n8.6.9  各Map实现类的性能分析\t325\n8.7  HashSet和HashMap的性能选项\t325\n8.8  操作集合的工具类：Collections\t326\n8.8.1  排序操作\t326\n8.8.2  查找、替换操作\t329\n8.8.3  同步控制\t330\n8.8.4  设置不可变集合\t330\n8.9  烦琐的接口：Enumeration\t331\n8.10  本章小结\t332\n本章练习\t332\n第9 章　泛型\t333\n9.1  泛型入门\t334\n9.1.1  编译时不检查类型的异常\t334\n9.1.2  使用泛型\t334\n9.1.3  Java 7泛型的“菱形”语法\t335\n9.2  深入泛型\t336\n9.2.1　定义泛型接口、类\t336\n9.2.2  从泛型类派生子类\t338\n9.2.3  并不存在泛型类\t339\n9.3  类型通配符\t339\n9.3.1  使用类型通配符\t341\n9.3.2  设定类型通配符的上限\t341\n9.3.3  设定类型形参的上限\t343\n9.4  泛型方法\t344\n9.4.1  定义泛型方法\t344\n9.4.2  泛型方法和类型通配符的区别\t346\n9.4.3  Java 7的“菱形”语法与泛型构造器\t347\n9.4.4  设定通配符下限\t348\n9.4.5  泛型方法与方法重载\t350\n9.4.6  Java 8改进的类型推断\t351\n9.5  擦除和转换\t352\n9.6  泛型与数组\t353\n9.7  本章小结\t355\n第10 章　异常处理\t356\n10.1  异常概述\t357\n10.2  异常处理机制\t358\n10.2.1  使用try...catch捕获异常\t358\n10.2.2  异常类的继承体系\t360\n10.2.3  Java 7提供的多异常捕获\t362\n10.2.4  访问异常信息\t363\n10.2.5  使用finally回收资源\t364\n10.2.6  异常处理的嵌套\t366\n10.2.7  Java 7的自动关闭资源的try语句\t366\n10.3  Checked异常和Runtime异常体系\t368\n10.3.1  使用throws声明抛出异常\t368\n10.4  使用throw抛出异常\t370\n10.4.1  抛出异常\t370\n10.4.2  自定义异常类\t371\n10.4.3  catch和throw同时使用\t372\n10.4.4  Java 7增强的throw语句\t373\n10.4.5  异常链\t374\n10.5  Java的异常跟踪栈\t376\n10.6  异常处理规则\t377\n10.6.1  不要过度使用异常\t378\n10.6.2  不要使用过于庞大的try块\t379\n10.6.3  避免使用Catch All语句\t379\n10.6.4  不要忽略捕获到的异常\t379\n10.7  本章小结\t380\n本章练习\t380\n第11 章　AWT编程\t381\n11.1  GUI（图形用户界面）和AWT\t382\n11.2  AWT容器\t383\n11.3  布局管理器\t386\n11.3.1  FlowLayout布局管理器\t386\n11.3.2  BorderLayout布局管理器\t387\nBorderLayout最多只能放置5个组件吗？那它也太不实用了吧？\t388\n11.3.3  GridLayout布局管理器\t389\n11.3.4  GridBagLayout布局管理器\t390\n11.3.5  CardLayout布局管理器\t392\n11.3.6  绝对定位\t394\n11.3.7  BoxLayout布局管理器\t395\n图11.15和图11.16显示的所有按钮都紧挨在一起，如果希望像FlowLayout、GridLayout等布局管理器那样指定组件的间距应该怎么办？\t396\n11.4  AWT常用组件\t397\n11.4.1  基本组件\t397\n11.4.2  对话框（Dialog）\t399\n11.5  事件处理\t401\n11.5.1  Java事件模型的流程\t401\n11.5.2  事件和事件监听器\t403\n11.5.3  事件适配器\t407\n11.5.4  使用内部类实现监听器\t408\n11.5.5  使用外部类实现监听器\t408\n11.5.6  类本身作为事件监听器类\t409\n11.5.7  匿名内部类实现监听器\t410\n11.6  AWT菜单\t410\n11.6.1  菜单条、菜单和菜单项\t410\n11.6.2  右键菜单\t412\n为什么即使我没有给多行文本域编写右键菜单，但当我在多行文本域上单击右键时也一样会弹出右键菜单？\t414\n11.7  在AWT中绘图\t414\n11.7.1  画图的实现原理\t414\n11.7.2  使用Graphics类\t415\n11.8  处理位图\t419\n11.8.1  Image抽象类和BufferedImage实现类\t419\n11.8.2  使用ImageIO输入/输出位图\t421\n11.9  剪贴板\t425\n11.9.1  数据传递的类和接口\t426\n11.9.2  传递文本\t426\n11.9.3  使用系统剪贴板传递图像\t428\n11.9.4  使用本地剪贴板传递对象引用\t430\n11.9.5  通过系统剪贴板传递Java对象\t433\n11.10  拖放功能\t435\n11.10.1  拖放目标\t436\n11.10.2  拖放源\t439\n11.11  本章小结\t440\n本章练习\t440\n第12 章　Swing编程\t441\n12.1  Swing概述\t442\n12.2  Swing基本组件的用法\t443\n12.2.1  Java 7 的Swing组件层次\t443\n12.2.2  AWT组件的Swing实现\t444\n为什么单击Swing多行文本域时不是弹出像AWT多行文本域中的右键菜单？\t450\n12.2.3  为组件设置边框\t450\n12.2.4  Swing组件的双缓冲和键盘驱动\t452\n12.2.5  使用JToolBar创建工具条\t453\n12.2.6  使用JFileChooser和Java 7增强的JColorChooser\t455\n12.2.7  使用JOptionPane\t462\n12.3  Swing中的特殊容器\t467\n12.3.1  使用JSplitPane\t467\n12.3.2  使用JTabbedPane\t469\n12.3.3  使用JLayeredPane、JdesktopPane和JInternalFrame\t473\n12.4  Swing简化的拖放功能\t480\n12.5  Java 7新增的Swing功能\t481\n12.5.1  使用JLayer装饰组件\t481\n12.5.2  创建透明、不规则形状窗口\t487\n12.6  使用JProgressBar、ProgressMonitor和BoundedRangeModel创建进度条\t489\n12.6.1  创建进度条\t489\n12.6.2  创建进度对话框\t492\n12.7  使用JSlider和BoundedRangeModel创建滑动条\t494\n12.8  使用JSpinner和SpinnerModel创建微调控制器\t497\n12.9  使用JList、JComboBox创建列表框\t500\n12.9.1  简单列表框\t500\n12.9.2  不强制存储列表项的ListModel和ComboBoxModel\t503\n12.9.3  强制存储列表项的DefaultListModel和DefaultComboBoxModel\t506\n为什么JComboBox提供了添加、删除列表项的方法？而JList没有提供添加、删除列表项的方法呢？\t508\n12.9.4  使用ListCellRenderer改变列表项外观\t508\n12.10  使用JTree和TreeModel创建树\t510\n12.10.1  创建树\t511\n12.10.2  拖动、编辑树节点\t513\n12.10.3  监听节点事件\t517\n12.10.4  使用DefaultTreeCellRenderer改变节点外观\t519\n12.10.5  扩展DefaultTreeCellRenderer改变节点外观\t520\n12.10.6  实现TreeCellRenderer改变节点外观\t523\n12.11  使用JTable和TableModel创建表格\t524\n12.11.1  创建表格\t525\n我们指定的表格数据、表格列标题都是Object类型的数组，JTable如何显示这些Object对象？\t525\n12.11.2  TableModel和监听器\t530\n12.11.3  TableColumnModel和监听器\t534\n12.11.4  实现排序\t537\n12.11.5  绘制单元格内容\t540\n12.11.6  编辑单元格内容\t543\n12.12  使用JFormattedTextField和JtextPane创建格式文本\t546\n12.12.1  监听Document的变化\t547\n12.12.2  使用JPasswordField\t549\n12.12.3  使用JFormattedTextField\t549\n12.12.4  使用JEditorPane\t557\n12.12.5  使用JTextPane\t557\n12.13  本章小结\t564\n本章练习\t564\n第13 章　MySQL数据库与JDBC编程\t565\n13.1  JDBC基础\t566\n13.1.1  JDBC简介\t566\n13.1.2  JDBC驱动程序\t567\n13.2  SQL语法\t568\n13.2.1  安装数据库\t568\n13.2.2  关系数据库基本概念和MySQL基本命令\t570\n13.2.3  SQL语句基础\t572\n13.2.4  DDL语句\t573\n13.2.5  数据库约束\t577\n13.2.6  索引\t584\n13.2.7  视图\t585\n13.2.8  DML语句语法\t585\n13.2.9  单表查询\t588\n13.2.10  数据库函数\t592\n13.2.11  分组和组函数\t594\n13.2.12  多表连接查询\t596\n13.2.13  子查询\t599\n13.2.14  集合运算\t601\n13.3  JDBC的典型用法\t602\n13.3.1  JDBC 4.2常用接口和类简介\t602\n13.3.2  JDBC编程步骤\t604\n前面给出的仅仅是MySQL和Oracle两种数据库的驱动，我看不出驱动类字符串有什么规律啊。如果我希望使用其他数据库，那怎么找到其他数据库的驱动类呢？\t604\n13.4  执行SQL语句的方式\t607\n13.4.1  使用Java 8新增的executeLargeUpdate方法执行DDL和DML语句\t607\n13.4.2  使用execute方法执行SQL语句\t608\n13.4.3  使用PreparedStatement执行SQL语句\t610\n13.4.4  使用CallableStatement调用存储过程\t614\n13.5  管理结果集\t615\n13.5.1  可滚动、可更新的结果集\t615\n13.5.2  处理Blob类型数据\t617\n13.5.3  使用ResultSetMetaData分析结果集\t622\n13.6  Java 7的RowSet 1.1\t624\n13.6.1  Java 7新增的RowSetFactory与RowSet\t625\n13.6.2  离线RowSet\t627\n13.6.3  离线RowSet的查询分页\t629\n13.7  事务处理\t630\n13.7.1  事务的概念和MySQL事务支持\t630\n13.7.2  JDBC的事务支持\t632\n13.7.3  Java 8增强的批量更新\t634\n13.8  分析数据库信息\t635\n13.8.1  使用DatabaseMetaData分析数据库信息\t635\n13.8.2  使用系统表分析数据库信息\t636\n13.8.3  选择合适的分析方式\t637\n13.9  使用连接池管理连接\t638\n13.9.1  DBCP数据源\t638\n13.9.2  C3P0数据源\t639\n13.10  本章小结\t640\n本章练习\t640\n第14 章　Annotation（注释）\t641\n14.1  基本Annotation\t642\n14.1.1  限定重写父类方法：@Override\t642\n14.1.2  标示已过时：@Deprecated\t643\n14.1.3  抑制编译器警告：@SuppressWarnings\t644\n14.1.4  Java 7的“堆污染”警告与@SafeVarargs\t644\n14.1.5  Java 8的函数式接口与@FunctionalInterface\t645\n14.2  JDK的元Annotation\t646\n14.2.1  使用@Retention\t646\n14.2.2  使用@Target\t647\n14.2.3  使用@Documented\t647\n14.2.4  使用@Inherited\t648\n14.3  自定义Annotation\t649\n14.3.1  定义Annotation\t649\n14.3.2  提取Annotation信息\t650\n14.3.3  使用Annotation的示例\t652\n14.3.4  Java 8新增的重复注解\t656\n14.3.5  Java 8新增的Type Annotation\t658\n14.4  编译时处理Annotation\t659\n14.5  本章小结\t663\n第15 章　输入/输出\t664\n15.1  File类\t665\n15.1.1  访问文件和目录\t665\n15.1.2  文件过滤器\t667\n15.2  理解Java的IO流\t668\n15.2.1  流的分类\t668\n15.2.2  流的概念模型\t669\n15.3  字节流和字符流\t670\n15.3.1  InputStream和Reader\t670\n15.3.2  OutputStream和Writer\t672\n15.4  输入/输出流体系\t673\n15.4.1  处理流的用法\t674\n15.4.2  输入/输出流体系\t674\n15.4.3  转换流\t677\n怎么没有把字符流转换成字节流的转换流呢？\t677\n15.4.4  推回输入流\t678\n15.5  重定向标准输入/输出\t679\n15.6  Java虚拟机读写其他进程的数据\t680\n15.7  RandomAccessFile\t682\n15.8  对象序列化\t686\n15.8.1  序列化的含义和意义\t686\n15.8.2  使用对象流实现序列化\t686\n15.8.3  对象引用的序列化\t688\n15.8.4  自定义序列化\t692\n15.8.5  另一种自定义序列化机制\t696\n15.8.6  版本\t698\n15.9  NIO\t699\n15.9.1  Java新IO概述\t699\n15.9.2  使用Buffer\t699\n15.9.3  使用Channel\t702\n15.9.4  字符集和Charset\t705\n二进制序列与字符之间如何对应呢？\t706\n15.9.5  文件锁\t707\n15.10  Java 7的NIO.2\t709\n15.10.1  Path、Paths和Files核心API\t709\n15.10.2  使用FileVisitor遍历文件和目录\t710\n15.10.3  使用WatchService监控文件变化\t711\n15.10.4  访问文件属性\t712\n15.11  本章小结\t714\n本章练习\t714\n第16 章　多线程\t715\n16.1  线程概述\t716\n16.1.1  线程和进程\t716\n16.1.2  多线程的优势\t717\n16.2  线程的创建和启动\t718\n16.2.1  继承Thread类创建线程类\t718\n16.2.2  实现Runnable接口创建线程类\t719\n16.2.3  使用Callable和Future创建线程\t720\n16.2.4  创建线程的三种方式对比\t722\n16.3  线程的生命周期\t722\n16.3.1  新建和就绪状态\t722\n16.3.2  运行和阻塞状态\t724\n16.3.3  线程死亡\t725\n16.4  控制线程\t726\n16.4.1  join线程\t726\n16.4.2  后台线程\t727\n16.4.3  线程睡眠：sleep\t728\n16.4.4  线程让步：yield\t729\n16.4.5  改变线程优先级\t730\n16.5  线程同步\t731\n16.5.1  线程安全问题\t731\n16.5.2  同步代码块\t733\n16.5.3  同步方法\t735\n16.5.4  释放同步监视器的锁定\t737\n16.5.5  同步锁（Lock）\t737\n16.5.6  死锁\t739\n16.6  线程通信\t741\n16.6.1  传统的线程通信\t741\n16.6.2  使用Condition控制线程通信\t744\n16.6.3  使用阻塞队列（BlockingQueue）控制线程通信\t746\n16.7  线程组和未处理的异常\t749\n16.8  线程池\t752\n16.8.1  Java 8改进的线程池\t752\n16.8.2  Java 8增强的ForkJoinPool\t754\n16.9  线程相关类\t757\n16.9.1  ThreadLocal类\t757\n16.9.2  包装线程不安全的集合\t759\n16.9.3  线程安全的集合类\t759\n16.10  本章小结\t760\n第17 章　网络编程\t761\n17.1  网络编程的基础知识\t762\n17.1.1  网络基础知识\t762\n17.1.2  IP地址和端口号\t763\n17.2  Java的基本网络支持\t764\n17.2.1  使用InetAddress\t764\n17.2.2  使用URLDecoder和URLEncoder\t765\n17.2.3  URL、URLConnection和URLPermission\t766\n17.3  基于TCP协议的网络编程\t772\n17.3.1  TCP协议基础\t772\n17.3.2  使用ServerSocket创建TCP服务器端\t773\n17.3.3  使用Socket进行通信\t773\n17.3.4  加入多线程\t776\n17.3.5  记录用户信息\t778\n17.3.6  半关闭的Socket\t785\n17.3.7  使用NIO实现非阻塞Socket通信\t786\n17.3.8  使用Java 7的AIO实现非阻塞通信\t792\n上面程序中好像没用到④⑤号代码的get()方法的返回值，这两个地方不调用get()方法行吗？\t795\n17.4  基于UDP协议的网络编程\t798\n17.4.1  UDP协议基础\t799\n17.4.2  使用DatagramSocket发送、接收数据\t799\n17.4.3  使用MulticastSocket实现多点广播\t803\n17.5  使用代理服务器\t813\n17.5.1  直接使用Proxy创建连接\t813\n17.5.2  使用ProxySelector自动选择代理服务器\t814\n17.6  本章小结\t817\n本章练习\t817\n第18 章　类加载机制与反射\t818\n18.1  类的加载、连接和初始化\t819\n18.1.1  JVM和类\t819\n18.1.2  类的加载\t820\n18.1.3  类的连接\t821\n18.1.4  类的初始化\t821\n18.1.5  类初始化的时机\t822\n18.2  类加载器\t823\n18.2.1  类加载器简介\t823\n18.2.2  类加载机制\t824\n18.2.3  创建并使用自定义的类加载器\t826\n18.2.4  URLClassLoader类\t829\n18.3  通过反射查看类信息\t830\n18.3.1  获得Class对象\t830\n18.3.2  从Class中获取信息\t831\n18.3.3  Java 8新增的方法参数反射\t835\n18.4  使用反射生成并操作对象\t836\n18.4.1  创建对象\t836\n18.4.2  调用方法\t838\n18.4.3  访问成员变量值\t840\n18.4.4  操作数组\t841\n18.5  使用反射生成JDK动态代理\t842\n18.5.1  使用Proxy和InvocationHandler创建动态代理\t843\n18.5.2  动态代理和AOP\t844\n18.6  反射和泛型\t848\n18.6.1  泛型和Class类\t848\n18.6.2  使用反射来获取泛型信息\t850\n18.7  本章小结\t851\n本章练习\t851",
        "pages": "851",
        "images": {
          "small": "https://img3.doubanio.com/spic/s27404471.jpg",
          "large": "https://img3.doubanio.com/lpic/s27404471.jpg",
          "medium": "https://img3.doubanio.com/mpic/s27404471.jpg"
        },
        "alt": "https://book.douban.com/subject/25959184/",
        "id": "25959184",
        "publisher": "电子工业出版社",
        "isbn10": "7121236699",
        "isbn13": "9787121236693",
        "title": "疯狂Java讲义",
        "url": "https://api.douban.com/v2/book/25959184",
        "alt_title": "",
        "author_intro": "李刚，十多年软件行业开发从业经验，疯狂软件教育中心教学总监。\n疯狂Java实训营创始人，疯狂Java体系原创图书作者。\n广东技术师范学院计算机科学系兼职副教授，51cto专家门诊特邀嘉宾。\n培训的学生已在华为、IBM、阿里软件、网易、电信盈科等名企就职。\n国内著名高端IT技术作家，已出版《疯狂Java讲义》《疯狂Android讲义》《轻量级Java EE企业应用实战》《疯狂iOS讲义》《疯狂Ajax讲义》《疯狂XML讲义》《经典Java EE企业应用实战》《疯狂HTML 5/CSS 3/JavaScript讲义》《Struts 2.x权威指南》等著作。其中疯狂Java体系图书经多年沉淀，赢得极高的市场认同，多次重印成为超级畅销书，并被多所“985”“211”院校选作教材。部分图书已被翻译成繁体中文版、授权到台湾地区。",
        "summary": "《疯狂Java讲义（第3版）(含CD光盘1张)》是《疯狂Java讲义》的第3版，第3版保持了前两版系统、全面、讲解浅显、细致的特性，全面新增介绍了Java 8的新特性，《疯狂Java讲义（第3版）(含CD光盘1张)》大部分示例程序都采用Lambda表达式、流式API进行了改写，因此务必使用Java 8的JDK来编译、运行。\n《疯狂Java讲义（第3版）(含CD光盘1张)》深入介绍了Java编程的相关方面，全书内容覆盖了Java的基本语法结构、Java的面向对象特征、Java集合框架体系、Java泛型、异常处理、Java GUI编程、JDBC数据库编程、Java注释、Java的IO流体系、Java多线程编程、Java网络通信编程和Java反射机制。覆盖了java.lang、java.util、java.text、java.io和java.nio、java.sql、java.awt、javax.swing包下绝大部分类和接口。本书全面介绍了Java 8的新的接口语法、Lambda表达式、方法引用、构造器引用、函数式编程、流式编程、新的日期、时间API、并行支持、改进的类型推断、重复注解、JDBC 4.2新特性等新特性。\n与前两版类似，《疯狂Java讲义（第3版）(含CD光盘1张)》并不单纯从知识角度来讲解Java，而是从解决问题的角度来介绍Java语言，所以《疯狂Java讲义（第3版）(含CD光盘1张)》中涉及大量实用案例开发：五子棋游戏、梭哈游戏、仿QQ的游戏大厅、MySQL企业管理器、仿EditPlus的文本编辑器、多线程、断点下载工具、Spring框架的IoC容器……这些案例既能让读者巩固每章的知识，又可以让读者学以致用，激发编程自豪感，进而引爆内心的编程激情。《疯狂Java讲义（第3版）(含CD光盘1张)》光盘里包含书中所有示例的代码和《疯狂Java实战演义》的所有项目代码，这些项目可以作为《疯狂Java讲义（第3版）(含CD光盘1张)》课后练习的“非标准答案”，如果读者需要获取关于课后习题的解决方法、编程思路，可以登录http://www.crazyit.org站点与笔者及《疯狂Java讲义（第3版）(含CD光盘1张)》庞大的读者群相互交流。\n《疯狂Java讲义（第3版）(含CD光盘1张)》为所有打算深入掌握Java编程的读者而编写，适合各种层次的Java学习者和工作者阅读，也适合作为大学教育、培训机构的Java教材。但如果只是想简单涉猎Java，则本书过于庞大，不适合阅读。",
        "price": "109.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "e680864e01bc79cc0d353f1769e222fd85387ca044c86d932e3b54e459d58836",
        "file": "疯狂Java讲义-第3版.pdf"
      },
      {
        "author": "雨林木风",
        "creation_date": "D:20101211221454+08'00'",
        "creator": "Adobe Acrobat Pro 9.3.1",
        "mod_date": "D:20101211221454+08'00'",
        "producer": "Adobe Acrobat Pro 9.3.1",
        "meta_type": "pdf",
        "type": "pdf",
        "sha_256": "9e273db1c2687209feb0a62aa741a4b6a5b641504361cfe74863cf021dd5fd48",
        "file": "疯狂java实战演义李刚.pdf"
      }
    ]
  },
  {
    "dir_name": "javascript",
    "name": "JavaScript",
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 37,
          "average": "8.1",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "李 喆"
        ],
        "pubdate": "2014-10",
        "tags": [
          {
            "count": 18,
            "name": "chrome",
            "title": "chrome"
          },
          {
            "count": 17,
            "name": "JavaScript",
            "title": "JavaScript"
          },
          {
            "count": 15,
            "name": "chrome拓展及应用",
            "title": "chrome拓展及应用"
          },
          {
            "count": 12,
            "name": "浏览器扩展",
            "title": "浏览器扩展"
          },
          {
            "count": 7,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 4,
            "name": "前端技术",
            "title": "前端技术"
          },
          {
            "count": 4,
            "name": "前端",
            "title": "前端"
          },
          {
            "count": 4,
            "name": "crx",
            "title": "crx"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/mpic/s27461678.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "第1章　初步接触Chrome扩展及应用开发　 001\n1.1　 认识Chrome扩展及应用　 002\n1.2　 应用与扩展的区别　 003\n1.3　 我的第一个Chrome扩展　 004\n1.4　 Manifest文件格式　 008\n1.5　 DOM简述　 011\n1.6　 调试方法与代码质量　 013\n第2章　Chrome扩展基础　 016\n2.1　 操作用户正在浏览的页面　 017\n2.2　 跨域请求　 020\n2.3　 常驻后台　 025\n2.4　 带选项页面的扩展　 027\n2.5　 扩展页面间的通信　 032\n2.6　 存储数据　 034\n2.7　 i18n　 037\n第3章　Chrome扩展的UI界面　 039\n3.1　 CSS简述　 040\n3.1.1　 默认样式及box模型　 040\n3.1.2　 元素定位　 042\n3.1.3　 字体及背景颜色　 043\n3.2　 Browser　 Actions　 045\n3.2.1　 图标　 045\n3.2.2　 popup页面　 047\n3.2.3　 标题和badge　 049\n3.3　 右键菜单　 051\n3.4　 桌面提醒　 056\n3.5　 omnibox　 058\n3.6　 Page　 Actions　 061\n第4章　管理你的浏览器　 062\n4.1　 书签　 063\n4.1.1　 创建书签　 064\n4.1.2　 创建书签分类　 064\n4.1.3　 调整书签位置　 065\n4.1.4　 更新书签　 065\n4.1.5　 移除书签　 065\n4.1.6　 获取书签内容　 065\n4.1.7　 书签事件　 066\n4.2　 Cookies　 068\n4.2.1　 管理Cookie　 068\n4.2.2　 读取Cookie　 069\n4.2.3　 设置Cookie　 069\n4.2.4　 删除Cookie　 070\n4.2.5　 获取全部的cookie　 store　 070\n4.2.6　 监控操作Cookie的行为　 071\n4.3　 历史　 071\n4.3.1　 读取历史　 072\n4.3.2　 添加历史　 073\n4.3.3　 删除历史　 074\n4.3.4　 对历史操作的监听　 074\n4.4　 管理扩展与应用　 075\n4.4.1　 读取用户已安装的扩展和应用的信息　 075\n4.4.2　 获取权限警告　 076\n4.4.3　 启用、禁用、卸载扩展和启动应用　 076\n4.4.4　 对管理操作的监听　 077\n4.5　 标签　 078\n4.5.1　 获取标签信息　 078\n4.5.2　 创建标签　 079\n4.5.3　 更新标签　 079\n4.5.4　 移动标签　 080\n4.5.5　 重载标签　 080\n4.5.6　 移除标签　 080\n4.5.7　 获取当前标签页面的显示语言　 081\n4.5.8　 获取指定窗口活动标签可见部分的截图　 081\n4.5.9　 注入JavaScript和CSS　 081\n4.5.10　 与指定标签中的内容脚本（content　 script）通信　 082\n4.5.11　 监视标签行为　 082\n4.6　 Override　 Pages　 084\n第5章　部分高级API　 086\n5.1　 下载　 087\n5.2　 网络请求　 089\n5.3　 代理　 092\n5.4　 系统信息　 095\n第6章　Chrome应用基础　 098\n6.1　 更加严格的内容安全策略　 099\n6.2　 图标设计规范　 101\n6.3　 应用的生命周期　 103\n6.4　 应用窗口　 106\n6.4.1　 创建窗口　 106\n6.4.2　 样式更加自由的窗口　 109\n6.4.3　 获取窗口　 115\n6.4.4　 窗口事件　 116\n6.5　 编写第一个Chrome应用　 117\n第7章　文件系统　 125\n7.1　 目录及文件操作对象　 126\n7.2　 获取目录及文件操作对象　 127\n7.3　 读取文件　 128\n7.4　 遍历目录　 130\n7.5　 创建及删除目录和文件　 132\n7.6　 写入文件　 134\n7.6.1　 Typed　 Array　 134\n7.6.2　 Blob对象　 136\n7.6.3　 FileWriter对象　 137\n7.7　 复制及移动目录和文件　 139\n第8章　媒体库　 140\n8.1　 获取媒体库　 141\n8.2　 添加及移除媒体库　 146\n8.3　 更新媒体库　 148\n8.4　 获取媒体文件信息　 152\n第9章　网络通信　 154\n9.1　 UDP协议　 155\n9.1.1　 建立与关闭连接　 156\n9.1.2　 发送与接收数据　 158\n9.1.3　 多播　 160\n9.1.4　 获取socket和组　 162\n9.1.5　 局域网聊天应用　 163\n9.2　 TCP协议　 166\n9.2.1　 建立与关闭连接　 167\n9.2.2　 发送与接收数据　 168\n9.2.3　 获取socket　 170\n9.3　 TCP　 Server　 170\n9.3.1　 建立与关闭连接　 171\n9.3.2　 监听数据　 173\n9.3.3　 获取socket　 174\n9.3.4　 HTTP　 Server　 175\n9.4　 WebSocket　 178\n第10章　其他接口　 179\n10.1　 操作USB设备　 180\n10.1.1　 发现设备　 180\n10.1.2　 接口操作　 181\n10.1.3　 传输操作　 182\n10.2　 串口通信　 183\n10.2.1　 建立连接　 183\n10.2.2　 发送和接收数据　 184\n10.2.3　 获取连接及状态　 185\n10.3　 文字转语音　 185\n10.3.1　 朗读文字　 186\n10.3.2　 获取声音　 187\n10.3.3　 获取朗读状态并监听事件　 188\n10.4　 系统信息　 189\n附录A　 制作Chrome主题　 191\nA.1　 背景图片　 193\nA.2　 颜色　 198\nA.3　 颜色叠加　 205\nA.4　 UI属性　 206\nA.5　 使用My　 Chrome　 Theme制作主题　 209\n附录B　 CSS选择器　 212\nB.1　 基本选择器　 213\nB.2　 高级选择器　 215\nB.3　 伪类　 216\n附录C　 初识AngularJS　 220\nC.1　 视图　 221\nC.2　 $scope　 224\nC.3　 module与路由　 225\n附录D　 Chrome扩展及应用的完整API列表　 229\nD.1　 Chrome扩展的全部API　 230\nD.2　 Chrome应用的全部API　 235",
        "pages": "252",
        "images": {
          "small": "https://img1.doubanio.com/spic/s27461678.jpg",
          "large": "https://img1.doubanio.com/lpic/s27461678.jpg",
          "medium": "https://img1.doubanio.com/mpic/s27461678.jpg"
        },
        "alt": "https://book.douban.com/subject/25980975/",
        "id": "25980975",
        "publisher": "人民邮电出版社",
        "isbn10": "711536866X",
        "isbn13": "9787115368669",
        "title": "Chrome扩展及应用开发",
        "url": "https://api.douban.com/v2/book/25980975",
        "alt_title": "",
        "author_intro": "李喆\n网名Sneezry，Chrome扩展及应用开发者，吉林大学电子科学与工程学院在读硕士，现研究方向为计算机视觉的硬件实现。喜欢小动物，养有一只智利狼蛛作为宠物。",
        "summary": "本书简述了Chrome平台开发的概念、扩展与应用的区别及其常用功能，并结合具体场景给出了实例。主要介绍了Chrome扩展基础、Chrome扩展的UI界面、管理浏览器和部分高级API划分，讲解了文件系统、网络通信、操作USB设备和串口通信等多个与操作系统紧密相关的内容，还介绍了Chrome主题开发、支持国际化的程序开发，以及如何使用Angular框架进行开发。\n本书以直观生动的实例帮助读者理解知识要点，以自顶向下的方式进行讲解，让读者先接触最直观的内容，然后慢慢深挖究其本质，非常适合开发者自学。",
        "price": "49.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "2e336caf56f2312a09d54189c82cc56ec2b89ec66befb494ced0d98408a2cc23",
        "file": "Chrome扩展应用开发.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 77,
          "average": "8.6",
          "min": 0
        },
        "subtitle": "HTML5权威指南",
        "author": [
          "[美] Adam Freeman"
        ],
        "pubdate": "2014-1",
        "tags": [
          {
            "count": 151,
            "name": "HTML5",
            "title": "HTML5"
          },
          {
            "count": 77,
            "name": "前端开发",
            "title": "前端开发"
          },
          {
            "count": 45,
            "name": "Web前端",
            "title": "Web前端"
          },
          {
            "count": 38,
            "name": "前端",
            "title": "前端"
          },
          {
            "count": 34,
            "name": "web开发",
            "title": "web开发"
          },
          {
            "count": 29,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 24,
            "name": "Web",
            "title": "Web"
          },
          {
            "count": 15,
            "name": "javascript",
            "title": "javascript"
          }
        ],
        "origin_title": "The definitive guide to HTML5",
        "image": "https://img3.doubanio.com/mpic/s27169241.jpg",
        "binding": "平装",
        "translator": [
          "谢廷晟",
          "牛化成",
          "刘美英"
        ],
        "catalog": "第一部分　开篇\n第1章　HTML5背景知识　　1\n1.1 　HTML的历史　　2\n1.1.1 　JavaScript出场　　2\n1.1.2 　浏览器战争的结束　　3\n1.1.3 　插件称雄　　3\n1.1.4 　语义HTML浮出水面　　3\n1.1.5 　发展态势：HTML标准滞后于其使用　　4\n1.2 　HTML5简介　　4\n1.2.1 　新标准　　4\n1.2.2 　引入原生多媒体支持　　5\n1.2.3 　引入可编程内容　　5\n1.2.4 　引入语义Web　　6\n1.3 　HTML5现况　　6\n1.3.1 　浏览器对HTML5的支持情况　　6\n1.3.2 　网站对HTML5的支持情况　　6\n1.4 　本书结构　　6\n1.5 　HTML5的更多信息　　7\n1.6 　小结　　7\n第2章　准备工作　　8\n2.1 　挑选浏览器　　8\n2.2 　挑选HTML编辑器　　9\n2.3 　挑选Web服务器　　9\n2.4 　获取Node.js　　9\n2.5 　获取示例代码　　10\n2.6 　小结　　10\n第3章　初探HTML　　11\n3.1 　使用元素　　12\n3.1.1 　了解本章用到的元素　　13\n3.1.2 　使用空元素　　14\n3.1.3 　使用自闭合标签　　14\n3.1.4 　使用虚元素　　14\n3.2 　使用元素属性　　16\n3.2.1 　一个元素应用多个属性　　16\n3.2.2 　使用布尔属性　　16\n3.2.3 　使用自定义属性　　17\n3.3 　创建HTML文档　　17\n3.3.1 　外层结构　　18\n3.3.2 　元数据　　19\n3.3.3 　内容　　19\n3.3.4 　父元素、子元素、后代元素和兄弟元素　　20\n3.3.5 　了解元素类型　　20\n3.4 　使用HTML实体　　21\n3.5 　HTML5全局属性　　21\n3.5.1 　accesskey属性　　21\n3.5.2 　class属性　　22\n3.5.3 　contenteditable属性　　25\n3.5.4 　contextmenu属性　　25\n3.5.5 　dir属性　　26\n3.5.6 　draggable属性　　26\n3.5.7 　dropzone属性　　26\n3.5.8 　hidden属性　　26\n3.5.9 　id属性　　28\n3.5.10 　lang属性　　29\n3.5.11 　spellcheck属性　　29\n3.5.12 　style属性　　30\n3.5.13 　tabindex属性　　30\n3.5.14 　title属性　　31\n3.6 　有用的HTML工具　　32\n3.7 　小结　　32\n第4章　初探CSS　　33\n4.1 　定义和应用样式　　33\n4.1.1 　了解本章所用的CSS属性　　34\n4.1.2 　使用元素内嵌样式　　34\n4.1.3 　使用文档内嵌样式　　35\n4.1.4 　使用外部样式表　　37\n4.2 　样式的层叠和继承　　40\n4.2.1 　浏览器样式　　40\n4.2.2 　用户样式　　41\n4.2.3 　样式如何层叠　　42\n4.2.4 　用重要样式调整层叠次序　　42\n4.2.5 　根据具体程度和定义次序解决同级样式冲突　　43\n4.2.6 　继承　　46\n4.3 　CSS中的颜色　　48\n4.4 　CSS中的长度　　49\n4.4.1 　绝对长度　　50\n4.4.2 　相对长度　　51\n4.5 　其他CSS单位　　56\n4.5.1 　使用CSS角度　　56\n4.5.2 　使用CSS时间　　57\n4.6 　测试CSS特性的支持情况　　57\n4.7 　有用的CSS工具　　57\n4.7.1 　浏览器样式报告　　57\n4.7.2 　用SelectorGadget生成选择器　　58\n4.7.3 　用LESS改进CSS　　59\n4.7.4 　使用CSS框架　　59\n4.8 　小结　　59\n第5章　初探JavaScript　　60\n5.1 　准备使用JavaScript　　61\n5.2 　使用语句　　62\n5.3 　定义和使用函数　　63\n5.3.1 　定义带参数的函数　　63\n5.3.2 　定义会返回结果的函数　　64\n5.4 　使用变量和类型　　65\n5.4.1 　使用基本类型　　66\n5.4.2 　创建对象　　67\n5.4.3 　使用对象　　69\n5.5 　使用JavaScript运算符　　73\n5.5.1 　相等和等同运算符　　73\n5.5.2 　显式类型转换　　76\n5.6 　使用数组　　78\n5.6.1 　使用数组字面量　　79\n5.6.2 　读取和修改数组内容　　80\n5.6.3 　枚举数组内容　　80\n5.6.4 　使用内置的数组方法　　81\n5.7 　处理错误　　81\n5.8 　比较undefined和null值　　83\n5.8.1 　检查变量或属性是否为undefined或null　　85\n5.8.2 　区分null和undefined　　85\n5.9 　常用的JavaScript工具　　86\n5.9.1 　使用JavaScript调试器　　86\n5.9.2 　使用JavaScript库　　86\n5.10 　小结　　87\n第二部分　HTML元素\n第6章　HTML5元素背景知识　　90\n6.1 　语义与呈现分离　　90\n6.2 　元素选用原则　　91\n6.2.1 　少亦可为多　　91\n6.2.2 　别误用元素　　91\n6.2.3 　具体为佳，一以贯之　　91\n6.2.4 　对用户不要想当然　　92\n6.3 　元素说明体例　　92\n6.4 　元素速览　　92\n6.4.1 　文档和元数据元素　　92\n6.4.2 　文本元素　　93\n6.4.3 　对内容分组　　94\n6.4.4 　划分内容　　95\n6.4.5 　制表　　95\n6.4.6 　创建表单　　96\n6.4.7 　嵌入内容　　96\n6.5 　未实现的元素　　97\n6.6 　小结　　97\n第7章　创建HTML文档　　98\n7.1 　构筑基本的文档结构　　99\n7.1.1 　DOCTYPE元素　　99\n7.1.2 　html元素　　99\n7.1.3 　head元素　　100\n7.1.4 　body元素　　101\n7.2 　用元数据元素说明文档　　102\n7.2.1 　设置文档标题　　102\n7.2.2 　设置相对URL的解析基准　　103\n7.2.3 　用元数据说明文档　　104\n7.2.4 　定义CSS样式　　108\n7.2.5 　指定外部资源　　112\n7.3 　使用脚本元素　　116\n7.3.1 　script元素　　117\n7.3.2 　noscript元素　　123\n7.4 　小结　　125\n第8章　标记文字　　126\n8.1 　生成超链接　　127\n8.1.1 　生成指向外部的超链接　　128\n8.1.2 　使用相对URL　　129\n8.1.3 　生成内部超链接　　129\n8.1.4 　设定浏览环境　　130\n8.2 　用基本的文字元素标记内容　　131\n8.2.1 　表示关键词和产品名称　　131\n8.2.2 　加以强调　　132\n8.2.3 　表示外文词语或科技术语　　133\n8.2.4 　表示不准确或校正　　134\n8.2.5 　表示重要的文字　　135\n8.2.6 　为文字添加下划线　　136\n8.2.7 　添加小号字体内容　　137\n8.2.8 　添加上标和下标　　138\n8.3 　换行　　139\n8.3.1 　强制换行　　139\n8.3.2 　指明可以安全换行的建议位置　　141\n8.4 　表示输入和输出　　142\n8.5 　使用标题引用、引文、定义和缩写　　143\n8.5.1 　表示缩写　　143\n8.5.2 　定义术语　　144\n8.5.3 　引用来自他处的内容　　145\n8.5.4 　引用其他作品的标题　　146\n8.6 　使用语言元素　　147\n8.6.1 　ruby、rt和rp元素　　147\n8.6.2 　bdo元素　　149\n8.6.3 　bdi元素　　150\n8.7 　其他文本元素　　152\n8.7.1 　表示一段一般性的内容　　152\n8.7.2 　突出显示文本　　153\n8.7.3 　表示添加和删除的内容　　155\n8.7.4 　表示时间和日期　　156\n8.8 　小结　　157\n第9章　组织内容　　158\n9.1 　为什么要对内容分组　　158\n9.2 　建立段落　　159\n9.3 　使用div元素　　161\n9.4 　使用预先编排好格式的内容　　163\n9.5 　引用他处内容　　164\n9.6 　添加主题分隔　　166\n9.7 　将内容组织为列表　　169\n9.7.1 　ol元素　　169\n9.7.2 　ul元素　　171\n9.7.3 　li元素　　172\n9.7.4 　生成说明列表　　173\n9.7.5 　生成自定义列表　　174\n9.8 　使用插图　　176\n9.9 　小结　　178\n第10章　文档分节　　179\n10.1 　添加基本的标题　　179\n10.2 　隐藏子标题　　182\n10.3 　生成节　　185\n10.4 　添加首部和尾部　　188\n10.5 　添加导航区域　　191\n10.6 　使用article　　194\n10.7 　生成附注栏　　198\n10.8 　提供联系信息　　201\n10.9 　生成详情区域　　202\n10.10 　小结　　205\n第11章　表格元素　　206\n11.1 　生成基本的表格　　206\n11.2 　添加表头单元格　　209\n11.3 　为表格添加结构　　211\n11.3.1 　表示表头和表格主题　　212\n11.3.2 　添加表脚　　214\n11.4 　制作不规则表格　　216\n11.5 　把表头与单元格关联起来　　220\n11.6 　为表格添加标题　　221\n11.7 　处理列　　223\n11.8 　设置表格边框　　228\n11.9 　小结　　230\n第12章　表单　　231\n12.1 　制作基本表单　　232\n12.1.1 　定义表单　　233\n12.1.2 　查看表单数据　　234\n12.2 　配置表单　　236\n12.2.1 　配置表单的action属性　　236\n12.2.2 　配置HTTP方法属性　　237\n12.2.3 　配置数据编码　　237\n12.2.4 　控制表单的自动完成功能　　239\n12.2.5 　指定表单反馈信息的目标显示位置　　240\n12.2.6 　设置表单名称　　242\n12.3 　在表单中添加说明标签　　242\n12.4 　自动聚焦到某个input元素　　244\n12.5 　禁用单个input元素　　245\n12.6 　对表单元素编组　　246\n12.6.1 　为fieldset元素添加说明标签　　248\n12.6.2 　用fieldset禁用整组input元素　　249\n12.7 　使用button元素　　250\n12.7.1 　用button元素提交表单　　251\n12.7.2 　用button元素重置表单　　252\n12.7.3 　把button作为一般元素使用　　253\n12.8 　使用表单外的元素　　254\n12.9 　小结　　254\n第13章　定制input元素　　255\n13.1 　用input元素输入文字　　256\n13.1.1 　设定元素大小　　256\n13.1.2 　设置初始值和占位式提示　　258\n13.1.3 　使用数据列表　　259\n13.1.4 　生成只读或被禁用的文本框　　262\n13.1.5 　指定文字方向数据的名称　　263\n13.2 　用input元素输入密码　　263\n13.3 　用input元素生成按钮　　266\n13.4 　用input元素为输入数据把关　　267\n13.4.1 　用input元素获取数值　　268\n13.4.2 　用input元素获取指定范围内的数值　　270\n13.4.3 　用input元素获取布尔型输入　　271\n13.4.4 　用input元素生成一组固定选项　　273\n13.4.5 　用input元素获取有规定格式的字符串　　275\n13.4.6 　用input元素获取时间和日期　　277\n13.4.7 　用input元素获取颜色值　　279\n13.5 　用input元素获取搜索用词　　281\n13.6 　用input元素生成隐藏的数据项　　282\n13.7 　用input元素生成图像按钮和分区响应图　　284\n13.8 　用input元素上传文件　　286\n13.9 　小结　　288\n第14章　其他表单元素及输入验证　　289\n14.1 　使用其他表单元素　　289\n14.1.1 　生成选项列表　　289\n14.1.2 　输入多行文字　　294\n14.1.3 　表示计算结果　　296\n14.1.4 　生成公开/私有密钥对　　297\n14.2 　使用输入验证　　298\n14.2.1 　确保用户提供了一个值　　299\n14.2.2 　确保输入值位于某个范围内　　300\n14.2.3 　确保输入值与指定模式匹配　　301\n14.2.4 　确保输入值是电子邮箱地址或URL　　303\n14.3 　禁用输入验证　　304\n14.4 　小结　　305\n第15章　嵌入内容　　306\n15.1 　嵌入图像　　306\n15.1.1 　在超链接里嵌入图像　　308\n15.1.2 　创建客户端分区响应图　　310\n15.2 　嵌入另一张HTML文档　　313\n15.3 　通过插件嵌入内容　　315\n15.3.1 　使用embed元素　　315\n15.3.2 　使用object和param元素　　317\n15.4 　object元素的其他用途　　319\n15.4.1 　使用object元素嵌入图像　　319\n15.4.2 　使用object元素创建分区响应图　　320\n15.4.3 　将object元素作为浏览上下文环境　　320\n15.5 　嵌入数字表现形式　　321\n15.5.1 　显示进度　　321\n15.5.2 　显示范围里的值　　322\n15.6 　其他嵌入元素　　324\n15.6.1 　嵌入音频和视频　　324\n15.6.2 　嵌入图形　　324\n15.7 　小结　　324\n第三部分　CSS\n第16章　理解CSS　　326\n16.1 　CSS标准化　　326\n16.2 　盒模型　　327\n16.3 　选择器简明参考　　328\n16.4 　属性简明参考　　329\n16.4.1 　边框和背景属性　　329\n16.4.2 　盒模型属性　　331\n16.4.3 　布局属性　　332\n16.4.4 　文本属性　　332\n16.4.5 　过渡、动画和变换属性　　333\n16.4.6 　其他属性　　334\n16.5 　小结　　334\n第17章　使用CSS选择器（第Ⅰ部分）　　335\n17.1 　使用CSS基本选择器　　335\n17.1.1 　选择所有元素　　336\n17.1.2 　根据类型选择元素　　337\n17.1.3 　根据类选择元素　　338\n17.1.4 　根据ID选择元素　　340\n17.1.5 　根据属性选择元素　　341\n17.2 　复合选择器　　344\n17.2.1 　并集选择器　　344\n17.2.2 　后代选择器　　345\n17.2.3 　选择子元素　　347\n17.2.4 　选择兄弟元素　　349\n17.3 　使用伪元素选择器　　351\n17.3.1 　使用::first-line选择器　　351\n17.3.2 　使用::first-letter选择器　　352\n17.3.3 　使用:before和:after选择器　　353\n17.3.4 　使用CSS计数器　　354\n17.4 　小结　　356\n第18章　使用CSS选择器（第Ⅱ部分）　　357\n18.1 　使用结构性伪类选择器　　357\n18.1.1 　使用根元素选择器　　358\n18.1.2 　使用子元素选择器　　359\n18.1.3 　使用:nth-child选择器　　363\n18.2 　使用UI伪类选择器　　364\n18.2.1 　选择启用或禁用元素　　364\n18.2.2 　选择已勾选的元素　　365\n18.2.3 　选择默认元素　　366\n18.2.4 　选择有效和无效的input元素　　367\n18.2.5 　选择限定范围的input元素　　369\n18.2.6 　选择必需和可选的input元素　　370\n18.3 　使用动态伪类选择器　　371\n18.3.1 　使用:link和:visited选择器　　371\n18.3.2 　使用:hover选择器　　372\n18.3.3 　使用:active选择器　　373\n18.3.4 　使用:focus选择器　　374\n18.4 　其他伪类选择器　　375\n18.4.1 　使用否定选择器　　376\n18.4.2 　使用:empty选择器　　376\n18.4.3 　使用:lang选择器　　377\n18.4.4 　使用:target选择器　　377\n18.5 　小结　　379\n第19章　使用边框和背景　　380\n19.1 　应用边框样式　　380\n19.1.1 　定义边框宽度　　381\n19.1.2 　定义边框样式　　382\n19.1.3 　为一条边应用边框样式　　383\n19.1.4 　使用border简写属性　　384\n19.1.5 　创建圆角边框　　385\n19.1.6 　将图像用做边框　　388\n19.2 　设置元素的背景　　392\n19.2.1 　设置背景颜色和图像　　392\n19.2.2 　设置背景图像的尺寸　　394\n19.2.3 　设置背景图像位置　　395\n19.2.4 　设置元素的背景附着方式　　396\n19.2.5 　设置背景图像的开始位置和裁剪样式　　397\n19.2.6 　使用background简写属性　　399\n19.3 　创建盒子阴影　　400\n19.4 　应用轮廓　　403\n19.5 　小结　　405\n第20章　使用盒模型　　406\n20.1 　为元素应用内边距　　407\n20.2 　为元素应用外边距　　409\n20.3 　控制元素的尺寸　　410\n20.3.1 　设置一定尺寸的盒子　　412\n20.3.2 　设置最小和最大尺寸　　413\n20.4 　处理溢出内容　　414\n20.5 　控制元素的可见性　　417\n20.6 　设置元素的盒类型　　419\n20.6.1 　认识块级元素　　420\n20.6.2 　认识行内元素　　421\n20.6.3 　认识行内?块级元素　　422\n20.6.4 　认识插入元素　　423\n20.6.5 　隐藏元素　　426\n20.7 　创建浮动盒　　427\n20.8 　小结　　433\n第21章　创建布局　　434\n21.1 　定位内容　　434\n21.1.1 　设置定位类型　　435\n21.1.2 　设置元素的层叠顺序　　437\n21.2 　创建多列布局　　439\n21.3 　创建弹性盒布局　　442\n21.3.1 　创建简单的弹性盒　　444\n21.3.2 　伸缩多个元素　　446\n21.3.3 　处理垂直空间　　447\n21.3.4 　处理最大尺寸　　448\n21.4 　创建表格布局　　450\n21.5 　小结　　453\n第22章　设置文本样式　　454\n22.1 　应用基本文本样式　　454\n22.1.1 　对齐文本　　455\n22.1.2 　处理空白　　457\n22.1.3 　指定文本方向　　460\n22.1.4 　指定单词、字母、行之间的间距　　461\n22.1.5 　控制断词　　462\n22.1.6 　首行缩进　　464\n22.2 　文本装饰与大小写转换　　465\n22.3 　创建文本阴影　　467\n22.4 　使用字体　　468\n22.4.1 　选择字体　　469\n22.4.2 　设置字体大小　　470\n22.4.3 　设置字体样式和粗细　　472\n22.5 　使用Web字体　　473\n22.6 　小结　　475\n第23章　过渡、动画和变换　　476\n23.1 　使用过渡　　477\n23.1.1 　创建反向过渡　　480\n23.1.2 　选择中间值的计算方式　　481\n23.2 　使用动画　　483\n23.2.1 　使用关键帧　　486\n23.2.2 　设置重复方向　　488\n23.2.3 　理解结束状态　　490\n23.2.4 　初始布局时应用动画　　491\n23.2.5 　重用关键帧　　492\n23.2.6 　为多个元素应用多个动画　　493\n23.2.7 　停止和启动动画　　495\n23.3 　使用变换　　497\n23.3.1 　应用变换　　497\n23.3.2 　指定元素变换的起点　　498\n23.3.3 　将变换作为动画和过渡处理　　500\n23.4 　小结　　501\n第24章　其他CSS属性和特性　　502\n24.1 　设置元素的颜色和透明度　　502\n24.1.1 　设置前景色　　502\n24.1.2 　设置元素的透明度　　504\n24.2 　设置表格样式　　505\n24.2.1 　合并表格边框　　505\n24.2.2 　配置独立边框　　507\n24.2.3 　处理空单元格　　508\n24.2.4 　设置标题的位置　　509\n24.2.5 　指定表格布局　　511\n24.3 　设置列表样式　　512\n24.3.1 　设置列表标记类型　　513\n24.3.2 　使用图像作为列表标记　　514\n24.3.3 　设置列表标记的位置　　515\n24.4 　设置光标样式　　517\n24.5 　小结　　518\n第四部分　使用DOM\n第25章　理解DOM　　520\n25.1 　理解文档对象模型　　520\n25.2 　理解DOM Level和兼容性　　522\n25.3 　DOM快速查询　　524\n25.3.1 　Document的成员　　524\n25.3.2 　Window的成员　　525\n25.3.3 　HTMLElement的成员　　527\n25.3.4 　DOM里的CSS属性　　529\n25.3.5 　DOM中的事件　　531\n25.4 　小结　　532\n第26章　使用Document对象　　533\n26.1 　使用Document元数据　　536\n26.1.1 　获取文档信息　　536\n26.1.2 　使用Location对象　　537\n26.1.3 　读取和写入cookie　　541\n26.1.4 　理解就绪状态　　542\n26.1.5 　获取DOM的实现情况　　543\n26.2 　获取HTML元素对象　　544\n26.2.1 　使用属性获取元素对象　　545\n26.2.2 　使用数组标记获取已命名元素　　546\n26.2.3 　搜索元素　　548\n26.2.4 　合并进行链式搜索　　550\n26.3 　在DOM树里导航　　552\n26.4 　小结　　554\n第27章　使用Window对象　　555\n27.1 　获取Window对象　　555\n27.2 　获取窗口信息　　556\n27.3 　与窗口进行交互　　558\n27.4 　对用户进行提示　　559\n27.5 　获取基本信息　　561\n27.6 　使用浏览器历史　　561\n27.6.1 　在浏览历史中导航　　562\n27.6.2 　在浏览历史里插入条目　　564\n27.6.3 　为不同的文档添加条目　　566\n27.6.4 　在浏览历史中保存复杂状态　　567\n27.6.5 　替换浏览历史中的条目　　570\n27.7 　使用跨文档消息传递　　570\n27.8 　使用计时器　　574\n27.9 　小结　　576\n第28章　使用DOM元素　　577\n28.1 　使用元素对象　　577\n28.1.1 　使用类　　579\n28.1.2 　使用元素属性　　582\n28.2 　使用Text对象　　586\n28.3 　修改模型　　588\n28.3.1 　创建和删除元素　　589\n28.3.2 　复制元素　　591\n28.3.3 　移动元素　　592\n28.3.4 　比较元素对象　　593\n28.3.5 　使用HTML片段　　595\n28.3.6 　向文本块插入元素　　600\n28.4 　小结　　601\n第29章　为DOM元素设置样式　　602\n29.1 　使用样式表　　602\n29.1.1 　获得样式表的基本信息　　603\n29.1.2 　使用媒介限制　　605\n29.1.3 　禁用样式表　　607\n29.1.4 　CSSRuleList对象的成员　　608\n29.2 　使用元素样式　　611\n29.3 　使用CSSStyleDeclaration对象　　613\n29.3.1 　使用便捷属性　　613\n29.3.2 　使用常规属性　　616\n29.3.3 　使用细粒度的CSS DOM对象　　620\n29.4 　使用计算样式　　623\n29.5 　小结　　625\n第30章　使用事件　　626\n30.1 　使用简单事件处理器　　627\n30.1.1 　实现简单的内联事件处理器　　627\n30.1.2 　实现一个简单的事件处理函数　　629\n30.2 　使用DOM和事件对象　　630\n30.2.1 　按类型区分事件　　633\n30.2.2 　理解事件流　　634\n30.2.3 　使用可撤销事件　　641\n30.3 　使用HTML事件　　642\n30.3.1 　文档和窗口事件　　642\n30.3.2 　使用鼠标事件　　643\n30.3.3 　使用键盘焦点事件　　645\n30.3.4 　使用键盘事件　　647\n30.3.5 　使用表单事件　　649\n30.4 　小结　　649\n第31章　使用元素专属对象　　650\n31.1 　文档和元数据对象　　650\n31.1.1 　base元素　　650\n31.1.2 　body元素　　650\n31.1.3 　link元素　　651\n31.1.4 　meta元素　　651\n31.1.5 　script元素　　651\n31.1.6 　style元素　　652\n31.1.7 　title元素　　652\n31.1.8 　其他文档和元数据元素　　652\n31.2 　文本元素　　652\n31.2.1 　a元素　　652\n31.2.2 　del和ins元素　　653\n31.2.3 　q元素　　653\n31.2.4 　time元素　　653\n31.2.5 　其他文本元素　　654\n31.3 　分组元素　　654\n31.3.1 　blockquote元素　　654\n31.3.2 　li元素　　654\n31.3.3 　ol元素　　654\n31.3.4 　其他分组元素　　655\n31.4 　区块元素　　655\n31.4.1 　details元素　　655\n31.4.2 　其他区块元素　　655\n31.5 　表格元素　　655\n31.5.1 　col和colgroup元素　　655\n31.5.2 　table元素　　656\n31.5.3 　thead、tbody和tfoot元素　　656\n31.5.4 　th元素　　657\n31.5.5 　tr元素　　657\n31.5.6 　其他表格元素　　657\n31.6 　表单元素　　657\n31.6.1 　button元素　　657\n31.6.2 　datalist元素　　658\n31.6.3 　fieldset元素　　658\n31.6.4 　form元素　　658\n31.6.5 　input元素　　659\n31.6.6 　label元素　　660\n31.6.7 　legend元素　　661\n31.6.8 　optgroup元素　　661\n31.6.9 　option元素　　661\n31.6.10 　output元素　　661\n31.6.11 　select元素　　662\n31.6.12 　textarea元素　　663\n31.7 　内容元素　　663\n31.7.1 　area元素　　664\n31.7.2 　embed元素　　664\n31.7.3 　iframe元素　　664\n31.7.4 　img元素　　665\n31.7.5 　map元素　　665\n31.7.6 　meter元素　　665\n31.7.7 　object元素　　666\n31.7.8 　param元素　　666\n31.7.9 　progress元素　　667\n31.8 　小结　　667\n第五部分　高级功能\n第32章　使用Ajax（第Ⅰ部分）　　670\n32.1 　Ajax起步　　671\n32.1.1 　处理响应　　674\n32.1.2 　主流中的异类：应对Opera　　675\n32.2 　使用Ajax事件　　677\n32.3 　处理错误　　679\n32.3.1 　处理设置错误　　681\n32.3.2 　处理请求错误　　682\n32.3.3 　处理应用程序错误　　682\n32.4 　获取和设置标头　　683\n32.4.1 　覆盖请求的HTTP方法　　683\n32.4.2 　禁用内容缓存　　685\n32.4.3 　读取响应标头　　685\n32.5 　生成跨源Ajax请求　　687\n32.5.1 　使用Origin请求标头　　690\n32.5.2 　高级CORS功能　　691\n32.6 　中止请求　　691\n32.7 　小结　　693\n第33章　使用Ajax（第Ⅱ部分）　　694\n33.1 　准备向服务器发送数据　　694\n33.1.1 　定义服务器　　695\n33.1.2 　理解问题所在　　697\n33.2 　发送表单数据　　698\n33.3 　使用FormData对象发送表单数据　　701\n33.3.1 　创建FormData对象　　701\n33.3.2 　修改FormData对象　　702\n33.4 　发送JSON数据　　703\n33.5 　发送文件　　705\n33.6 　追踪上传进度　　707\n33.7 　请求并处理不同内容类型　　709\n33.7.1 　接收HTML片段　　709\n33.7.2 　接收XML数据　　712\n33.7.3 　接收JSON数据　　714\n33.8 　小结　　715\n第34章　使用多媒体　　716\n34.1 　使用video元素　　717\n34.1.1 　预先加载视频　　718\n34.1.2 　显示占位图像　　720\n34.1.3 　设置视频尺寸　　720\n34.1.4 　指定视频来源（和格式）　　721\n34.1.5 　track元素　　724\n34.2 　使用audio元素　　724\n34.3 　通过DOM操作嵌入式媒体　　726\n34.3.1 　获得媒体信息　　726\n34.3.2 　评估回放能力　　728\n34.3.3 　控制媒体回放　　730\n34.4 　小结　　733\n第35章　使用canvas元素（第Ⅰ部分）　　734\n35.1 　开始使用canvas元素　　735\n35.2 　获取画布的上下文　　736\n35.3 　绘制矩形　　737\n35.4 　设置画布绘制状态　　739\n35.4.1 　设置线条连接样式　　741\n35.4.2 　设置填充和笔触样式　　742\n35.4.3 　使用渐变　　743\n35.4.4 　使用径向渐变　　748\n35.4.5 　使用图案　　751\n35.5 　保存和恢复绘制状态　　753\n35.6 　绘制图像　　755\n35.6.1 　使用视频图像　　756\n35.6.2 　使用画布图像　　759\n35.7 　小结　　761\n第36章　使用canvas元素（第Ⅱ部分）　　762\n36.1 　用路径绘图　　762\n36.1.1 　用线条绘制路径　　763\n36.1.2 　绘制矩形　　766\n36.2 　绘制圆弧　　768\n36.2.1 　使用arcTo方法　　768\n36.2.2 　使用arc方法　　772\n36.3 　绘制贝塞尔曲线　　773\n36.3.1 　绘制三次贝塞尔曲线　　773\n36.3.2 　绘制二次贝塞尔曲线　　775\n36.4 　创建剪辑区域　　777\n36.5 　绘制文本　　778\n36.6 　使用特效和变换　　780\n36.6.1 　使用阴影　　780\n36.6.2 　使用透明度　　781\n36.6.3 　使用合成　　782\n36.6.4 　使用变换　　784\n36.7 　小结　　786\n第37章　使用拖放　　787\n37.1 　创建来源项目　　787\n37.2 　创建释放区　　791\n37.3 　使用DataTransfer对象　　794\n37.3.1 　根据数据过滤被拖动项目　　796\n37.3.2 　拖放文件　　797\n37.4 　小结　　801\n第38章　使用地理定位　　802\n38.1 　使用地理定位　　802\n38.2 　处理地理定位错误　　805\n38.3 　指定地理定位选项　　807\n38.4 　监控位置　　809\n38.5 　小结　　810\n第39章　使用Web存储　　811\n39.1 　使用本地存储　　811\n39.2 　使用会话存储　　815\n39.3 　小结　　819\n第40章　创建离线Web应用程序　　820\n40.1 　定义问题　　820\n40.2 　定义清单　　822\n40.3 　检测浏览器状态　　827\n40.4 　使用离线缓存　　828\n40.4.1 　制作更新　　832\n40.4.2 　获取更新　　832\n40.4.3 　应用更新　　833\n40.5 　小结　　834\n",
        "pages": "834",
        "images": {
          "small": "https://img3.doubanio.com/spic/s27169241.jpg",
          "large": "https://img3.doubanio.com/lpic/s27169241.jpg",
          "medium": "https://img3.doubanio.com/mpic/s27169241.jpg"
        },
        "alt": "https://book.douban.com/subject/25786074/",
        "id": "25786074",
        "publisher": "人民邮电出版社",
        "isbn10": "7115338361",
        "isbn13": "9787115338365",
        "title": "Html5权威指南",
        "url": "https://api.douban.com/v2/book/25786074",
        "alt_title": "The definitive guide to HTML5",
        "author_intro": "Adam Freeman\n曾在多家名企担任高级职务，现为畅销技术图书作家，著有多部C#、.NET和Java方面的大部头作品。其中《ASP.NET 4高级程序设计（第4版）》、《精通ASP.NET MVC 3框架（第3版）》销量均在同品种中名列前茅，备受读者推崇。《HTML5权威指南》是Freeman专门为网页开发新手和网页设计师打造的经典参考书，这本书秉承作者的一贯风格，幽默风趣、简约凝练、逻辑性强，是广大Web开发人员的必读经典。",
        "summary": "《HTML5 权威指南》是系统学习网页设计的权威参考图书。本书分为五部分：第一部分介绍学习本书的预备知识和HTML、CSS 和JavaScript 的最新进展；第二部分讨论HTML 元素，并详细说明了HTML5中新增和修改的元素；第三部分阐述CSS，涵盖了所有控制内容样式的CSS 选择器和属性，并辅以大量代码示例和图示；第四部分介绍DOM，剖析如何用JavaScript 操纵HTML 内容；第五部分讲解Ajax、多媒体和canvas 元素等HTML5 高级特性。\n本书面向初学者和中等水平Web 开发人员，是牢固掌握HTML5、CSS3 和JavaScript 的必读之作。",
        "series": {
          "id": "660",
          "title": "图灵程序设计丛书"
        },
        "price": "129.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "b6fc0eb0b2359228146669e70876c38b09da5a2ca816cf1841616e5a19e5e48d",
        "file": "Html5权威指南.pdf"
      },
      {
        "timestamp": "2017-11-03T04:27:06.197458+00:00",
        "creator": "Linghao Li",
        "title": "JS 函数式编程指南",
        "language": "zh",
        "identifier": {
          "uuid": "f4079265-16ab-4879-bd3e-755fa5b285f4"
        },
        "description": "Mostly Adequate Guide 中文版",
        "contributor": "GitBook",
        "publisher": "GitBook",
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "8806b59128bac0d6127946ea7a38294f2639ac111ff76b4e7c9ccff07dbb97f5",
        "file": "JS函数式编程-GitBook.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 186,
          "average": "9.1",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "曾探"
        ],
        "pubdate": "2015-5",
        "tags": [
          {
            "count": 307,
            "name": "JavaScript",
            "title": "JavaScript"
          },
          {
            "count": 175,
            "name": "设计模式",
            "title": "设计模式"
          },
          {
            "count": 124,
            "name": "前端开发",
            "title": "前端开发"
          },
          {
            "count": 53,
            "name": "前端",
            "title": "前端"
          },
          {
            "count": 48,
            "name": "Web前端",
            "title": "Web前端"
          },
          {
            "count": 47,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 36,
            "name": "javascript",
            "title": "javascript"
          },
          {
            "count": 35,
            "name": "计算机",
            "title": "计算机"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s28065006.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "第一部分　基础知识\n第1章　面向对象的JavaScript\n1.1 动态类型语言和鸭子类型　　2\n1.2 多态　　4\n1.3 封装　　12\n1.4 原型模式和基于原型继承的JavaScript对象系统　　14\n第2章　this、call和apply\n2.1 this　　24\n2.2 call和apply　　29\n第3章　闭包和高阶函数\n3.1 闭包 35\n3.2 高阶函数　　44\n3.3 小结　　58\n第二部分 设计模式\n第4章　单例模式\n4.1 实现单例模式　　60\n4.2 透明的单例模式　　61\n4.3 用代理实现单例模式　　62\n4.4 JavaScript中的单例模式　　63\n4.5 惰性单例　　65\n4.6 通用的惰性单例　　68\n4.7 小结　　70\n第5章　策略模式\n5.1 使用策略模式计算奖金　　72\n5.2 JavaScript 版本的策略模式　　75\n5.3 多态在策略模式中的体现　　76\n5.4 使用策略模式实现缓动动画　　76\n5.5 更广义的“算法”　　80\n5.6 表单校验　　80\n5.7 策略模式的优缺点　　86\n5.8 一等函数对象与策略模式　　86\n5.9 小结　　87\n第6章　代理模式\n6.1 第一个例子——小明追MM的故事　　88\n6.2 保护代理和虚拟代理　　91\n6.3 虚拟代理实现图片预加载　　91\n6.4 代理的意义　　93\n6.5 代理和本体接口的一致性　　94\n6.6 虚拟代理合并HTTP 请求　　95\n6.7 虚拟代理在惰性加载中的应用　　97\n6.8 缓存代理　　99\n6.9 用高阶函数动态创建代理　　100\n6.10 其他代理模式　　101\n6.11 小结　　102\n第7章　迭代器模式\n7.1 jQuery 中的迭代器　　103\n7.2 实现自己的迭代器　　104\n7.3 内部迭代器和外部迭代器　　104\n7.4 迭代类数组对象和字面量对象　　106\n7.5 倒序迭代器　　106\n7.6 中止迭代器　　107\n7.7 迭代器模式的应用举例　　107\n7.8 小结　　109\n第8章　发布—订阅模式\n8.1 现实中的发布—订阅模式　　110\n8.2 发布—订阅模式的作用　　110\n8.3 DOM 事件　　111\n8.4 自定义事件　　112\n8.5 发布—订阅模式的通用实现　　113\n8.6 取消订阅的事件　　115\n8.7 真实的例子——网站登录　　115\n8.8 全局的发布—订阅对象　　117\n8.9 模块间通信　　119\n8.10 必须先订阅再发布吗　　120\n8.11 全局事件的命名冲突　　121\n8.12 JavaScript实现发布—订阅模式的便利性　　124\n8.13 小结　　124\n第9章　命令模式\n9.1 命令模式的用途　　125\n9.2 命令模式的例子——菜单程序　　126\n9.3 JavaScript中的命令模式　　128\n9.4 撤销命令　　130\n9.5 撤消和重做　　132\n9.6 命令队列　　134\n9.7 宏命令　　134\n9.8 智能命令与傻瓜命令　　135\n9.9 小结　　136\n第10章　组合模式\n10.1 回顾宏命令　　138\n10.2 组合模式的用途　　139\n10.3 请求在树中传递的过程　　139\n10.4 更强大的宏命令　　140\n10.5 抽象类在组合模式中的作用　　143\n10.6 透明性带来的安全问题　　144\n10.7 组合模式的例子——扫描文件夹　　145\n10.8 一些值得注意的地方　　147\n10.9 引用父对象　　148\n10.10 何时使用组合模式　　150\n10.11 小结　　150\n第11章　模板方法模式\n11.1 模板方法模式的定义和组成　　151\n11.2 第一个例子——Coffee or Tea　　151\n11.3 抽象类　　156\n11.4 模板方法模式的使用场景　　159\n11.5 钩子方法　　160\n11.6 好莱坞原则　　162\n11.7 真的需要“继承”吗　　162\n11.8 小结　　164\n第12章　享元模式\n12.1 初识享元模式　　165\n12.2 内部状态与外部状态　　166\n12.3 享元模式的通用结构　　167\n12.4 文件上传的例子　　167\n12.5 享元模式的适用性　　173\n12.6 再谈内部状态和外部状态　　173\n12.7 对象池　　175\n12.8 小结　　178\n第13章　职责链模式\n13.1 现实中的职责链模式　　179\n13.2 实际开发中的职责链模式　　180\n13.3 用职责链模式重构代码　　181\n13.4 灵活可拆分的职责链节点　　183\n13.5 异步的职责链　　184\n13.6 职责链模式的优缺点　　185\n13.7 用AOP 实现职责链　　186\n13.8 用职责链模式获取文件上传对象　　187\n13.9 小结　　188\n第14章　中介者模式\n14.1 现实中的中介者　　190\n14.2 中介者模式的例子——泡泡堂游戏　　191\n14.3 中介者模式的例子——购买商品　　199\n14.4 小结　　207\n第15章　装饰者模式\n15.1 模拟传统面向对象语言的装饰者模式　　210\n15.2 装饰者也是包装器　　211\n15.3 回到JavaScript 的装饰者　　212\n15.4 装饰函数　　212\n15.5 用AOP 装饰函数　　214\n15.6 AOP 的应用实例　　216\n15.7 装饰者模式和代理模式　　222\n15.8 小结　　223\n第16章　状态模式\n16.1 初识状态模式　　224\n16.2 状态模式的定义　　230\n16.3 状态模式的通用结构　　230\n16.4 缺少抽象类的变通方式　　　231\n16.5 另一个状态模式示例——文件上传　　232\n16.6 状态模式的优缺点　　241\n16.7 状态模式中的性能优化点　　241\n16.8 状态模式和策略模式的关系　　241\n16.9 JavaScript版本的状态机　　242\n16.10 表驱动的有限状态机　　244\n16.11 实际项目中的其他状态机　　245\n16.12 小结　　245\n第17章　适配器模式\n17.1 现实中的适配器　　246\n17.2 适配器模式的应用　　247\n17.3 小结　　250\n第三部分 设计原则和编程技巧\n第18章　单一职责原则\n18.1 设计模式中的SRP原则　　252\n18.2 何时应该分离职责　　256\n18.3 违反SRP原则　　256\n18.4 SRP 原则的优缺点　　257\n第19章　最少知识原则\n19.1 减少对象之间的联系　　258\n19.2 设计模式中的LKP原则　　259\n19.3 封装在LKP 原则中的体现　　261\n第20章　开放-封闭原则\n20.1 扩展window.onload函数　　263\n20.2 开放和封闭　　264\n20.3 用对象的多态性消除条件分支　　265\n20.4 找出变化的地方　　266\n20.5 设计模式中的开放—封闭原则　　268\n20.6 开放—封闭原则的相对性　　270\n20.7 接受第一次愚弄　　270\n第21章　接口和面向接口编程\n21.1 回到Java的抽象类　　271\n21.2 interface　　276\n21.3 JavaScript 语言是否需要抽象类和interface　　275\n21.4 用鸭子类型进行接口检查　　277\n21.5 用TypeScript 编写基于interface的命令模式　　278\n第22章　代码重构\n22.1 提炼函数　　282\n22.2 合并重复的条件片段　　283\n22.3 把条件分支语句提炼成函数　　284\n22.4 合理使用循环　　285\n22.5 提前让函数退出代替嵌套条件分支　　285\n22.6 传递对象参数代替过长的参数列表　　286\n22.7 尽量减少参数数量　　287\n22.8 少用三目运算符　　288\n22.9 合理使用链式调用　　288\n22.10 分解大型类　　289\n22.11 用return退出多重循环　　290\n参考文献　　293",
        "pages": "294",
        "images": {
          "small": "https://img3.doubanio.com/spic/s28065006.jpg",
          "large": "https://img3.doubanio.com/lpic/s28065006.jpg",
          "medium": "https://img3.doubanio.com/mpic/s28065006.jpg"
        },
        "alt": "https://book.douban.com/subject/26382780/",
        "id": "26382780",
        "publisher": "人民邮电出版社",
        "isbn10": "7115388881",
        "isbn13": "9787115388889",
        "title": "JavaScript设计模式与开发实践",
        "url": "https://api.douban.com/v2/book/26382780",
        "alt_title": "",
        "author_intro": "曾探\n2007年毕业于吉林大学软件学院。就职于国内知名前端团队腾讯AlloyTeam，高级工程师。\n曾参与Web QQ、QQ群、Q+开发者网站、微云、QQ兴趣部落等大型前端项目的开发。有过Java、Python和JavaScript的开发经验，业余作品有HTML5版街头霸王等。\n平时喜欢电影和音乐，业务时间也是一名健身教练。",
        "summary": "本书在尊重《设计模式》原意的同时，针对JavaScript语言特性全面介绍了更适合JavaScript程序员的了16个常用的设计模式，讲解了JavaScript面向对象和函数式编程方面的基础知识，介绍了面向对象的设计原则及其在设计模式中的体现，还分享了面向对象编程技巧和日常开发中的代码重构。本书将教会你如何把经典的设计模式应用到JavaScript语言中，编写出优美高效、结构化和可维护的代码。",
        "series": {
          "id": "13000",
          "title": "图灵原创"
        },
        "price": "59.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "d90207f3a64c1c6411a83068bd3916c1409f574b33596a0cb04407ce354ddfc4",
        "file": "JavaScript设计模式与开发实践.pdf"
      },
      {
        "title": "Node.js 设计模式（第 2 版）",
        "subtitle": "",
        "author": [
          "【爱尔兰】Mario Casciaro（马里奥•卡西罗）",
          "【意大利】Luciano Mammino（卢西安诺•马米诺）"
        ],
        "summary": "《node.js设计模式（第2版）》通过大量示例形象地阐述了 Node.js 的哲学思想和设计模式。内容主要由六部分组成：Node 核心思想、基础设计模式、异步控制流模式、流编程、Node.js 的传统设计模式和特有设计模式、通用编程的 Web 应用以及处理复杂实际问题的高级编程技巧。\n这是一本值得深入品读的书籍，读者若具备一些软件设计的理论知识会有助于理解书中提出的概念，中级 Node.js 开发者也会从本书有所收获。《node.js设计模式（第2版）》尤其适用于已经接触过 Node.js 并且想在效率、设计质量和可扩展性方面获得提升的开发者。",
        "publisher": "电子工业出版社",
        "isbn13": "9787121335228",
        "isbn10": "7121335220",
        "tags": [
          {
            "title": "Node.js",
            "name": "Node.js",
            "count": 39
          },
          {
            "title": "JavaScript",
            "name": "JavaScript",
            "count": 17
          },
          {
            "title": "设计模式",
            "name": "设计模式",
            "count": 14
          },
          {
            "title": "前端技术",
            "name": "前端技术",
            "count": 11
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 9
          },
          {
            "title": "技术",
            "name": "技术",
            "count": 9
          },
          {
            "title": "编程",
            "name": "编程",
            "count": 8
          },
          {
            "title": "web开发",
            "name": "web开发",
            "count": 7
          }
        ],
        "pubdate": "2018-2",
        "translator": [
          "冯康"
        ],
        "binding": "平装",
        "author_intro": "Mario Casciaro，软件工程硕士学位，软件工程师，企业家，对技术、科学和开源知识充满了热情。他在IBM开始了职业生涯，数年间先后参与很多不同产品的开发，例如TivoliEndpoint\nManager、Cognos Insight 及 SalesConnect。后来，他加入了一个成长中的 SaaS 公司——D4HTechnologies，负责开发一款实时应急管理的前沿产品。现在，Mario 是 Sponsorama.com 的\n联合创始人兼 CEO，这是一个帮助在线项目募集企业赞助资金的平台。Mario 也是 Node.js DesignPatterns（Node.js 设计模式）第一版的作者。\n翻译成员全部来自陆金所大前端团队，也是公众号大前端工程师的翻译小组成员，他们在公众号与知乎专栏里面也有很多新的技术文章的翻译，此次由寸志老师带队，大家一边在公司进行nodejs项目的推广实践，一边将实践的心得注入到本书翻译的理解，这是非常难得的结合，相信大家在读的过程中能体会到这一点。",
        "rating": {
          "average": 8.5,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 20.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "0e697764b1d7bdd2d8a4ea1c22699a8bc71fabbbc4e77bd5b2f35745cfaf8b9e",
        "file": "Node.js 设计模式-第二版.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 297,
          "average": "7.4",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "余果"
        ],
        "pubdate": "2015-9-1",
        "tags": [
          {
            "count": 207,
            "name": "前端开发",
            "title": "前端开发"
          },
          {
            "count": 133,
            "name": "web",
            "title": "web"
          },
          {
            "count": 95,
            "name": "程序员",
            "title": "程序员"
          },
          {
            "count": 80,
            "name": "全栈工程师",
            "title": "全栈工程师"
          },
          {
            "count": 78,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 76,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 54,
            "name": "fullstack",
            "title": "fullstack"
          },
          {
            "count": 47,
            "name": "前端",
            "title": "前端"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/view/subject/m/public/s28281864.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "什么是全栈工程师\n002tFacebook只招全栈工程师\n004tWeb开发流程\n011t全栈工程师登上舞台\n014t全栈工程师的发展前景\n如何成为全栈工程师\n020t先精后广，一专多长\n023t围绕商业目标\n027t关注用户体验\n从学生到工程师\n034t校园招聘\n038t获得面试机会\n041t实习\n野生程序员的故事\n046t遭遇“野生程序员”\n050t什么是“野生程序员”\n053t大公司还是创业公司\n工程师事业指南\n058t那个什么都懂的家伙\n059t积累作品集\n068t突出重点\n全栈工程师眼中的\n072t简介\n074t前端视角\n077t后台视角\n079tBigPipe\n高性能网站的关键：缓存\n084t什么是缓存\n085t服务器缓存\n090t浏览器缓存\n大前端\n098t前端工程师\n098t知识体系\n104t岗位细分\n向移动端转型\n112t为什么向移动端转型\n113t一个转型故事\n114t一定要是自己的产品的用户\n115t有哪些方向\n持续集成\n126t版本控制\n134t包管理\n141t构建工具\n理解编程语言\n150t编程语言是什么\n159t全栈工程师最佳实践\n161t脚本语言的优势\n全栈游乐场\n168tVPS\n172t实践\n软件设计方法\n178t设计模式\n183t架构模式\n186t设计原则\n高效工程师\n192t为什么需要高效\n192t提速100倍\n学习设计\n204t科学家和工程师\n207t设计基础\n211tFacebook的品牌设计故事\n全栈思维\n218t有兴趣就够了吗\n220t学一点管理\n224t沟通：被忽视的竞争力\n后记",
        "pages": "234",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s28281864.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s28281864.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s28281864.jpg"
        },
        "alt": "https://book.douban.com/subject/26598045/",
        "id": "26598045",
        "publisher": "人民邮电出版社",
        "isbn10": "7115399026",
        "isbn13": "9787115399021",
        "title": "Web全栈工程师的自我修养",
        "url": "https://api.douban.com/v2/book/26598045",
        "alt_title": "",
        "author_intro": "余果，腾讯社交用户体验设计部高级UI工程师，前端开发组负责人，熟悉前端开发、iOS开发、PHP开发和Ruby开发等；曾独立开发iOS APP（撸大师）和CMS（33PU）；翻译有《众妙之门: 网站重新设计之道》和《响应式Web设计全流程解析》；平时喜欢编程、写作、演讲、摄影和英语等，希望自己能做一个终生学习者。",
        "summary": "全栈工程师正成为 IT 行业的新秀，论是上市互联网公司还是创业公司，都对全栈工程师青睐有加。本书作者是腾讯公司高级工程师，在前端、后端和APP开发方面都有丰富的经验，在本书中分享了全栈工程师的技能要求、核心竞争力、未来发展方向、对移动端的思考。除此之外，本书还详细记录了作者从零开始、学习成长的心路历程。\n本书内容全面，客观务实，适合互联网行业新人、程序员，以及期待技术转型的从业者阅读参考。",
        "price": "49.00",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "1d258c83a1c26ab481f6119d28dcfc8e943ff0bc8609ee6ea2fc145aa3b26b7e",
        "file": "Web全栈工程师的自我修养.epub"
      },
      {
        "timestamp": "2016-09-21T08:33:58.071106+00:00",
        "creator": "Eddy Chang",
        "contributor": "GitBook",
        "language": "zh",
        "title": "從Promise開始的JavaScript異步生活",
        "description": "學習如何使用ES6 Promise，應用異步執行流程在你的JavaScript程式中。",
        "identifier": {
          "uuid": "a1ccf1dd-f071-4d25-8941-4b60e19c94c8"
        },
        "publisher": "GitBook",
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "df4a4bf5fa3d831d457478e1ae80041a7219fe3b0898b21c89c5804ca0a7cb08",
        "file": "javascript-start-es6-promise.epub"
      },
      {
        "timestamp": "2016-09-21T09:38:07.501544+00:00",
        "language": "zh",
        "publisher": "GitBook",
        "creator": "Eddy Chang",
        "description": "寫給中文開發者的JavaScript程式語言入門書籍，加入許多ES6新語法與API。",
        "contributor": "GitBook",
        "title": "從ES6開始的JavaScript學習生活",
        "identifier": {
          "uuid": "5dc337ad-8a20-4669-a510-f776d3b735c7"
        },
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "483f81e05a4a263d4c5438de2e0a681c56ec90ed3ff36f87ad55ed0a90f03ee8",
        "file": "javascript-start-from-es6.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 483,
          "average": "8.9",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "David Flanagan"
        ],
        "pubdate": "2012-4-1",
        "tags": [
          {
            "count": 776,
            "name": "JavaScript",
            "title": "JavaScript"
          },
          {
            "count": 266,
            "name": "Web前端开发",
            "title": "Web前端开发"
          },
          {
            "count": 237,
            "name": "犀牛书",
            "title": "犀牛书"
          },
          {
            "count": 170,
            "name": "前端",
            "title": "前端"
          },
          {
            "count": 115,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 110,
            "name": "前端开发",
            "title": "前端开发"
          },
          {
            "count": 110,
            "name": "Web开发",
            "title": "Web开发"
          },
          {
            "count": 107,
            "name": "计算机",
            "title": "计算机"
          }
        ],
        "origin_title": "JavaScript: The Definitive Guide, Sixth Edition",
        "image": "https://img3.doubanio.com/mpic/s8958854.jpg",
        "binding": "平装",
        "translator": [
          "淘宝前端团队"
        ],
        "catalog": "前言  1\n第1章 JavaScript概述  5\n1.1 JavaScript语言核心  8\n1.2 客户端JavaScript  12\n第一部分 JavaScript 语言核心\n第2章 词法结构  25\n2.1 字符集  25\n2.2 注释  27\n2.3 直接量  27\n2.4 标识符和保留字  28\n2.5 可选的分号  30\n第3章 类型、值和变量  32\n3.1 数字  34\n3.2 文本  38\n3.3 布尔值  43\n3.4 null和undefined  44\n3.5 全局对象  45\n3.6 包装对象  46\n3.7 不可变的原始值和可变的对象引用  47\n3.8 类型转换  48\n3.9 变量声明  55\n3.10 变量作用域  56\n第4章 表达式和运算符  60\n4.1 原始表达式  60\n4.2 对象和数组的初始化表达式  61\n4.3 函数定义表达式  62\n4.4 属性访问表达式  63\n4.5 调用表达式  64\n4.6 对象创建表达式  64\n4.7 运算符概述  65\n4.8 算术表达式  69\n4.9 关系表达式  74\n4.10 逻辑表达式  79\n4.11 赋值表达式  81\n4.12 表达式计算  83\n4.13 其他运算符  86\n第5章 语句  91\n5.1 表达式语句  92\n5.2 复合语句和空语句  92\n5.3 声明语句  94\n5.4 条件语句  96\n5.5 循环  101\n5.6 跳转  106\n5.7 其他语句类型  113\n5.8 JavaScript语句小结  116\n第6章 对象  118\n6.1 创建对象  120\n6.2 属性的查询和设置  123\n6.3 删除属性  127\n6.4 检测属性  128\n6.5 枚举属性  130\n6.6 属性getter和setter  132\n6.7 属性的特性  134\n6.8 对象的三个属性  138\n6.9 序列化对象  141\n6.10 对象方法  142\n第7章 数组  144\n7.1 创建数组  144\n7.2 数组元素的读和写  145\n7.3 稀疏数组  147\n7.4 数组长度  148\n7.5 数组元素的添加和删除  149\n7.6 数组遍历  149\n7.7 多维数组  151\n7.8 数组方法  152\n7.9 ECMAScript 5中的数组方法  156\n7.10 数组类型  160\n7.11 类数组对象  161\n7.12 作为数组的字符串  163\n第8章 函数  165\n8.1 函数定义  166\n8.2 函数调用  168\n8.3 函数的实参和形参  173\n8.4 作为值的函数  178\n8.5 作为命名空间的函数  181\n8.6 闭包  182\n8.7 函数属性、方法和构造函数  188\n8.8 函数式编程  194\n第9章 类和模块  201\n9.1 类和原型  202\n9.2 类和构造函数  203\n9.3 JavaScript中Java式的类继承  207\n9.4 类的扩充  210\n9.5 类和类型  212\n9.6 JavaScript中的面向对象技术  217\n9.7 子类  230\n9.8 ECMAScript 5 中的类  239\n9.9 模块  248\n第10章 正则表达式的模式匹配  253\n10.1 正则表达式的定义  253\n10.2 用于模式匹配的String方法  261\n10.3 RegExp对象  263\n第11章 JavaScript的子集和扩展  267\n11.1 JavaScript的子集  268\n11.2 常量和局部变量  271\n11.3 解构赋值  274\n11.4 迭代  276\n11.5 函数简写  285\n11.6 多Catch 从句  285\n11.7 E4X: ECMAScript for XML  286\n第12章 服务器端JavaScript  290\n12.1 用Rhino脚本化Java  291\n12.2 用Node实现异步I/O  297\n第二部分 客户端JavaScript\n第13章 Web浏览器中的JavaScript  309\n13.1 客户端JavaScript  309\n13.2 在HTML里嵌入JavaScript  313\n13.3 JavaScript程序的执行  319\n13.4 兼容性和互用性  326\n13.5 可访问性  333\n13.6 安全性  334\n13.7 客户端框架  339\n第14章 Window对象  341\n14.1 计时器  342\n14.2 浏览器定位和导航  343\n14.3 浏览历史  345\n14.4 浏览器和屏幕信息  346\n14.5 对话框  348\n14.6 错误处理  351\n14.7 作为Window对象属性的文档元素  351\n14.8 多窗口和窗体  353\n第15章 脚本化文档  361\n15.1 DOM概览  362\n15.2 选取文档元素  364\n15.3 文档结构和遍历  371\n15.4 属性  375\n15.5 元素的内容  378\n15.6 创建、插入和删除节点  382\n15.7 例子：生成目录表  387\n15.8 文档和元素的几何形状和滚动  389\n15.9 HTML表单  396\n15.10 其他文档特性  404\n第16章 脚本化CSS  410\n16.1 CSS概览  411\n16.2 重要的CSS属性  416\n16.3 脚本化内联样式  427\n16.4 查询计算出的样式  431\n16.5 脚本化CSS类  433\n16.6 脚本化样式表  435\n第17章 事件处理  440\n17.1 事件类型  442\n17.2 注册事件处理程序  451\n17.3 事件处理程序的调用  454\n17.4 文档加载事件  459\n17.5 鼠标事件  461\n17.6 鼠标滚轮事件  465\n17.7 拖放事件  468\n17.8 文本事件  475\n17.9 键盘事件  478\n第18章 脚本化HTTP  484\n18.1 使用XMLHttpRequest  487\n18.2 借助<script>发送HTTP请求：JSONP  505\n18.3 基于服务器端推送事件的Comet技术  508\n第19章 jQuery类库  514\n19.1 jQuery基础  515\n19.2 jQuery的getter和setter  522\n19.3 修改文档结构  528\n19.4 用jQuery处理事件  531\n19.5 动画效果  542\n19.6 jQuery中的Ajax  550\n19.7 工具函数  563\n19.8 jQuery选择器和选取方法  566\n19.9 jQuery的插件扩展  574\n19.10 jQuery UI类库  577\n第20章 客户端存储  579\n20.1 localStorage和sessionStorage  581\n20.2 cookie  586\n20.3 利用IE userData来持久化数据  592\n20.4 应用程序存储和离线Web应用  594\n第21章 多媒体和图形编程  606\n21.1 脚本化图片  606\n21.2 脚本化音频和视频  608\n21.3 SVG：可伸缩的矢量图形  615\n21.4 <canvas>中的图形  623\n第22章 HTML5 API  658\n22.1 地理位置  659\n22.2 历史记录管理  662\n22.3 跨域消息传递  668\n22.4 Web Workers  671\n22.5 类型化数组和ArrayBuffer  678\n22.6 Blob  682\n22.7 文件系统API  691\n22.8 客户端数据库  696\n22.9 Web套接字  704\n第三部分 JavaScript核心参考\nJavaScript核心参考  711\n第四部分 客户端JavaScript参考\n客户端JavaScript参考  847",
        "pages": "1004",
        "images": {
          "small": "https://img3.doubanio.com/spic/s8958854.jpg",
          "large": "https://img3.doubanio.com/lpic/s8958854.jpg",
          "medium": "https://img3.doubanio.com/mpic/s8958854.jpg"
        },
        "alt": "https://book.douban.com/subject/10549733/",
        "id": "10549733",
        "publisher": "机械工业出版社华章公司",
        "isbn10": "7111376617",
        "isbn13": "9787111376613",
        "title": "JavaScript权威指南(第6版)",
        "url": "https://api.douban.com/v2/book/10549733",
        "alt_title": "JavaScript: The Definitive Guide, Sixth Edition",
        "author_intro": "David Flanagan是一名程序员，也是一名作家，它的个人网站是http://davidflanagan.com。他在O'Reilly出版的其他畅销书还包括《JavaScript Pocket Reference》、《The Ruby Programming Language》，以及《Java in a Nutshell》。David毕业于麻生理工学院，获得计算机科学与工程学位。他和妻子和孩子一起生活在西雅图和温哥华之间的美国太平洋西北海岸。",
        "summary": "本书是程序员学习核心JavaScript语言和由Web浏览器定义的JavaScript API的指南和综合参考手册。\n第6版涵盖HTML 5和ECMAScript 5。很多章节完全重写，以便与时俱进，紧跟当今的最佳Web开发实践。本书新增章节描述了jQuery和服务器端JavaScript。\n本书适合那些希望学习Web编程语言的初、中级程序员和希望精通JavaScript的JavaScript程序员阅读。",
        "series": {
          "id": "697",
          "title": "博文视点O'reilly系列"
        },
        "price": "139.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "77be2af91bad103bcde85c352787a745f10b3216f365928554d85ce0a3d5fc5d",
        "file": "javascript权威指南中文第六版.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 369,
          "average": "9.4",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[美] Kyle Simpson"
        ],
        "pubdate": "2015-4",
        "tags": [
          {
            "count": 453,
            "name": "JavaScript",
            "title": "JavaScript"
          },
          {
            "count": 208,
            "name": "前端开发",
            "title": "前端开发"
          },
          {
            "count": 118,
            "name": "javascript",
            "title": "javascript"
          },
          {
            "count": 111,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 105,
            "name": "前端",
            "title": "前端"
          },
          {
            "count": 73,
            "name": "Web前端开发",
            "title": "Web前端开发"
          },
          {
            "count": 71,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 58,
            "name": "Web",
            "title": "Web"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s28033372.jpg",
        "binding": "平装",
        "translator": [
          "赵望野",
          "梁杰"
        ],
        "catalog": "前言　　VIII\n第一部分　作用域和闭包\n序　　2\n第1章　作用域是什么　　4\n1.1　编译原理　　4\n1.2　理解作用域　　6\n1.2.1　演员表　　6\n1.2.2　对话　　6\n1.2.3　编译器有话说　　7\n1.2.4　引擎和作用域的对话　　9\n1.2.5　小测验　　10\n1.3　作用域嵌套　　10\n1.4　异常　　12\n1.5　小结　　12\n第2章　词法作用域　　14\n2.1　词法阶段　　14\n2.2　欺骗词法　　17\n2.2.1　eval　　17\n2.2.2　with　　18\n2.2.3　性能　　20\n2.3　小结　　21\n第3章　函数作用域和块作用域　　22\n3.1　函数中的作用域　　22\n3.2　隐藏内部实现　　23\n3.3　函数作用域　　26\n3.3.1　匿名和具名　　27\n3.3.2　立即执行函数表达式　　28\n3.4　块作用域　　30\n3.4.1　with　　31\n3.4.2　try/catch　　31\n3.4.3　let　　32\n3.4.4　const　　35\n3.5　小结　　36\n第4章　提升　　37\n4.1　先有鸡还是先有蛋　　37\n4.2　编译器再度来袭　　38\n4.3　函数优先　　40\n4.4　小结　　41\n第5章　作用域闭包　　43\n5.1　启示　　43\n5.2　实质问题　　44\n5.3　现在我懂了　　47\n5.4　循环和闭包　　48\n5.5　模块　　51\n5.5.1　现代的模块机制　　54\n5.5.2　未来的模块机制　　56\n5.6　小结　　57\n附录A　动态作用域　　58\n附录B　块作用域的替代方案　　60\n附录C　this词法　　64\n附录D　致谢　　67\n第二部分　this和对象原型\n序　　72\n第1章　关于this　　74\n1.1　为什么要用this　　74\n1.2　误解　　76\n1.2.1　指向自身　　76\n1.2.2　它的作用域　　79\n1.3　this到底是什么　　80\n1.4　小结　　80\n第2章　this全面解析　　82\n2.1　调用位置　　82\n2.2　绑定规则　　83\n2.2.1　默认绑定　　83\n2.2.2　隐式绑定　　85\n2.2.3　显式绑定　　87\n2.2.4　new绑定　　90\n2.3　优先级　　91\n2.4　绑定例外　　95\n2.4.1　被忽略的this　　96\n2.4.2　间接引用　　97\n2.4.3　软绑定　　98\n2.5　this词法　　99\n2.6　小结　　101\n第3章　对象　　102\n3.1　语法　　102\n3.2　类型　　103\n3.3　内容　　105\n3.3.1　可计算属性名　　106\n3.3.2　属性与方法　　107\n3.3.3　数组　　108\n3.3.4　复制对象　　109\n3.3.5　属性描述符　　111\n3.3.6　不变性　　114\n3.3.7　[[Get]]　　115\n3.3.8　[[Put]]　　116\n3.3.9　Getter和Setter　　117\n3.3.10　存在性　　119\n3.4　遍历　　121\n3.5　小结　　124\n第4章　混合对象“类”　　126\n4.1　类理论　　126\n4.1.1　“类”设计模式　　127\n4.1.2　JavaScript中的“类”　　128\n4.2　类的机制　　128\n4.2.1　建造　　128\n4.2.2　构造函数　　130\n4.3　类的继承　　130\n4.3.1　多态　　132\n4.3.2　多重继承　　134\n4.4　混入　　134\n4.4.1　显式混入　　135\n4.4.2　隐式混入　　139\n4.5　小结　　140\n第5章　原型　　142\n5.1　[[Prototype]]　　142\n5.1.1　Object.prototype　　144\n5.1.2　属性设置和屏蔽　　144\n5.2　“类”　　146\n5.2.1　“类”函数　　146\n5.2.2　“构造函数”　　149\n5.2.3　技术　　151\n5.3　（原型）继承　　153\n5.4　对象关联　　159\n5.4.1　创建关联　　159\n5.4.2　关联关系是备用　　161\n5.5　小结　　162\n第6章　行为委托　　164\n6.1　面向委托的设计　　165\n6.1.1　类理论　　165\n6.1.2　委托理论　　166\n6.1.3　比较思维模型　　170\n6.2　类与对象　　173\n6.2.1　控件“类”　　174\n6.2.2　委托控件对象　　176\n6.3　更简洁的设计　　178\n6.4　更好的语法　　182\n6.5　内省　　185\n6.6　小结　　187\n附录A　ES6中的Class　　189",
        "ebook_url": "https://read.douban.com/ebook/12051836/",
        "pages": "195",
        "images": {
          "small": "https://img3.doubanio.com/spic/s28033372.jpg",
          "large": "https://img3.doubanio.com/lpic/s28033372.jpg",
          "medium": "https://img3.doubanio.com/mpic/s28033372.jpg"
        },
        "alt": "https://book.douban.com/subject/26351021/",
        "id": "26351021",
        "publisher": "人民邮电出版社",
        "isbn10": "7115385734",
        "isbn13": "9787115385734",
        "title": "你不知道的JavaScript（上卷）",
        "url": "https://api.douban.com/v2/book/26351021",
        "alt_title": "",
        "author_intro": "作者简介：\nKyle Simpson\n推崇开放的互联网，对JavaScript、HTML5、实时/端对端通信和Web性能有深入研究。他是技术书作家、技术培训师、讲师和开源社区的活跃成员。\n译者简介：\n赵望野\n前端工程师，前端基础技术组leader，曾经负责豌豆荚2.0的前端架构设计和主要开发工作，目前负责Front-end Technical Infrastructure的建设。新浪微博@赵望野。负责本书第一部分“作用域和闭包”的翻译。\n梁杰\n北京航空航天大学计算机科学与技术专业大四学生。热爱JavaScript、Python，热爱开源，喜欢做各种各样有趣的事情。负责本书第二部分“this和对象原型”的翻译。",
        "summary": "JavaScript语言有很多复杂的概念，但却用简单的方式体现出来（比如回调函数），因此，JavaScript开发者无需理解语言内部的原理，就能编写出功能全面的程序；就像收音机一样，你无需理解里面的管子和线圈都是做什么用的，只要会操作收音机上的按键，就可以收听你喜欢的节目。然而，JavaScript的这些复杂精妙的概念才是语言的精髓，即使是经验丰富的JavaScript开发者，如果没有认真学习也无法真正理解语言本身的特性。正是因为绝大多数人不求甚解，一遇到出乎意料的行为就认为是语言本身有缺陷，进而把相关的特性加入黑名单，久而久之就排除了这门语言的多样性，人为地使它变得不完整、不安全。\n“你不知道的JavaScript”系列就是要让不求甚解的JavaScript开发者迎难而上，深入语言内部，弄清楚JavaScript每一个零部件的用途。本书介绍了该系列的两个主题：“作用域和闭包”以及“this和对象原型”。掌握了这些知识之后，无论什么技术、框架和流行词语，你都能轻松理解。",
        "ebook_price": "24.99",
        "price": "49.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "d2864d7545a251e9475fc1db90266ae8143413bc5b602bd8e132a25d2acbc723",
        "file": "你不知道的JavaScript(上卷).epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 95,
          "average": "9.1",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[美] Kyle Simpson"
        ],
        "pubdate": "2016-8",
        "tags": [
          {
            "count": 116,
            "name": "JavaScript",
            "title": "JavaScript"
          },
          {
            "count": 49,
            "name": "前端开发",
            "title": "前端开发"
          },
          {
            "count": 36,
            "name": "javascript",
            "title": "javascript"
          },
          {
            "count": 29,
            "name": "前端",
            "title": "前端"
          },
          {
            "count": 28,
            "name": "Web前端开发",
            "title": "Web前端开发"
          },
          {
            "count": 22,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 15,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 7,
            "name": "WebApp",
            "title": "WebApp"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s28969600.jpg",
        "binding": "平装",
        "translator": [
          "单业",
          "姜南"
        ],
        "catalog": "前言 XI\n第一部分　类型和语法\n序　　2\n第1章 　类型　　3\n1.1　类型　　4\n1.2　内置类型　　4\n1.3　值和类型　　6\n1.3.1　undefined 和undeclared　　6\n1.3.2　typeof Undeclared　　7\n1.4　小结　　10\n第2章　值　　11\n2.1　数组　　11\n2.2　字符串　　13\n2.3　数字　　15\n2.3.1　数字的语法　　16\n2.3.2　较小的数值　　18\n2.3.3　整数的安全范围　　19\n2.3.4　整数检测　　20\n2.3.5　32 位有符号整数　　20\n2.4　特殊数值　　21\n2.4.1　不是值的值　　21\n2.4.2　undefined　　21\n2.4.3　特殊的数字　　23\n2.4.4　特殊等式　　27\n2.5　值和引用　　28\n2.6　小结　　31\n第3章　原生函数　　33\n3.1　内部属性[[Class]]　　34\n3.2　封装对象包装　　35\n3.3　拆封　　36\n3.4　原生函数作为构造函数　　37\n3.4.1　Array(..)　　37\n3.4.2　Object(..)、Function(..) 和RegExp(..)　　40\n3.4.3　Date(..) 和Error(..)　　41\n3.4.4　Symbol(..)　　42\n3.4.5　原生原型　　43\n3.5　小结　　45\n第4章　强制类型转换　　46\n4.1　值类型转换　　46\n4.2　抽象值操作　　47\n4.2.1　ToString　　48\n4.2.2　ToNumber　　52\n4.2.3　ToBoolean　　53\n4.3　显式强制类型转换　　56\n4.3.1　字符串和数字之间的显式转换　　57\n4.3.2　显式解析数字字符串　　62\n4.3.3　显式转换为布尔值　　65\n4.4　隐式强制类型转换　　67\n4.4.1　隐式地简化　　67\n4.4.2　字符串和数字之间的隐式强制类型转换　　68\n4.4.3　布尔值到数字的隐式强制类型转换　　71\n4.4.4　隐式强制类型转换为布尔值　　72\n4.4.5　|| 和&&　　73\n4.4.6　符号的强制类型转换　　76\n4.5　宽松相等和严格相等　　77\n4.5.1　相等比较操作的性能　　77\n4.5.2　抽象相等\n4.6　抽象关系比较　　89\n4.7　小结　　91\n第5章　语法　　92\n5.1　语句和表达式　　92\n5.1.1　语句的结果值　　93\n5.1.2　表达式的副作用　　95\n5.1.3　上下文规则　　99\n5.2　运算符优先级　　104\n5.2.1　短路　　107\n5.2.2　更强的绑定　　107\n5.2.3　关联　　108\n5.2.4　释疑　　110\n5.3　自动分号　　111\n5.4　错误　　113\n5.5　函数参数　　115\n5.6　try..finally　　117\n5.7　switch　　120\n5.8　小结　　122\n附录A　混合环境JavaScript　　123\n第二部分　异步和性能\n序　　136\n第1章　异步：现在与将来　　138\n1.1　分块的程序　　139\n1.2　事件循环　　141\n1.3　并行线程　　143\n1.4　并发　　148\n1.4.1　非交互　　150\n1.4.2　交互　　150\n1.4.3　协作　　154\n1.5　任务　　156\n1.6　语句顺序　　157\n1.7　小结　　159\n第2章　回调　　161\n2.1　continuation　　162\n2.2　顺序的大脑　　163\n2.2.1　执行与计划　　164\n2.2.2　嵌套回调与链式回调　　165\n2.3　信任问题　　169\n2.3.1　五个回调的故事　　170\n2.3.2　不只是别人的代码　　171\n2.4　省点回调　　173\n2.5　小结　　176\n第3章　Promise　　178\n3.1　什么是Promise　　179\n3.1.1　未来值　　179\n3.1.2　完成事件　　183\n3.2　具有then 方法的鸭子类型　　188\n3.3　Promise 信任问题　　190\n3.3.1　调用过早　　190\n3.3.2　调用过晚　　191\n3.3.3　回调未调用　　192\n3.3.4　调用次数过少或过多　　193\n3.3.5　未能传递参数/ 环境值　　193\n3.3.6　吞掉错误或异常　　194\n3.3.7　是可信任的Promise 吗　　195\n3.3.8　建立信任　　197\n3.4　链式流　　198\n3.5　错误处理　　206\n3.5.1　绝望的陷阱　　208\n3.5.2　处理未捕获的情况　　209\n3.5.3　成功的坑　　211\n3.6　Promise 模式　　212\n3.6.1　Promise.all([ .. ])　　212\n3.6.2　Promise.race([ .. ])　　213\n3.6.3　all([ .. ]) 和race([ .. ]) 的变体　　216\n3.6.4　并发迭代　　217\n3.7　Promise API 概述　　219\n3.7.1　new Promise(..) 构造器　　219\n3.7.2　Promise.resolve(..) 和Promise.reject(..)　　219\n3.7.3　then(..) 和catch(..)　　220\n3.7.4　Promise.all([ .. ]) 和Promise.race([ .. ])　　221\n3.8　Promise 局限性　　222\n3.8.1　顺序错误处理　　222\n3.8.2　单一值　　223\n3.8.3　单决议　　225\n3.8.4　惯性　　227\n3.8.5　无法取消的Promise　　230\n3.8.6　Promise 性能　　231\n3.9　小结　　233\n第4章　生成器　　234\n4.1　打破完整运行　　234\n4.1.1　输入和输出　　236\n4.1.2　多个迭代器　　239\n4.2　生成器产生值　　243\n4.2.1　生产者与迭代器　　243\n4.2.2　iterable　　246\n4.2.3　生成器迭代器　　247\n4.3　异步迭代生成器　　250\n4.4　生成器+Promise　　254\n4.4.1　支持Promise 的Generator Runner　　256\n4.4.2　生成器中的Promise 并发　　258\n4.5　生成器委托　　262\n4.5.1　为什么用委托　　264\n4.5.2　消息委托　　264\n4.5.3　异步委托　　268\n4.5.4　递归委托　　268\n4.6　生成器并发　　269\n4.7　形实转换程序　　273\n4.8　ES6 之前的生成器　　279\n4.8.1　手工变换　　280\n4.8.2　自动转换　　284\n4.9　小结　　285\n第5章　程序性能　　287\n5.1　Web Worker　　288\n5.1.1　Worker 环境　　290\n5.1.2　数据传递　　291\n5.1.3　共享Worker　　291\n5.1.4　模拟Web Worker　　293\n5.2　SIMD　　293\n5.3　asm.js　　295\n5.3.1　如何使用asm.js 优化　　295\n5.3.2　asm.js 模块　　296\n5.4　小结　　298\n第6章　性能测试与调优　　299\n6.1　性能测试　　99\n6.1.1　重复　　300\n6.1.2　Benchmark.js　　301\n6.2　环境为王　　303\n6.3　jsPerf.com　　305\n6.4　写好测试　　309\n6.5　微性能　　309\n6.5.1　不是所有的引擎都类似　　312\n6.5.2　大局　　314\n6.6　尾调用优化　　316\n6.7　小结　　318\n附录A　asynquence 库　　319\n附录B　高级异步模式　　339",
        "pages": "358",
        "images": {
          "small": "https://img3.doubanio.com/spic/s28969600.jpg",
          "large": "https://img3.doubanio.com/lpic/s28969600.jpg",
          "medium": "https://img3.doubanio.com/mpic/s28969600.jpg"
        },
        "alt": "https://book.douban.com/subject/26854244/",
        "id": "26854244",
        "publisher": "人民邮电出版社",
        "isbn10": "7115431167",
        "isbn13": "9787115431165",
        "title": "你不知道的JavaScript（中卷）",
        "url": "https://api.douban.com/v2/book/26854244",
        "alt_title": "",
        "author_intro": "<作者介绍>\nKyle Simpson\n作家、培训师、讲师、开源社区的活跃成员，推崇开放的互联网，对JavaScript、HTML5、实时/端对端通信和Web性能有深入研究。\n<译者介绍>\n单业\n计算机专业硕士，软件工程师，曾供职于多家软件公司，从事软件开发工作，现居于上海。负责本书第二部分“异步和性能”的翻译。\n姜南\n从事过国内外金融、通信、移动互联网、数字出版等领域的IT系统开发工作，擅长的技术有Java、C#、HTML5、JavaScript、iOS、Android等。长期在独立技术博客——酷壳（coolshell.cn）发表翻译文章。负责本书第一部分“类型和语法”的翻译。",
        "summary": "JavaScript这门语言简单易用，很容易上手，但其语言机制复杂微妙，即使是经验丰富的JavaScript开发人员，如果没有认真学习的话也无法真正理解。本套书直面当前JavaScript开发人员不求甚解的大趋势，深入理解语言内部的机制，全面介绍了JavaScript中常被人误解和忽视的重要知识点。本书是其中卷，主要介绍了类型、语法、异步和性能。",
        "price": "79.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "2e2faea109a7e42d07aac1c737148f0b230fad3bc4d0312eac3c59efae6a2b6c",
        "file": "你不知道的JavaScript(中卷).epub"
      },
      {
        "title": "你不知道的JavaScript（下卷）",
        "subtitle": "",
        "author": [
          "[美] Kyle Simpson"
        ],
        "summary": "JavaScript这门语言简单易用，很容易上手，但其语言机制复杂微妙，即使是经验丰富的JavaScript开发人员，如果没有认真学习的话也无法真正理解。本套书直面当前JavaScript开发人员不求甚解的大趋势，深入理解语言内部的机制，全面介绍了JavaScript中常被人误解和忽视的重要知识点。本书是其下卷，主要介绍了JavaScript入门知识和对ES6及未来发展趋势的展望。",
        "publisher": "人民邮电出版社",
        "isbn13": "9787115471659",
        "isbn10": "7115471657",
        "tags": [
          {
            "title": "JavaScript",
            "name": "JavaScript",
            "count": 81
          },
          {
            "title": "编程",
            "name": "编程",
            "count": 21
          },
          {
            "title": "前端开发",
            "name": "前端开发",
            "count": 21
          },
          {
            "title": "前端",
            "name": "前端",
            "count": 16
          },
          {
            "title": "Web前端开发",
            "name": "Web前端开发",
            "count": 15
          },
          {
            "title": "javascript",
            "name": "javascript",
            "count": 14
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 11
          },
          {
            "title": "技术",
            "name": "技术",
            "count": 6
          }
        ],
        "pubdate": "2018-1-1",
        "translator": [
          "单业"
        ],
        "binding": "平装",
        "author_intro": "作者:[美]凯尔?辛普森（Kyle Simpson） 译者:单业\nKyle Simpson，推崇开放的互联网，对JavaScript、HTML5、实时/端对端通信和Web性能有深入研究。他是技术书作家、技术培训师、讲师和开源社区的活跃成员。",
        "rating": {
          "average": 8.0,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 86.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "9d518b08fea3cdc79e222c461112d41d6c111d89d005b3346b73c85dee2183e4",
        "file": "你不知道的JavaScript-下卷.epub"
      },
      {
        "timestamp": "2015-04-04T19:21:29.576313+00:00",
        "publisher": "GitBook",
        "creator": "Leo Hui",
        "contributor": "GitBook",
        "title": "前端工程师手册",
        "language": "zh",
        "description": "都是一些自己的收藏和记录。",
        "identifier": {
          "uuid": "6a1c45fe-fd7c-45ae-a2a0-d21663ff58b4"
        },
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "bf75fd0f35b9eb072a9b1cb7276d47b4435904692c9c42ed2e8ab1ce63d31a22",
        "file": "前端工程师手册.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 100,
          "average": "6.5",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[美] Michael McMillan"
        ],
        "pubdate": "2014-8",
        "tags": [
          {
            "count": 102,
            "name": "JavaScript",
            "title": "JavaScript"
          },
          {
            "count": 60,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 25,
            "name": "Web前端",
            "title": "Web前端"
          },
          {
            "count": 21,
            "name": "数据结构",
            "title": "数据结构"
          },
          {
            "count": 18,
            "name": "前端",
            "title": "前端"
          },
          {
            "count": 11,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 8,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 8,
            "name": "web",
            "title": "web"
          }
        ],
        "origin_title": "Data Structures and Algorithms with JavaScript",
        "image": "https://img1.doubanio.com/mpic/s27371758.jpg",
        "binding": "平装",
        "translator": [
          "王群锋",
          "杜　欢"
        ],
        "catalog": "推荐序　　XI\n前言　　XII\n第1章　JavaScript的编程环境和模型　　1\n1.1　JavaScript环境　　1\n1.2　JavaScript编程实践　　2\n1.2.1　声明和初始化变量　　3\n1.2.2　JavaScript中的算术运算和数学库函数　　3\n1.2.3　判断结构　　4\n1.2.4　循环结构　　6\n1.2.5　函数　　7\n1.2.6　变量作用域　　7\n1.2.7　递归　　9\n1.3　对象和面向对象编程　　10\n1.4　小结　　11\n第2章　数组　　13\n2.1　JavaScript中对数组的定义　　13\n2.2　使用数组　　13\n2.2.1　创建数组　　14\n2.2.2　读写数组　　15\n2.2.3　由字符串生成数组　　15\n2.2.4　对数组的整体性操作　　16\n2.3　存取函数　　17\n2.3.1　查找元素　　17\n2.3.2　数组的字符串表示　　18\n2.3.3　由已有数组创建新数组　　18\n2.4　可变函数　　19\n2.4.1　为数组添加元素　　19\n2.4.2　从数组中删除元素　　20\n2.4.3　从数组中间位置添加和删除元素　　21\n2.4.4　为数组排序　　21\n2.5　迭代器方法　　22\n2.5.1　不生成新数组的迭代器方法　　22\n2.5.2　生成新数组的迭代器方法　　25\n2.6　二维和多维数组　　27\n2.6.1　创建二维数组　　27\n2.6.2　处理二维数组的元素　　28\n2.6.3　参差不齐的数组　　29\n2.7　对象数组　　30\n2.8　对象中的数组　　31\n2.9　练习　　32\n第3章　列表　　33\n3.1　列表的抽象数据类型定义　　33\n3.2　实现列表类　　34\n3.2.1　append：给列表添加元素　　35\n3.2.2　remove：从列表中删除元素　　35\n3.2.3　find：在列表中查找某一元素　　35\n3.2.4　length：列表中有多少个元素　　36\n3.2.5　toString：显示列表中的元素　　36\n3.2.6　insert：向列表中插入一个元素　　37\n3.2.7　clear：清空列表中所有的元素　　37\n3.2.8　contains：判断给定值是否在列表中　　37\n3.2.9　遍历列表　　38\n3.3　使用迭代器访问列表　　39\n3.4　一个基于列表的应用　　40\n3.4.1　读取文本文件　　40\n3.4.2　使用列表管理影碟租赁　　41\n3.5　练习　　44\n第4章　栈　　45\n4.1　对栈的操作　　45\n4.2　栈的实现　　46\n4.3　使用Stack类　　48\n4.3.1　数制间的相互转换　　49\n4.3.2　回文　　50\n4.3.3　递归演示　　51\n4.4　练习　　52\n第5章　队列　　53\n5.1　对队列的操作　　53\n5.2　一个用数组实现的队列　　54\n5.3　使用队列：方块舞的舞伴分配问题　　57\n5.4　使用队列对数据进行排序　　61\n5.5　优先队列　　63\n5.6　练习　　65\n第6章　链表　　67\n6.1　数组的缺点　　67\n6.2　定义链表　　67\n6.3　设计一个基于对象的链表　　69\n6.3.1　Node类　　69\n6.3.2　LinkedList类　　69\n6.3.3　插入新节点　　69\n6.3.4　从链表中删除一个节点　　71\n6.4　双向链表　　74\n6.5　循环链表　　78\n6.6　链表的其他方法　　79\n6.7　练习　　79\n第7章　字典　　81\n7.1　Dictionary类　　81\n7.2　Dictionary类的辅助方法　　83\n7.3　为Dictionary类添加排序功能　　85\n7.4　练习　　86\n第8章　散列　　87\n8.1　散列概览　　87\n8.2　HashTable类　　88\n8.2.1　选择一个散列函数　　88\n8.2.2　一个更好的散列函数　　91\n8.2.3　散列化整型键　　93\n8.2.4　对散列表排序、从散列表中取值　　95\n8.3　碰撞处理　　96\n8.3.1　开链法　　96\n8.3.2　线性探测法　　99\n8.4　练习　　100\n第9章　集合　　101\n9.1　集合的定义、操作和属性　　101\n9.1.1　集合的定义　　101\n9.1.2　对集合的操作　　102\n9.2　Set类的实现　　102\n9.3　更多集合操作　　104\n9.4　练习　　107\n第10章　二叉树和二叉查找树　　109\n10.1　树的定义　　109\n10.2　二叉树和二叉查找树　　111\n10.2.1　实现二叉查找树　　111\n10.2.2　遍历二叉查找树　　113\n10.3　在二叉查找树上进行查找　　116\n10.3.1　查找最小值和最大值　　116\n10.3.2　查找给定值　　117\n10.4　从二叉查找树上删除节点　　118\n10.5　计数　　120\n10.6　练习　　123\n第11章　图和图算法　　125\n11.1　图的定义　　125\n11.2　用图对现实中的系统建模　　127\n11.3　图类　　127\n11.3.1　表示顶点　　127\n11.3.2　表示边　　127\n11.3.3　构建图　　128\n11.4　搜索图　　130\n11.4.1　深度优先搜索　　130\n11.4.2　广度优先搜索　　133\n11.5　查找最短路径　　135\n11.5.1　广度优先搜索对应的最短路径　　135\n11.5.2　确定路径　　135\n11.6　拓扑排序　　137\n11.6.1　拓扑排序算法　　137\n11.6.2　实现拓扑排序算法　　137\n11.7　练习　　141\n第12章　排序算法　　143\n12.1　数组测试平台　　143\n12.2　基本排序算法　　145\n12.2.1　冒泡排序　　145\n12.2.2　选择排序　　148\n12.2.3　插入排序　　150\n12.2.4　基本排序算法的计时比较　　151\n12.3　高级排序算法　　153\n12.3.1　希尔排序　　153\n12.3.2　归并排序　　158\n12.3.3　快速排序　　163\n12.4　练习　　167\n第13章　检索算法　　169\n13.1　顺序查找　　169\n13.1.1　查找最小值和最大值　　172\n13.1.2　使用自组织数据　　175\n13.2　二分查找算法　　177\n13.3　查找文本数据　　183\n13.4　练习　　185\n第14章　高级算法　　187\n14.1　动态规划　　187\n14.1.1　动态规划实例：计算斐波那契数列　　188\n14.1.2　寻找最长公共子串　　191\n14.1.3　背包问题：递归解决方案　　194\n14.1.4　背包问题：动态规划方案　　195\n14.2　贪心算法　　196\n14.2.1　第一个贪心算法案例：找零问题　　196\n14.2.2　背包问题的贪心算法解决方案　　197\n14.3　练习　　199\n封面介绍　　200",
        "ebook_url": "https://read.douban.com/ebook/12053043/",
        "pages": "216",
        "images": {
          "small": "https://img1.doubanio.com/spic/s27371758.jpg",
          "large": "https://img1.doubanio.com/lpic/s27371758.jpg",
          "medium": "https://img1.doubanio.com/mpic/s27371758.jpg"
        },
        "alt": "https://book.douban.com/subject/25945449/",
        "id": "25945449",
        "publisher": "人民邮电出版社",
        "isbn10": "7115363390",
        "isbn13": "9787115363398",
        "title": "数据结构与算法JavaScript描述",
        "url": "https://api.douban.com/v2/book/25945449",
        "alt_title": "Data Structures and Algorithms with JavaScript",
        "author_intro": "作者简介：\nMichael McMillan\n作为大学老师和程序员，曾编写过多部受到好评的数据结构与算法图书，包括Data Structures and Algorithms Using C#、Data Structures and Algorithms Using Visual Basic.NET，以及其他计算机教程，如Object-Oriented Programming with Visual Basic.NET、C++ Programming: An Introduction、Java Programming Tutorial、Perl from the Ground Up等。Michael现在阿肯色州北小石城普瓦斯基技术学院当讲师，教授计算机信息系统。他还是北小石城阿肯色大学的兼职讲师，教授信息科学。在做讲师之前，他曾是阿肯色儿童医院的一名程序设计师/分析师，负责统计计算和数据分析。\n译者简介：\n王群锋\n1981年生于陕西省富平县桥西大队三里村，2004年毕业于西安电子科技大学。毕业后当了一名程序员，现居西安，在IBM西安研发中心从事下一代统计预测软件的开发工作。\n杜欢\n淘宝网高级技术专家，2012年加入淘宝，曾就职于雅虎台湾及CISCO。对前端架构、前后端协作有自己的见解，专注于Web产品设计、可用性实施，热爱标准化。",
        "summary": "通过本书的学习，读者将能自如地选择最合适的数据结构与算法，并在JavaScript开发中懂得权衡使用。此外，本书也概述了与数据结构与算法相关的JavaScript特性。\n本书主要内容如下。\n数组和列表：最常用的数据结构。\n栈和队列：与列表类似但更复杂的数据结构。\n链表：如何通过它们克服数组的不足。\n字典：将数据以键-值对的形式存储。\n散列：适用于快速查找和检索。\n集合：适用于存储只出现一次的元素。\n二叉树：以层级的形式存储数据。\n图和图算法：网络建模的理想选择。\n算法：包括排序或搜索数据的算法。\n高级算法：动态规划和贪心算法。",
        "ebook_price": "29.99",
        "price": "49.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "6175e8f3ff78363a36f85ec023434ea5d61bfc5fcba9ec65da035f6b6afce08e",
        "file": "数据结构与算法JavaScript描述.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 712,
          "average": "8.5",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "朴灵"
        ],
        "pubdate": "2013-12-1",
        "tags": [
          {
            "count": 752,
            "name": "node.js",
            "title": "node.js"
          },
          {
            "count": 419,
            "name": "JavaScript",
            "title": "JavaScript"
          },
          {
            "count": 216,
            "name": "Node.js",
            "title": "Node.js"
          },
          {
            "count": 200,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 164,
            "name": "Web",
            "title": "Web"
          },
          {
            "count": 125,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 109,
            "name": "nodejs",
            "title": "nodejs"
          },
          {
            "count": 78,
            "name": "技术",
            "title": "技术"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s27269296.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "第1章　Node简介　　1\n1.1 　Node的诞生历程　　1\n1.2 　Node的命名与起源　　1\n1.2.1 　为什么是JavaScript　　2\n1.2.2 　为什么叫Node　　2\n1.3 　Node给JavaScript带来的意义　　2\n1.4 　Node的特点　　4\n1.4.1 　异步I/O　　4\n1.4.2 　事件与回调函数　　6\n1.4.3 　单线程　　7\n1.4.4 　跨平台　　7\n1.5 　Node的应用场景　　8\n1.5.1 　I/O密集型　　8\n1.5.2 　是否不擅长CPU密集型业务　　8\n1.5.3 　与遗留系统和平共处　　10\n1.5.4 　分布式应用　　10\n1.6 　Node的使用者　　10\n1.7 　参考资源　　11\n第2章　模块机制　　12\n2.1 　CommonJS规范　　13\n2.1.1 　CommonJS的出发点　　13\n2.1.2 　CommonJS的模块规范　　14\n2.2 　Node的模块实现　　15\n2.2.1 　优先从缓存加载　　16\n2.2.2 　路径分析和文件定位　　16\n2.2.3 　模块编译　　18\n2.3 　核心模块　　20\n2.3.1 　JavaScript核心模块的编译过程　　21\n2.3.2 　C/C++核心模块的编译过程　　22\n2.3.3 　核心模块的引入流程　　25\n2.3.4 　编写核心模块　　25\n2.4 　C/C++扩展模块　　27\n2.4.1 　前提条件　　28\n2.4.2 　C/C++扩展模块的编写　　29\n2.4.3 　C/C++扩展模块的编译　　30\n2.4.4 　C/C++扩展模块的加载　　31\n2.5 　模块调用栈　　32\n2.6 　包与NPM　　33\n2.6.1 　包结构　　34\n2.6.2 　包描述文件与NPM　　34\n2.6.3 　NPM常用功能　　37\n2.6.4 　局域NPM　　42\n2.6.5 　NPM潜在问题　　43\n2.7 　前后端共用模块　　44\n2.7.1 　模块的侧重点　　44\n2.7.2 　AMD规范　　44\n2.7.3 　CMD规范　　45\n2.7.4 　兼容多种模块规范　　45\n2.8 　总结　　46\n2.9 　参考资源　　46\n第3章　异步I/O　　47\n3.1 　为什么要异步I/O　　47\n3.1.1 　用户体验　　48\n3.1.2 　资源分配　　49\n3.2 　异步I/O实现现状　　50\n3.2.1 　异步I/O与非阻塞I/O　　50\n3.2.2 　理想的非阻塞异步I/O　　54\n3.2.3 　现实的异步I/O　　54\n3.3 　Node的异步I/O　　56\n3.3.1 　事件循环　　56\n3.3.2 　观察者　　56\n3.3.3 　请求对象　　57\n3.3.4 　执行回调　　59\n3.3.5 　小结　　60\n3.4 　非I/O的异步API　　60\n3.4.1 　定时器　　60\n3.4.2 　process.nextTick()　　61\n3.4.3 　setImmediate()　　62\n3.5 　事件驱动与高性能服务器　　63\n3.6 　总结　　65\n3.7 　参考资源　　65\n第4章　异步编程　　66\n4.1 　函数式编程　　66\n4.1.1 　高阶函数　　66\n4.1.2 　偏函数用法　　67\n4.2 　异步编程的优势与难点　　68\n4.2.1 　优势　　69\n4.2.2 　难点　　70\n4.3 　异步编程解决方案　　74\n4.3.1 　事件发布/订阅模式　　74\n4.3.2 　Promise/Deferred模式　　82\n4.3.3 　流程控制库　　93\n4.4 　异步并发控制　　105\n4.4.1 　bagpipe的解决方案　　105\n4.4.2 　async的解决方案　　109\n4.5 　总结　　110\n4.6 　参考资源　　110\n第5章　内存控制　　111\n5.1 　V8的垃圾回收机制与内存限制　　111\n5.1.1 　Node与V8　　112\n5.1.2 　V8的内存限制　　112\n5.1.3 　V8的对象分配　　112\n5.1.4 　V8的垃圾回收机制　　113\n5.1.5 　查看垃圾回收日志　　119\n5.2 　高效使用内存　　121\n5.2.1 　作用域　　121\n5.2.2 　闭包　　123\n5.2.3 　小结　　124\n5.3 　内存指标　　124\n5.3.1 　查看内存使用情况　　124\n5.3.2 　堆外内存　　126\n5.3.3 　小结　　127\n5.4 　内存泄漏　　127\n5.4.1 　慎将内存当做缓存　　127\n5.4.2 　关注队列状态　　130\n5.5 　内存泄漏排查　　130\n5.5.1 　node-heapdump　　131\n5.5.2 　node-memwatch　　132\n5.5.3 　小结　　135\n5.6 　大内存应用　　135\n5.7 　总结　　136\n5.8 　参考资源　　136\n第6章 　理解Buffer　　137\n6.1 　Buffer结构　　137\n6.1.1 　模块结构　　137\n6.1.2 　Buffer对象　　138\n6.1.3 　Buffer内存分配　　139\n6.2 　Buffer的转换　　141\n6.2.1 　字符串转Buffer　　141\n6.2.2 　Buffer转字符串　　142\n6.2.3 　Buffer不支持的编码类型　　142\n6.3 　Buffer的拼接　　143\n6.3.1 　乱码是如何产生的　　144\n6.3.2 　setEncoding()与string_decoder()　　144\n6.3.3 　正确拼接Buffer　　145\n6.4 　Buffer与性能　　146\n6.5 　总结　　149\n6.6 　参考资源　　149\n第7章　网络编程　　150\n7.1 　构建TCP服务　　150\n7.1.1 　TCP　　150\n7.1.2 　创建TCP服务器端　　151\n7.1.3 　TCP服务的事件　　153\n7.2 　构建UDP服务　　154\n7.2.1 　创建UDP套接字　　154\n7.2.2 　创建UDP服务器端　　154\n7.2.3 　创建UDP客户端　　155\n7.2.4 　UDP套接字事件　　155\n7.3 　构建HTTP服务　　155\n7.3.1 　HTTP　　156\n7.3.2 　http模块　　157\n7.3.3 　HTTP客户端　　161\n7.4 　构建WebSocket服务　　163\n7.4.1 　WebSocket握手　　164\n7.4.2 　WebSocket数据传输　　167\n7.4.3 　小结　　169\n7.5 　网络服务与安全　　169\n7.5.1 　TLS/SSL　　170\n7.5.2 　TLS服务　　172\n7.5.3 　HTTPS服务　　173\n7.6 　总结　　175\n7.7 　参考资源　　176\n第8章　构建Web应用　　177\n8.1 　基础功能　　177\n8.1.1 　请求方法　　178\n8.1.2 　路径解析　　179\n8.1.3 　查询字符串　　180\n8.1.4 　Cookie　　181\n8.1.5 　Session　　184\n8.1.6 　缓存　　190\n8.1.7 　Basic认证　　193\n8.2 　数据上传　　195\n8.2.1 　表单数据　　195\n8.2.2 　其他格式　　196\n8.2.3 　附件上传　　197\n8.2.4 　数据上传与安全　　199\n8.3 　路由解析　　201\n8.3.1 　文件路径型　　202\n8.3.2 　MVC　　202\n8.3.3 　RESTful　　207\n8.4 　中间件　　210\n8.4.1 　异常处理　　214\n8.4.2 　中间件与性能　　215\n8.4.3 　小结　　216\n8.5 　页面渲染　　217\n8.5.1 　内容响应　　217\n8.5.2 　视图渲染　　219\n8.5.3 　模板　　220\n8.5.4 　Bigpipe　　231\n8.6 　总结　　235\n8.7 　参考资源　　235\n第9章　玩转进程　　236\n9.1 　服务模型的变迁　　236\n9.1.1 　石器时代：同步　　236\n9.1.2 　青铜时代：复制进程　　237\n9.1.3 　白银时代：多线程　　237\n9.1.4 　黄金时代：事件驱动　　237\n9.2 　多进程架构　　238\n9.2.1 　创建子进程　　239\n9.2.2 　进程间通信　　240\n9.2.3 　句柄传递　　242\n9.2.4 　小结　　247\n9.3 　集群稳定之路　　248\n9.3.1 　进程事件　　248\n9.3.2 　自动重启　　249\n9.3.3 　负载均衡　　254\n9.3.4 　状态共享　　255\n9.4 　Cluster模块　　257\n9.4.1 　Cluster工作原理　　258\n9.4.2 　Cluster事件　　259\n9.5 　总结　　259\n9.6 　参考资源　　260\n第10章　测试　　261\n10.1 　单元测试　　261\n10.1.1 　单元测试的意义　　261\n10.1.2 　单元测试介绍　　263\n10.1.3 　工程化与自动化　　276\n10.1.4 　小结　　277\n10.2 　性能测试　　278\n10.2.1 　基准测试　　278\n10.2.2 　压力测试　　280\n10.2.3 　基准测试驱动开发　　281\n10.2.4 　测试数据与业务数据的转换　　283\n10.3 　总结　　284\n10.4 　参考资源　　284\n第11章　产品化　　285\n11.1 　项目工程化　　285\n11.1.1 　目录结构　　285\n11.1.2 　构建工具　　286\n11.1.3 　编码规范　　289\n11.1.4 　代码审查　　289\n11.2 　部署流程　　290\n11.2.1 　部署环境　　291\n11.2.2 　部署操作　　291\n11.3 　性能　　293\n11.3.1 　动静分离　　293\n11.3.2 　启用缓存　　294\n11.3.3 　多进程架构　　294\n11.3.4 　读写分离　　295\n11.4 　日志　　295\n11.4.1 　访问日志　　295\n11.4.2 　异常日志　　296\n11.4.3 　日志与数据库　　299\n11.4.4 　分割日志　　299\n11.4.5 　小结　　299\n11.5 　监控报警　　299\n11.5.1 　监控　　300\n11.5.2 　报警的实现　　302\n11.5.3 　监控系统的稳定性　　303\n11.6 　稳定性　　303\n11.7 　异构共存　　304\n11.8 　总结　　305\n11.9 　参考资源　　305\n附录A 　安装Node　　306\nA.1 　Windows系统下的Node安装　　306\nA.2 　Mac系统下Node的安装　　307\nA.3 　Linux系统下Node的安装　　308\nA.4 　总结　　309\nA.5 　参考资源　　309\n附录B 　调试Node　　310\nB.1 　Debugger　　310\nB.2 　Node Inspector　　311\nB.2.1 　安装Node Inspector　　312\nB.2.2 　错误堆栈　　312\nB.3 　总结　　313\n附录C 　Node编码规范　　314\nC.1 　根源　　314\nC.2 　编码规范　　315\nC.2.1 　空格与格式　　315\nC.2.2 　命名规范　　317\nC.2.3 　比较操作　　318\nC.2.4 　字面量　　318\nC.2.5 　作用域　　318\nC.2.6 　数组与对象　　319\nC.2.7 　异步　　320\nC.2.8 　类与模块　　320\nC.2.9 　注解规范　　321\nC.3 　最佳实践　　321\nC.3.1 　冲突的解决原则　　321\nC.3.2 　给编辑器设置检测工具　　321\nC.3.3 　版本控制中的hook　　322\nC.3.4 　持续集成　　322\nC.4 　总结　　322\nC.5 　参考资源　　323\n附录D 　搭建局域NPM仓库　　324\nD.1 　NPM仓库的安装　　325\nD.1.1 　安装Erlang和CouchDB　　325\nD.1.2 　搭建NPM仓库　　326\nD.2 　高阶应用　　328\nD.2.1 　镜像仓库　　328\nD.2.2 　私有模块应用　　328\nD.2.3 　纯私有仓库　　329\nD.3 　总结　　331\nD.4 　参考资源　　332",
        "ebook_url": "https://read.douban.com/ebook/12053349/",
        "pages": "332",
        "images": {
          "small": "https://img3.doubanio.com/spic/s27269296.jpg",
          "large": "https://img3.doubanio.com/lpic/s27269296.jpg",
          "medium": "https://img3.doubanio.com/mpic/s27269296.jpg"
        },
        "alt": "https://book.douban.com/subject/25768396/",
        "id": "25768396",
        "publisher": "人民邮电出版社",
        "isbn10": "7115335508",
        "isbn13": "9787115335500",
        "title": "深入浅出Node.js",
        "url": "https://api.douban.com/v2/book/25768396",
        "alt_title": "",
        "author_intro": "朴灵\n真名田永强，文艺型码农，就职于阿里巴巴数据平台，资深工程师，Node.js布道者，写了多篇文章介绍Node.js的细节。活跃于CNode社区，是线下会议NodeParty的组织者和JSConf China（沪JS和京JS）的组织者之一。热爱开源，多个Node.js模块的作者。个人GitHub地址：http://github.com/JacksonTian。叩首问路，码梦为生。",
        "summary": "本书从不同的视角介绍了 Node 内在的特点和结构。由首章Node 介绍为索引，涉及Node 的各个方面，主要内容包含模块机制的揭示、异步I/O 实现原理的展现、异步编程的探讨、内存控制的介绍、二进制数据Buffer 的细节、Node 中的网络编程基础、Node 中的Web 开发、进程间的消息传递、Node 测试以及通过Node 构建产品需要的注意事项。最后的附录介绍了Node 的安装、调试、编码规范和NPM 仓库等事宜。\n本书适合想深入了解 Node 的人员阅读。",
        "ebook_price": "39.99",
        "series": {
          "id": "13000",
          "title": "图灵原创"
        },
        "price": "CNY 69.00",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "8678456eed99947fa3c7f0480e843d8638e86ae4a7c6db9b7226bb94a498158b",
        "file": "深入浅出Node.js.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 433,
          "average": "8.5",
          "min": 0
        },
        "subtitle": "第2版",
        "author": [
          "单东林",
          "张晓菲",
          "魏然"
        ],
        "pubdate": "2012-7-1",
        "tags": [
          {
            "count": 425,
            "name": "jQuery",
            "title": "jQuery"
          },
          {
            "count": 281,
            "name": "前端开发",
            "title": "前端开发"
          },
          {
            "count": 166,
            "name": "JavaScript",
            "title": "JavaScript"
          },
          {
            "count": 100,
            "name": "web开发",
            "title": "web开发"
          },
          {
            "count": 99,
            "name": "前端",
            "title": "前端"
          },
          {
            "count": 90,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 73,
            "name": "锋利的jQuery",
            "title": "锋利的jQuery"
          },
          {
            "count": 70,
            "name": "计算机",
            "title": "计算机"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/mpic/s28026858.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "第1章 认识jQuery 1\n1.1 JavaScript和JavaScript库 1\n1.1.1 JavaScript简介 1\n1.1.2 JavaScript库作用及对比 1\n1.2 加入jQuery 3\n1.2.1 jQuery简介 3\n1.2.2 jQuery的优势 4\n1.3 jQuery代码的编写 5\n1.3.1 配置jQuery环境 5\n1.3.2 编写简单的jQuery代码 7\n1.3.3 jQuery代码风格 8\n1.4 jQuery对象和DOM对象 11\n1.4.1 DOM对象和jQuery对象简介 11\n1.4.2 jQurey对象和DOM对象的相互转换 13\n1.4.3 实例研究 14\n1.5 解决jQuery和其他库的冲突 16\n1.6 jQuery开发工具和插件 18\n1.7 小结 22\n第2章 jQuery选择器 23\n2.1 jQuery选择器是什么 23\n2.2 jQuery选择器的优势 26\n2.3 jQuery选择器 27\n2.3.1 基本选择器 32\n2.3.2 层次选择器 33\n2.3.3 过滤选择器 35\n2.3.4 表单选择器 48\n2.4 应用jQuery改写示例 50\n2.5 选择器中的一些注意事项 50\n2.5.1 选择器中含有特殊符号的注意事项 50\n2.5.2 选择器中含有空格的注意事项 51\n2.6 案例研究——某网站品牌列表的效果 52\n2.7 其他选择器 58\n2.7.1 jQuery提供的选择器的扩展 58\n2.7.2 其他使用CSS选择器的方法 59\n2.8 小结 60\n第3章 jQuery中的DOM操作 61\n3.1 DOM操作的分类 61\n3.2 jQuery中的DOM操作 62\n3.2.1 查找节点 63\n3.2.2 创建节点 64\n3.2.3 插入节点 66\n3.2.4 删除节点 69\n3.2.5 复制节点 71\n3.2.6 替换节点 72\n3.2.7 包裹节点 72\n3.2.8 属性操作 75\n3.2.9 样式操作 76\n3.2.10 设置和获取HTML、文本和值 80\n3.2.11 遍历节点 85\n3.2.12 CSS-DOM操作 88\n3.3 案例研究——某网站的超链接和图片提示效果 91\n3.4 小结 97\n第4章 jQuery中的事件和动画 98\n4.1 jQuery中的事件 98\n4.1.1 加载DOM 98\n4.1.2 事件绑定 101\n4.1.3 合成事件 105\n4.1.4 事件冒泡 108\n4.1.5 事件对象的属性 112\n4.1.6 移除事件 114\n4.1.7 模拟操作 117\n4.1.8 其他用法 118\n4.2 jQuery中的动画 120\n4.2.1 show()方法和hide()方法 120\n4.2.2 fadeIn()方法和fadeOut()方法 122\n4.2.3 slideUp()方法和slideDown()方法 123\n4.2.4 自定义动画方法animate() 123\n4.2.5 动画回调函数 127\n4.2.6 停止动画和判断是否处于动画状态 127\n4.2.7 其他动画方法 130\n4.2.8 动画方法概括 131\n4.3 视频展示效果实例 133\n4.4 小结 139\n第5章 jQuery对表单、表格的操作及更多应用 140\n5.1 表单应用 140\n5.1.1 单行文本框应用 140\n5.1.2 多行文本框应用 142\n5.1.3 复选框应用 145\n5.1.4 下拉框应用 149\n5.1.5 表单验证 152\n5.2 表格应用 155\n5.2.1 表格变色 156\n5.2.2 表格展开关闭 160\n5.2.3 表格内容筛选 161\n5.3 其他应用 163\n5.3.1 网页字体大小 163\n5.3.2 网页选项卡 165\n5.3.3 网页换肤 167\n5.4 小结 171\n第6章 jQuery与Ajax的应用 172\n6.1 Ajax的优势和不足 172\n6.1.1 Ajax的优势 172\n6.1.2 Ajax的不足 173\n6.2 Ajax的XMLHttpRequest对象 173\n6.3 安装Web环境——AppServ 174\n6.4 编写第1个Ajax例子 175\n6.5 jQuery中的Ajax 177\n6.5.1 load()方法 177\n6.5.2 $.get()方法和$.post()方法 179\n6.5.3 $.getScript()方法和$.getJson()方法 185\n6.5.4 $.ajax()方法 188\n6.6 序列化元素 191\n6.7 jQuery中的Ajax全局事件 193\n6.8 基于jQuery的Ajax聊天室程序 195\n6.8.1 基本设想 195\n6.8.2 设计数据库 195\n6.8.3 服务器端处理 196\n6.8.4 客户端处理 197\n6.8.5 客户端代码 197\n6.8.6 整合代码 201\n6.9 小结 202\n第7章 jQuery插件的使用和写法 203\n7.1 jQuery表单验证插件——Validation 203\n7.1.1 Validation简介 203\n7.1.2 下载地址 204\n7.1.3 快速上手 204\n7.1.4 不同的验证写法 207\n7.1.5 验证信息 209\n7.1.6 自定义验证规则 212\n7.1.7 API 213\n7.2 jQuery表单插件——Form 213\n7.2.1 Form插件简介 213\n7.2.2 下载地址 214\n7.2.3 快速上手 214\n7.2.4 核心方法——ajaxForm()和ajaxSubmit() 215\n7.2.5 ajaxForm()方法和ajaxSubmit()方法的参数 215\n7.2.6 表单提交之前验证表单 218\n7.2.7 API 220\n7.3 模态窗口插件——SimpleModal 220\n7.3.1 SimpleModal插件简介 220\n7.3.2 下载地址 221\n7.3.3 快速上手 221\n7.3.4 关闭模态窗口 222\n7.3.5 实际应用 223\n7.3.6 API 225\n7.4 管理Cookie的插件——Cookie 225\n7.4.1 Cookie插件简介 225\n7.4.2 下载地址 225\n7.4.3 快速上手 226\n7.4.4 API 227\n7.5 jQuery UI插件 228\n7.5.1 jQuery UI简介 228\n7.5.2 下载地址 228\n7.5.3 快速上手 230\n7.5.4 与单击事件冲突 231\n7.5.5 与后台结合 232\n7.6 编写jQuery插件 234\n7.6.1 插件的种类 234\n7.6.2 插件的基本要点 234\n7.6.3 插件中的闭包 235\n7.6.4 jQuery插件的机制 236\n7.6.5 编写jQuery插件 237\n7.7 小结 248\n第8章 用jQuery打造个性网站 249\n8.1 案例背景介绍 249\n8.2 网站材料 249\n8.3 网站结构 249\n8.3.1 文件结构 249\n8.3.2 网页结构 250\n8.3.3 界面设计 250\n8.4 网站的(X)HTML 252\n8.5 网站样式(CSS) 252\n8.5.1 将CSS文件分门别类 252\n8.5.2 编写CSS 252\n8.6 网站脚本(jQuery) 273\n8.6.1 准备工作 273\n8.6.2 首页(index.html)上的功能 274\n8.6.3 详细页(detail.html)上的功能 282\n8.7 小结 290\n第9章 jQuery Mobile 291\n9.1 HTML 5简介 291\n9.2 jQuery Mobile简介 292\n9.3 jQuery Mobile主要特性 292\n9.4 jQuery Mobile的使用 293\n9.4.1 准备工作 293\n9.4.2 构建HTML模板 294\n9.4.3 data-role属性 295\n9.4.4 添加内容 296\n9.4.5 样式切换 297\n9.5 其他框架 298\n9.5.1 移动框架 298\n9.5.2 PhoneGap 299\n9.6 小结 299\n第10章 jQuery各个版本的变化 300\n10.1 jQuery的发展历史 300\n10.2 jQuery各个版本新增方法 307\n10.3 小结 311\n第11章 jQuery性能优化和技巧 312\n11.1 jQuery性能优化 312\n11.2 jQuery技巧 318\n11.3 小结 328\n附录A 关于$(document).ready()函数 329\nA.1 $(document).ready()函数介绍 329\nA.2 多个$(document).ready()函数 330\n附录B Firebug 331\nB.1 概述 331\nB.2 主面板简介 332\nB.2.1 控制台面板 333\nB.2.2 HTML面板 337\nB.2.3 CSS、DOM和网络面板 341\nB.2.4 脚本面板 341\nB.3 一些资源 344\nB.4 总结 345\n附录C Ajax的XMLHttpRequest对象的属性和方法 346\n附录D jQuery $.ajax()方法的参数详解 349\n附录E jQuery加载并解析XML 353\nE.1 简述 353\nE.2 Content-Type 353\nE.3 XML结构 353\nE.4 获取XML 354\nE.5 解析XML 355\nE.6 禁用缓存 355\n附录F 插件API 357\nF.1 Validation插件API 357\nF.2 Form插件API 359\nF.3 SimpleModal插件API 365\nF.4 Cookie插件API 366\n附录G jQuery速查表 368\nG.1 基础 368\nG.2 选择器 369\nG.3 属性 371\nG.4 筛选 371\nG.5 文档处理 372\nG.6 CSS 373\nG.7 事件 374\nG.8 效果 376\nG.9 Ajax 377\nG.10 实用项 378\nG.11 其他对象 379",
        "pages": "380",
        "images": {
          "small": "https://img1.doubanio.com/spic/s28026858.jpg",
          "large": "https://img1.doubanio.com/lpic/s28026858.jpg",
          "medium": "https://img1.doubanio.com/mpic/s28026858.jpg"
        },
        "alt": "https://book.douban.com/subject/10792216/",
        "id": "10792216",
        "publisher": "人民邮电出版社",
        "isbn10": "7115281602",
        "isbn13": "9787115281609",
        "title": "锋利的jQuery",
        "url": "https://api.douban.com/v2/book/10792216",
        "alt_title": "",
        "author_intro": "单东林，曾经拥有一个著名的网站cssrain.cn，后来因不可抗拒力而关闭。通过本书继续为国内前端开发做贡献。",
        "summary": "《锋利的jQuery(第2版)》循序渐进地对jQuery的各种函数和方法调用进行了介绍，读者可以系统地掌握jQuery的选择器、DOM操作、事件和动画、AJAX应用、插件、jQuery Mobile、jQuery各个版本变化、jQuery性能优化和技巧等知识点，并结合每个章节后面的案例演示进行练习，达到掌握核心知识点的目的。\n为使读者更好地进行开发实践，《锋利的jQuery(第2版)》的第8章将前7章讲解的知识点和效果进行了整合，打造出一个非常有个性的网站，并从案例研究、网站材料、网站结构、网站样式和网站脚本等方面指导读者参与到项目建设中来。",
        "price": "49.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "8bc4e4e80bc58554477d8e1d091a70be6a5e503c99c9f11f71f1e933bcfa2390",
        "file": "锋利的jQuery.epub"
      }
    ]
  },
  {
    "dir_name": "protocol",
    "name": "协议",
    "books": [
      {
        "title": "Antlr 4权威指南",
        "subtitle": "",
        "author": [
          "Terence Parr"
        ],
        "summary": "ANTLR是一款强大的语法分析器生成工具，可用于读取、处理、执行和翻译结构化的文本或二进制文件。它被广泛应用于学术领域和工业生产实践，是众多语言、工具和框架的基石。Twitter搜索使用ANTLR进行语法分析，每天处理超过20亿次查询；Hadoop生态系统中的Hive、Pig、数据仓库和分析系统所使用的语言都用到了ANTLR；Lex Machina将ANTLR用于分析法律文本；Oracle公司在SQL开发者IDE和迁移工具中使用了ANTLR；NetBeans公司的IDE使用ANTLR来解析C++；Hibernate对象-关系映射框架（ORM）使用ANTLR来处理HQL语言。\n除了这些鼎鼎大名的项目之外，还可以利用ANTLR构建各种各样的实用工具，如配置文件读取器、遗留代码转换器、维基文本渲染器，以及JSON解析器。我编写了一些工具，用于创建数据库的对象-关系映射、描述三维可视化以及在Java源代码中插入性能监控代码。我甚至为一次演讲编写了一个简单的DNA模式匹配程序。\n一门语言的正式描述称为语法（grammar），ANTLR能够为该语言生成一个语法分析器，并自动建立语法分析树——一种描述语法与输入文本匹配关系的数据结构。ANTLR也能够自动生成树的遍历器，这样你就可以访问树中的节点，执行自定义的业务逻辑代码。\n本书既是ANTLR 4的参考手册，也是解决语言识别问题的指南。你会学到如下知识：\n识别语言样例和参考手册中的语法模式，从而编写自定义的语法。\n循序渐进地为从简单的JSON到复杂的R语言编写语法。同时还能学会解决XML和Python中棘手的识别问题。\n基于语法，通过遍历自动生成的语法分析树，实现自己的语言类应用程序。\n在特定的应用领域中，自定义识别过程的错误处理机制和错误报告机制。\n通过在语法中嵌入Java动作（action），对语法分析过程进行完全的掌控。\n本书并非教科书，所有的讨论都是基于实例的，旨在令你巩固所学的知识，并提供语言类应用程序的基本范例。",
        "publisher": "机械工业出版社",
        "isbn13": "9787111566489",
        "isbn10": "7111566483",
        "tags": [
          {
            "title": "ANTLR",
            "name": "ANTLR",
            "count": 32
          },
          {
            "title": "编译原理",
            "name": "编译原理",
            "count": 26
          },
          {
            "title": "编译器",
            "name": "编译器",
            "count": 14
          },
          {
            "title": "编程语言",
            "name": "编程语言",
            "count": 11
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 10
          },
          {
            "title": "编程",
            "name": "编程",
            "count": 10
          },
          {
            "title": "词法分析",
            "name": "词法分析",
            "count": 7
          },
          {
            "title": "技术",
            "name": "技术",
            "count": 5
          }
        ],
        "pubdate": "2017-5-1",
        "translator": [
          "张博"
        ],
        "binding": null,
        "author_intro": null,
        "rating": {
          "average": 9.8,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 27.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "5857712796f5712c2297ce1bbdca5d37c5f063642c97371c905461e66ed20350",
        "file": "Antlr4权威指南.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 1151,
          "average": "8.6",
          "min": 0
        },
        "subtitle": "权威指南",
        "author": [
          "David Gourley",
          "Brian Totty"
        ],
        "pubdate": "2012-9",
        "tags": [
          {
            "count": 1928,
            "name": "HTTP",
            "title": "HTTP"
          },
          {
            "count": 897,
            "name": "网络",
            "title": "网络"
          },
          {
            "count": 657,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 568,
            "name": "互联网",
            "title": "互联网"
          },
          {
            "count": 527,
            "name": "协议",
            "title": "协议"
          },
          {
            "count": 463,
            "name": "web开发",
            "title": "web开发"
          },
          {
            "count": 266,
            "name": "基础理论",
            "title": "基础理论"
          },
          {
            "count": 205,
            "name": "编程",
            "title": "编程"
          }
        ],
        "origin_title": "HTTP: The Definitive Guide",
        "image": "https://img1.doubanio.com/mpic/s11329547.jpg",
        "binding": "Paperback",
        "translator": [
          "陈涓",
          "赵振平"
        ],
        "catalog": "目录\n第一部分 　HTTP：Web 的基础\n第1章 　HTTP 概述　　3\n1.1 　HTTP——因特网的多媒体信使 　 　4\n1.2 　Web 客户端和服务器  4\n1.3 　资源　　 5\n1.3.1 　媒体类型 　 　6\n1.3.2 　URI 　 　7\n1.3.3 　URL　　7\n1.3.4 　URN　　8\n1.4 　事务　　 9\n1.4.1 　方法　　9\n1.4.2 　状态码 　 　10\n1.4.3 　Web 页面中可以包含多个对象  10\n1.5 　报文　　11\n1.6 　连接　　13\n1.6.1 　TCP/IP 　 　13\n1.6.2 　连接、IP 地址及端口号 　 　14\n1.6.3 　使用Telnet 实例 　 　16\n1.7 　协议版本　　18\n1.8 　Web 的结构组件 　 　19\n1.8.1 　代理 　 　19\n1.8.2 　缓存 　 　20\n1.8.3 　网关 　 　20\n1.8.4 　隧道 　 　21\n1.8.5 　Agent 代理 　 　21\n1.9 　起始部分的结束语 　 　22\n1.10 　更多信息　　22\n1.10.1 　HTTP 协议信息  22\n1.10.2 　历史透视 　 　23\n1.10.3 　其他万维网信息 　 　23\n第2章 URL 与资源 　 　25\n2.1 　浏览因特网资源 　 　26\n2.2 　URL 的语法 　 　28\n2.2.1 　方案——使用什么协议 　 　29\n2.2.2 　主机与端口 　 　30\n2.2.3 　用户名和密码 　 　30\n2.2.4 　路径 　 　31\n2.2.5 　参数 　 　31\n2.2.6 　查询字符串 　 　32\n2.2.7 　片段 　 　33\n2.3 　URL 快捷方式 　 　34\n2.3.1 　相对URL  34\n2.3.2 　自动扩展URL  37\n2.4 　各种令人头疼的字符 　 　38\n2.4.1 　URL 字符集  38\n2.4.2 　编码机制  38\n2.4.3 　字符限制  39\n2.4.4 　另外一点说明 　 　40\n2.5 　方案的世界　　40\n2.6 　未来展望　　42\n2.7 　更多信息　　44\n第3章 　HTTP 报文 　 　45\n3.1 　报文流 　 　46\n3.1.1 　报文流入源端服务器 　 　46\n3.1.2 　报文向下游流动 　 　47\n3.2 　报文的组成部分 　 　47\n3.2.1 　报文的语法 　 　48\n3.2.2 　起始行 　 　50\n3.2.3 　首部 　 　53\n3.2.4 　实体的主体部分 　 　55\n3.2.5 　版本0.9 的报文 　 　55\n3.3 　方法　　56\n3.3.1 　安全方法  56\n3.3.2 　GET　　56\n3.3.3 　HEAD 　 　57\n3.3.4 　PUT　　57\n3.3.5 　POST 　 　58\n3.3.6 　TRACE 　 　58\n3.3.7 　OPTIONS 60\n3.3.8 　DELETE 　 　60\n3.3.9 　扩展方法  61\n3.4 　状态码 　 　62\n3.4.1 　100 ～ 199——信息性状态码 　 　62\n3.4.2 　200 ～ 299——成功状态码 　 　63\n3.4.3 　300 ～ 399——重定向状态码 　 　64\n3.4.4 　400 ～ 499——客户端错误状态码 　 　68\n3.4.5 　500 ～ 599——服务器错误状态码 　 　69\n3.5 　首部　　70\n3.5.1 　通用首部  71\n3.5.2 　请求首部  72\n3.5.3 　响应首部  74\n3.5.4 　实体首部  75\n3.6 　更多信息　　77\n第4章 　连接管理 　 　79\n4.1 　TCP 连接 　 　80\n4.1.1 　TCP 的可靠数据管道 　 　80\n4.1.2 　TCP 流是分段的、由IP 分组传送  81\n4.1.3 　保持TCP 连接的正确运行 　 　82\n4.1.4 　用TCP 套接字编程  84\n4.2 　对TCP 性能的考虑  85\n4.2.1 　HTTP 事务的时延 　 　86\n4.2.2 　性能聚焦区域 　 　87\n4.2.3 　TCP 连接的握手时延 　 　87\n4.2.4 　延迟确认  88\n4.2.5 　TCP 慢启动 　 　89\n4.2.6 　Nagle 算法与TCP_NODELAY 　 　89\n4.2.7 　TIME_WAIT 累积与端口耗尽 　 　90\n4.3 　HTTP 连接的处理 　 　91\n4.3.1 　常被误解的Connection 首部  91\n4.3.2 　串行事务处理时延 　 　92\n4.4 　并行连接　　94\n4.4.1 　并行连接可能会提高页面的加载速度 　 　94\n4.4.2 　并行连接不一定更快 　 　95\n4.4.3 　并行连接可能让人“感觉”更快一些 　 　95\n4.5 　持久连接　　96\n4.5.1 　持久以及并行连接 　 　96\n4.5.2 　HTTP/1.0+ keep-alive 连接 　 　97\n4.5.3 　Keep-Alive 操作 　 　98\n4.5.4 　Keep-Alive 选项 　 　98\n4.5.5 　Keep-Alive 连接的限制和规则 　 　99\n4.5.6 　Keep-Alive 和哑代理  100\n4.5.7 　插入Proxy-Connection  102\n4.5.8 　HTTP/1.1 持久连接 　 　104\n4.5.9 　持久连接的限制和规则  104\n4.6 　管道化连接 　 　105\n4.7 　关闭连接的奥秘  106\n4.7.1 “ 任意”解除连接  106\n4.7.2 　Content-Length 及截尾操作 　 　107\n4.7.3 　连接关闭容限、重试以及幂等性  107\n4.7.4 　正常关闭连接  108\n4.8 　更多信息　　110\n4.8.1 　HTTP 连接  110\n4.8.2 　HTTP 性能问题  110\n4.8.3 　TCP/IP　　111\n第二部分 　HTTP 结构\n第5章 　Web 服务器  115\n5.1 　各种形状和尺寸的Web 服务器  116\n5.1.1 　Web 服务器的实现  116\n5.1.2 　通用软件Web 服务器 　 　117\n5.1.3 　Web 服务器设备  117\n5.1.4 　嵌入式Web 服务器 　 　118\n5.2 　最小的Perl Web 服务器  118\n5.3 　实际的Web 服务器会做些什么  120\n5.4 　第一步——接受客户端连接  121\n5.4.1 　处理新连接  121\n5.4.2 　客户端主机名识别  122\n5.4.3 　通过ident 确定客户端用户  122\n5.5 　第二步——接收请求报文  123\n5.5.1 　报文的内部表示法  124\n5.5.2 　连接的输入/ 输出处理结构 　 　125\n5.6 　第三步——处理请求  126\n5.7 　第四步——对资源的映射及访问 　 　126\n5.7.1 　docroot 　 　127\n5.7.2 　目录列表 　 　129\n5.7.3 　动态内容资源的映射  130\n5.7.4 　服务器端包含项  131\n5.7.5 　访问控制 　 　131\n5.8 　第五步——构建响应  131\n5.8.1 　响应实体 　 　131\n5.8.2 　MIME 类型 132\n5.8.3 　重定向 　 　133\n5.9 　第六步——发送响应  134\n5.10 　第七步——记录日志 　 　134\n5.11 　更多信息　　134\n第6章 　代理 　 　135\n6.1 　Web 的中间实体  136\n6.1.1 　私有和共享代理  136\n6.1.2 　代理与网关的对比  137\n6.2 　为什么使用代理  138\n6.3 　代理会去往何处  143\n6.3.1 　代理服务器的部署  144\n6.3.2 　代理的层次结构  144\n6.3.3 　代理是如何获取流量的  147\n6.4 　客户端的代理设置  148\n6.4.1 　客户端的代理配置：手工配置 　 　149\n6.4.2 　客户端代理配置：PAC 文件 　 　149\n6.4.3 　客户端代理配置：WPAD 　 　150\n6.5 　与代理请求有关的一些棘手问题 　 　151\n6.5.1 　代理URI 与服务器URI 的不同 　 　151\n6.5.2 　与虚拟主机一样的问题  152\n6.5.3 　拦截代理会收到部分URI  153\n6.5.4 　代理既可以处理代理请求，也可以处理服务器请求 　 　154\n6.5.5 　转发过程中对URI 的修改  154\n6.5.6 　URI 的客户端自动扩展和主机名解析  155\n6.5.7 　没有代理时URI 的解析 155\n6.5.8 　有显式代理时URI 的解析  156\n6.5.9 　有拦截代理时URI 的解析  157\n6.6 　追踪报文　　158\n6.6.1 　Via 首部 158\n6.6.2 　TRACE 方法 　 　162\n6.7 　代理认证　　164\n6 ｜ 目录\n6.8 　代理的互操作性  165\n6.8.1 　处理代理不支持的首部和方法 　 　166\n6.8.2 　OPTIONS：发现对可选特性的支持  166\n6.8.3 　Allow 首部  167\n6.9 　更多信息　　167\n第7章 　缓存 　 　169\n7.1 　冗余的数据传输  170\n7.2 　带宽瓶颈　　170\n7.3 　瞬间拥塞　　171\n7.4 　距离时延　　172\n7.5 　命中和未命中的  173\n7.5.1 　再验证 　 　173\n7.5.2 　命中率 　 　175\n7.5.3 　字节命中率  176\n7.5.4 　区分命中和未命中的情况 　 　176\n7.6 　缓存的拓扑结构  177\n7.6.1 　私有缓存 　 　177\n7.6.2 　公有代理缓存  177\n7.6.3 　代理缓存的层次结构  179\n7.6.4 　网状缓存、内容路由以及对等缓存 　 　180\n7.7 　缓存的处理步骤  181\n7.7.1 　第一步——接收  181\n7.7.2 　第二步——解析  182\n7.7.3 　第三步——查找  182\n7.7.4 　第四步——新鲜度检测  182\n7.7.5 　第五步——创建响应  182\n7.7.6 　第六步——发送  183\n7.7.7 　第七步——日志  183\n7.7.8 　缓存处理流程图  183\n7.8 　保持副本的新鲜  183\n7.8.1 　文档过期 　 　184\n7.8.2 　过期日期和使用期  185\n7.8.3 　服务器再验证  185\n7.8.4 　用条件方法进行再验证  186\n7.8.5 　If-Modified-Since:Date 再验证 　 　187\n7.8.6 　If-None-Match：实体标签再验证 　 　189\n7.8.7 　强弱验证器  190\n7.8.8 　什么时候应该使用实体标签和最近修改日期 　 　190\n7.9 　控制缓存的能力  191\n7.9.1 　no-Store 与no-Cache 响应首部　　191\n7.9.2 　max-age 响应首部 　 　192\n7.9.3 　Expires 响应首部 　 　192\n7.9.4 　must-revalidate 响应首部  192\n7.9.5 　试探性过期  193\n7.9.6 　客户端的新鲜度限制  194\n7.9.7 　注意事项 　 　194\n7.10 　设置缓存控制 　 　195\n7.10.1 　控制Apache 的HTTP 首部 　 　195\n7.10.2 　通过HTTP-EQUIV 控制HTML 缓存 　 　196\n7.11 　详细算法　　197\n7.11.1 　使用期和新鲜生存期 　 　198\n7.11.2 　使用期的计算 　 　198\n7.11.3 　完整的使用期计算算法 　 　201\n7.11.4 　新鲜生存期计算 　 　202\n7.11.5 　完整的服务器——新鲜度算法 　 　202\n7.12 　缓存和广告 　 　204\n7.12.1 　发布广告者的两难处境 　 　204\n7.12.2 　发布者的响应 　 　204\n7.12.3 　日志迁移 　 　205\n7.12.4 　命中计数和使用限制 　 　205\n7.13 　更多信息　　205\n第8章 　集成点：网关、隧道及中继 　 　207\n8.1 　网关　　208\n8.2 　协议网关　　210\n8.2.1 　HTTP/*：服务器端Web 网关  211\n8.2.2 　HTTP/HTTPS：服务器端安全网关　　212\n8.2.3 　HTTPS/HTTP 客户端安全加速器网关 　 　212\n8.3 　资源网关　　213\n8.3.1 　CGI  215\n8.3.2 　服务器扩展API  215\n8.4 　应用程序接口和Web 服务  216\n8.5 　隧道　　217\n8.5.1 　用CONNECT 建立HTTP 隧道  217\n8.5.2 　数据隧道、定时及连接管理 　 　219\n8.5.3 　SSL 隧道 219\n8.5.4 　SSL 隧道与HTTP/HTTPS 网关的对比  220\n8.5.5 　隧道认证 　 　221\n8.5.6 　隧道的安全性考虑  221\n8.6 　中继　　222\n8.7 　更多信息　　224\n第9章 　Web 机器人  225\n9.1 　爬虫及爬行方式  226\n9.1.1 　从哪儿开始：根集  226\n9.1.2 　链接的提取以及相对链接的标准化 　 　227\n9.1.3 　避免环路的出现  228\n9.1.4 　循环与复制  228\n9.1.5 　面包屑留下的痕迹  229\n9.1.6 　别名与机器人环路  230\n9.1.7 　规范化URL 　 　230\n9.1.8 　文件系统连接环路  231\n9.1.9 　动态虚拟Web 空间 　 　232\n9.1.10 　避免循环和重复 　 　233\n9.2 　机器人的HTTP  236\n9.2.1 　识别请求首部  236\n9.2.2 　虚拟主机 　 　236\n9.2.3 　条件请求 　 　237\n9.2.4 　对响应的处理  238\n9.2.5 　User-Agent 导向  239\n9.3 　行为不当的机器人  239\n9.4 　拒绝机器人访问  240\n9.4.1 　拒绝机器人访问标准  241\n9.4.2 　Web 站点和robots.txt 文件  242\n9.4.3 　robots.txt 文件的格式  243\n9.4.4 　其他有关robots.txt 的知识  246\n9.4.5 　缓存和robots.txt 的过期 　 　246\n9.4.6 　拒绝机器人访问的Perl 代码 　 　246\n9.4.7 　HTML 的robot-control 元标签 　 　249\n9.5 　机器人的规范 　 　251\n9.6 　搜索引擎　　254\n9.6.1 　大格局 　 　255\n9.6.2 　现代搜索引擎结构  255\n9.6.3 　全文索引 　 　255\n9.6.4 　发布查询请求  257\n9.6.5 　对结果进行排序，并提供查询结果 　 　258\n9.6.6 　欺诈　　258\n9.7 　更多信息　　258\n第10章 　HTTP-NG 　 　261\n10.1 　HTTP 发展中存在的问题  262\n10.2 　HTTP-NG 的活动  263\n10.3 　模块化及功能增强  263\n10.4 　分布式对象 　 　264\n10.5 　第一层——报文传输 　 　264\n10.6 　第二层——远程调用 　 　265\n10.7 　第三层——Web 应用 　 　265\n10.8 　WebMUX 　 　265\n10.9 　二进制连接协议 　 　266\n10.10 　当前的状态 　 　267\n10.11 　更多信息 　 　267\n第三部分 　识别、认证与安全\n第11章 　客户端识别与cookie 机制 　 　271\n11.1 　个性化接触 　 　272\n11.2 　HTTP 首部　　273\n11.3 　客户端IP 地址  274\n11.4 　用户登录　　275\n11.5 　胖URL　　277\n11.6 　cookie 　 　278\n11.6.1 　cookie 的类型  278\n11.6.2 　cookie 是如何工作的  279\n11.6.3 　cookie 罐：客户端的状态 　 　280\n11.6.4 　不同站点使用不同的cookie  282\n11.6.5 　cookie 成分  283\n11.6.6 　cookies 版本0（Netscape） 　 　284\n11.6.7 　cookies 版本1（RFC 2965）  285\n11.6.8 　cookie 与会话跟踪  288\n11.6.9 　cookie 与缓存  290\n11.6.10 　cookie、安全性和隐私 　 　291\n11.7 　更多信息　　292\n第12章 　基本认证机制  293\n12.1 　认证 　 　294\n12.1.1 　HTTP 的质询/ 响应认证框架 　 　294\n12.1.2 　认证协议与首部  295\n12.1.3 　安全域  296\n12.2 　基本认证　　297\n12.2.1 　基本认证实例  298\n12.2.2 　Base-64 用户名/ 密码编码 　 　298\n12.2.3 　代理认证  299\n12.3 　基本认证的安全缺陷 　 　300\n12.4 　更多信息　　301\n第13章 　摘要认证 　 　303\n13.1 　摘要认证的改进 　 　304\n13.1.1 　用摘要保护密码  304\n13.1.2 　单向摘要  306\n13.1.3 　用随机数防止重放攻击 　 　307\n13.1.4 　摘要认证的握手机制  307\n13.2 　摘要的计算 　 　308\n13.2.1 　摘要算法的输入数据  308\n13.2.2 　算法H(d) 和KD(s,d)  310\n13.2.3 　与安全性相关的数据（A1）  310\n13.2.4 　与报文有关的数据（A2）  310\n13.2.5 　摘要算法总述 　 　311\n13.2.6 　摘要认证会话  312\n13.2.7 　预授权  312\n13.2.8 　随机数的选择  315\n13.2.9 　对称认证  315\n13.3 　增强保护质量 　 　316\n13.3.1 　报文完整性保护  316\n13.3.2 　摘要认证首部  317\n13.4 　应该考虑的实际问题 　 　317\n13.4.1 　多重质询  318\n13.4.2 　差错处理  318\n13.4.3 　保护空间  318\n13.4.4 　重写URI  319\n13.4.5 　缓存 　 　319\n13.5 　安全性考虑 　 　320\n13.5.1 　首部篡改  320\n13.5.2 　重放攻击  320\n13.5.3 　多重认证机制  320\n13.5.4 　词典攻击  321\n13.5.5 　恶意代理攻击和中间人攻击  321\n13.5.6 　选择明文攻击  321\n13.5.7 　存储密码  322\n13.6 　更多信息　　322\n第14章 　安全HTTP  323\n14.1 　保护HTTP 的安全 　 　324\n14.2 　数字加密　　326\n14.2.1 　密码编制的机制与技巧 　 　326\n14.2.2 　密码 　 　327\n14.2.3 　密码机  328\n14.2.4 　使用了密钥的密码  328\n14.2.5 　数字密码  328\n14.3 　对称密钥加密技术 　 　330\n14.3.1 　密钥长度与枚举攻击  330\n14.3.2 　建立共享密钥  332\n14.4 　公开密钥加密技术 　 　332\n14.4.1 　RSA 　 　333\n14.4.2 　混合加密系统和会话密钥 　 　334\n14.5 　数字签名　　334\n14.6 　数字证书　　336\n14.6.1 　证书的主要内容  336\n14.6.2 　X.509 v3 证书  337\n14.6.3 　用证书对服务器进行认证 　 　338\n14.7 　HTTPS——细节介绍 　 　339\n14.7.1 　HTTPS 概述  339\n14.7.2 　HTTPS 方案  340\n14.7.3 　建立安全传输  341\n14.7.4 　SSL 握手  341\n14.7.5 　服务器证书  343\n14.7.6 　站点证书的有效性  344\n14.7.7 　虚拟主机与证书  345\n14.8 　HTTPS 客户端实例 　 　345\n14.8.1 　OpenSSL  346\n14.8.2 　简单的HTTPS 客户端 　 　347\n14.8.3 　执行OpenSSL 客户端 　 　350\n14.9 　通过代理以隧道形式传输安全流量 　 　351\n14.10 　更多信息 　 　353\n14.10.1 　HTTP 安全性 　 　353\n14.10.2 　SSL 与TLS  353\n14.10.3 　公开密钥基础设施  354\n14.10.4 　数字密码  354\n第四部分 　实体、编码和国际化\n第15章 　实体和编码  357\n15.1 　报文是箱子，实体是货物 　 　359\n15.2 　Content-Length: 实体的大小  361\n15.2.1 　检测截尾  361\n15.2.2 　错误的Content-Length 　 　362\n15.2.3 　Content-Length 与持久连接  362\n15.2.4 　内容编码  362\n15.2.5 　确定实体主体长度的规则 　 　362\n15.3 　实体摘要　　364\n15.4 　媒体类型和字符集 　 　364\n15.4.1 　文本的字符编码  365\n15.4.2 　多部分媒体类型  365\n15.4.3 　多部分表格提交  366\n15.4.4 　多部分范围响应  367\n15.5 　内容编码　　368\n15.5.1 　内容编码过程  368\n15.5.2 　内容编码类型  369\n15.5.3 　Accept-Encoding 首部 　 　369\n15.6 　传输编码和分块编码 　 　371\n15.6.1 　可靠传输  371\n15.6.2 　Transfer-Encoding 首部  372\n15.6.3 　分块编码  373\n15.6.4 　内容编码与传输编码的结合  375\n15.6.5 　传输编码的规则  375\n15.7 　随时间变化的实例 　 　375\n15.8 　验证码和新鲜度 　 　376\n15.8.1 　新鲜度  377\n15.8.2 　有条件的请求与验证码 　 　378\n15.9 　范围请求　　380\n15.10 　差异编码 　 　382\n15.11 　更多信息 　 　385\n第16章 　国际化 　 　387\n16.1 　HTTP 对国际性内容的支持  388\n16.2 　字符集与HTTP 　 　389\n16.2.1 　字符集是把字符转换为二进制码的编码　　389\n16.2.2 　字符集和编码如何工作 　 　390\n16.2.3 　字符集不对，字符就不对 　 　391\n16.2.4 　标准化的MIME charset 值 　 　391\n16.2.5 　Content-Type 首部和Charset 首部以及META 标志 　 　393\n16.2.6 　Accept-Charset 首部 　 　393\n16.3 　多语言字符编码入门 　 　394\n16.3.1 　字符集术语  394\n16.3.2 　字符集的命名很糟糕  395\n16.3.3 　字符 　 　396\n16.3.4 　字形、连笔以及表示形式 　 　396\n16.3.5 　编码后的字符集  397\n16.3.6 　字符编码方案  399\n16.4 　语言标记与HTTP  402\n16.4.1 　Content-Language 首部 　 　402\n16.4.2 　Accept-Language 首部 　 　403\n16.4.3 　语言标记的类型  404\n16.4.4 　子标记  404\n16.4.5 　大小写  405\n16.4.6 　IANA 语言标记注册 　 　405\n16.4.7 　第一个子标记——名字空间  405\n16.4.8 　第二个子标记——名字空间  406\n16.4.9 　其余子标记——名字空间 　 　407\n16.4.10 　配置和语言有关的首选项 　 　407\n16.4.11 　语言标记参考表 　 　407\n16.5 　国际化的URI 　 　408\n16.5.1 　全球性的可转抄能力与有意义的字符的较量 　 　408\n16.5.2 　URI 字符集合  408\n16.5.3 　转义和反转义  409\n16.5.4 　转义国际化字符  409\n16.5.5 　URI 中的模态切换  410\n16.6 　其他需要考虑的地方 　 　410\n16.6.1 　首部和不合规范的数据 　 　410\n16.6.2 　日期 　 　411\n16.6.3 　域名 　 　411\n16.7 　更多信息　　411\n16.7.1 　附录 　 　411\n16.7.2 　互联网的国际化  411\n16.7.3 　国际标准  412\n第17章 　内容协商与转码  413\n17.1 　内容协商技术 　 　414\n17.2 　客户端驱动的协商 　 　415\n17.3 　服务器驱动的协商 　 　415\n17.3.1 　内容协商首部集  416\n17.3.2 　内容协商首部中的质量值 　 　417\n17.3.3 　随其他首部集而变化  417\n17.3.4 　Apache 中的内容协商  417\n17.3.5 　服务器端扩展  418\n17.4 　透明协商　　419\n17.4.1 　进行缓存与备用候选  419\n17.4.2 　Vary 首部 　 　420\n17.5 　转码 　 　422\n17.5.1 　格式转换  422\n17.5.2 　信息综合  423\n17.5.3 　内容注入  423\n17.5.4 　转码与静态预生成的对比 　 　423\n17.6 　下一步计划 　 　424\n17.7 　更多信息　　424\n第五部分 　内容发布与分发\n第18章 　Web 主机托管 　 　429\n18.1 　主机托管服务 　 　430\n18.2 　虚拟主机托管 　 　431\n18.2.1 　虚拟服务器请求缺乏主机信息 　 　432\n18.2.2 　设法让虚拟主机托管正常工作 　 　433\n18.2.3 　HTTP/1.1 的Host 首部 　 　437\n18.3 　使网站更可靠 　 　438\n18.3.1 　镜像的服务器集群  438\n18.3.2 　内容分发网络  440\n18.3.3 　CDN 中的反向代理缓存  440\n18.3.4 　CDN 中的代理缓存 　 　440\n18.4 　让网站更快 　 　441\n18.5 　更多信息　　441\n第19章 　发布系统 　 　443\n19.1 　FrontPage 为支持发布而做的服务器扩展　　444\n19.1.1 　FrontPage 服务器扩展 　 　444\n19.1.2 　FrontPage 术语表 　 　445\n19.1.3 　FrontPage 的RPC 协议 　 　445\n19.1.4 　FrontPage 的安全模型 　 　448\n19.2 　WebDAV 与协作写作 　 　449\n19.2.1 　WebDAV 的方法 449\n19.2.2 　WebDAV 与XML 　 　450\n19.2.3 　WebDAV 首部集 451\n19.2.4 　WebDAV 的锁定与防止覆写 452\n19.2.5 　LOCK 方法  453\n19.2.6 　UNLOCK 方法 　 　456\n19.2.7 　属性和元数据  456\n19.2.8 　PROPFIND 方法  457\n19.2.9 　PROPPATCH 方法 　 　459\n19.2.10 　集合与名字空间管理 　 　460\n19.2.11 　MKCOL 方法  460\n19.2.12 　DELETE 方法 　 　461\n19.2.13 　COPY 与MOVE 方法 　 　462\n19.2.14 　增强的HTTP/1.1 方法 　 　465\n19.2.15 　WebDAV 中的版本管理 466\n19.2.16 　WebDAV 的未来发展  466\n19.3 　更多信息　　467\n第20章 　重定向与负载均衡 　 　469\n20.1 　为什么要重定向 　 　470\n20.2 　重定向到何地 　 　471\n20.3 　重定向协议概览 　 　471\n20.4 　通用的重定向方法 　 　474\n20.4.1 　HTTP 重定向 　 　474\n20.4.2 　DNS 重定向  475\n20.4.3 　任播寻址  480\n20.4.4 　IP MAC 转发 　 　481\n20.4.5 　IP 地址转发  482\n20.4.6 　网元控制协议  484\n20.5 　代理的重定向方法 　 　485\n20.5.1 　显式浏览器配置  485\n20.5.2 　代理自动配置  485\n20.5.3 　Web 代理自动发现协议 　 　487\n20.6 　缓存重定向方法 　 　492\n20.7 　因特网缓存协议 　 　496\n20.8 　缓存阵列路由协议 　 　497\n20.9 　超文本缓存协议 　 　500\n20.9.1 　HTCP 认证 　 　502\n20.9.2 　设置缓存策略  503\n20.10 　更多信息 　 　504\n第21章 　日志记录与使用情况跟踪 　 　505\n21.1 　记录内容　　506\n21.2 　日志格式　　507\n21.2.1 　常见日志格式  507\n21.2.2 　组合日志格式  508\n21.2.3 　网景扩展日志格式  509\n21.2.4 　网景扩展2 日志格式  510\n21.2.5 　Squid 代理日志格式 　 　512\n21.3 　命中率测量 　 　515\n21.3.1 　概述 　 　515\n21.3.2 　Meter 首部  516\n21.4 　关于隐私的考虑 　 　517\n21.5 　更多信息　　518\n第六部分 　附 　录\n附录A 　URI 方案　　521\n附录B 　HTTP 状态码 　 　529\n附录C 　HTTP 首部参考 　 　533\n附录D 　MIME 类型 　 　557\n附录E 　Base-64 编码 　 　603\n附录F 　摘要认证 　 　607\n附录G 　语言标记　　615\n附录H 　MIME 字符集注册表  641\n索引　　661",
        "pages": "720",
        "images": {
          "small": "https://img1.doubanio.com/spic/s11329547.jpg",
          "large": "https://img1.doubanio.com/lpic/s11329547.jpg",
          "medium": "https://img1.doubanio.com/mpic/s11329547.jpg"
        },
        "alt": "https://book.douban.com/subject/10746113/",
        "id": "10746113",
        "publisher": "人民邮电出版社",
        "isbn10": "7115281483",
        "isbn13": "9787115281487",
        "title": "Http权威指南",
        "url": "https://api.douban.com/v2/book/10746113",
        "alt_title": "HTTP: The Definitive Guide",
        "author_intro": "David Gourley是Endeca的首席技术官（Chief Technology Officer），负责Endeca产品的研究及开发。Endeca开发的因特网及内部网络信息访问解决方案为企业级数据的导航及研究提供了一些新的方式。在到Endeca工作之前，David是Inktomi基础工程组的一员，他在那儿帮助开发了Inktomi的因特网搜索数据库，是Inktomi的Web缓存产品的主要开发者。\nDavid在加州大学伯克利分校获得了计算机科学的学士学位，还拥有Web技术方面的几项专利。\nBrian Totty最近出任了Inktomi公司（这是1996年他参与建立的一家公司）研发部副总裁，在公司中他负责Web缓存、流媒体及因特网搜索技术的研发工作。他曾是Silicon Graphics公司的一名科学家，他在那儿为高性能网络和超级计算机系统设计软件并对其进行优化。在那之前，他是苹果计算机公司高级技术组的一名工程师。\nBrian在伊利诺伊大学Urbana-Champaign分校获得了计算机科学的博士学位，在MIT获得了计算机科学及电子工程的学士学位，在那里他获得了计算机系统研究的Organick奖。他还为加州大学扩展系统开发并讲授了一些屡获殊荣的因特网技术方面的课程。\nMarjorie Sayer在Inktomi公司负责编写Web缓存方面的软件。在加州大学伯克利分校获得了数学硕士和博士学位之后，一直致力于数学课程的改革。从1990年开始致力于能量资源管理、并行系统软件、电话和网络方面的写作。\nSailu Reddy目前在Inktomi公司负责嵌入式的性能增强型HTTP 代理的开发。Sailu从事复杂软件系统的开发已经有12年了，从1995年开始深入Web架构的研发工作。他是Netscape第一台Web服务器、Web 代理产品，以及后面几代产品的核心工程师。他具备HTTP应用程序、数据压缩技术、数据库引擎以及合作管理等方面的技术经验。Sailu在亚里桑那大学获得了信息系统的硕士学位并握有Web技术方面的多项专利。\nAnshu Aggarwal是Inktomi公司的工程总监。他领导着Inktomi公司Web缓存产品的协议处理工程组，从1997年就开始参与Inktomi的Web技术设计工作。Anshu在科罗拉多大学Boulder分校获得了计算机科学的硕士和博士学位，从事分布式多处理器的内存一致性技术研究。他还拥有电子工程的硕士和学士学位。Anshu撰写了多篇技术论文，还拥有两项专利。",
        "summary": "超文本转移协议（Hypertext Transfer Protocol，HTTP）是在万维网上进行通信时所使用的协议方案。HTTP有很多应用，但最著名的是用于web浏览器和web服务器之间的双工通信。\nHTTP起初是一个简单的协议，因此你可能会认为关于这个协议没有太多好 说的。但现在，你手上拿着的是却一本两磅重 的书。如果你对我们怎么会写出一本650页 的关于HTTP的书感到奇怪的话，可以去看一下目录。本书不仅仅是一本HTTP首部的参考手册；它是一本名副其实的web结构圣经。\n本书中，我们尝试着将HTTP中一些互相关联且常被误解的规则梳理清楚，并编写了一系列基于各种主题的章节，对HTTP各方面的特性进行了介绍。纵观全书，我们对HTTP“为什么”这样做进行了详细的解释，而不仅仅停留在它是“怎么做”的。而且，为了节省大家寻找参考文献的时间，我们还对很多HTTP应用程序正常工作所必须的、重要的非HTTP技术进行了介绍。在组织得便于使用的附录中，可以找到按照字母排序的首部参考（这些首部构成了最常见的HTTP文本的基础）。我们希望这种概念性的设计有助于读者对HTTP的使用。\n本书是为所有希望理解HTTP以及Web底层结构的人编写的。软硬件工程师也可以将本书作为HTTP及相关web技术的条理清楚的参考书使用。系统架构师和网络管理员可以通过本书更好地了解如何设计、实现并管理复杂的网络架构。性能工程师和分析人员可以从高速缓存和性能优化的相关章节中获益。市场营销和咨询专家可以通过概念的介绍更好地理解web技术的前景。\n本书对一些常见的误解进行了说明，推荐了“各种使用诀窍”，提供了便捷的参考资料，并且对枯燥且令人费解的标准规范进行了可读性很强的介绍。在这本书里，我们对Web正常工作所必须且互相关联的技术进行了详细的介绍。\n本书是很多对因特网技术充满热情的人经过大量工作写成的。希望对你有所帮助。",
        "price": "109.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "396a1846b8160d01ba8320a53ea2aabf8f6a0f2359b9c1aaa87e750b5f1cc2e7",
        "file": "Http权威指南.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 5,
          "average": "0.0",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "高群凯"
        ],
        "pubdate": "2010-3",
        "tags": [
          {
            "count": 12,
            "name": "lighttpd",
            "title": "lighttpd"
          },
          {
            "count": 4,
            "name": "web",
            "title": "web"
          },
          {
            "count": 3,
            "name": "http",
            "title": "http"
          },
          {
            "count": 2,
            "name": "源码分析",
            "title": "源码分析"
          },
          {
            "count": 1,
            "name": "源友",
            "title": "源友"
          },
          {
            "count": 1,
            "name": "架构",
            "title": "架构"
          },
          {
            "count": 1,
            "name": "as",
            "title": "as"
          },
          {
            "count": 1,
            "name": "TCP/IP",
            "title": "TCP/IP"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s26387926.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "前言\n第1章 lighttpd介绍与分析准备工作 1\n1.1 lighttpd介绍 1\n1.1.1 什么是lighttpd 1\n1.1.2 lighttpd功能概述 1\n1.2 源码分析的准备工作 3\n1.2.1 lighttpd源码下载与组织结构 3\n1.2.2 lighttpd源码分析工具 4\n1.2.3 系统编译环境 6\n1.2.4 lighttpd编译运行 6\n1.2.5 其他准备 7\n1.3 本书内容综述 7\n1.4 本章总结 8\n第2章 lighttpd网络服务主模型 9\n2.1 概述 9\n2.2 lighttpd主进程执行流程 10\n2.2.1 lighttpd进程守护化 10\n2.2.2 lighttpd多进程网络服务模型 14\n2.3 lighttpd信号处理机制 20\n2.3.1 信号的概念 20",
        "ebook_url": "https://read.douban.com/ebook/15076844/",
        "pages": "460",
        "images": {
          "small": "https://img3.doubanio.com/spic/s26387926.jpg",
          "large": "https://img3.doubanio.com/lpic/s26387926.jpg",
          "medium": "https://img3.doubanio.com/mpic/s26387926.jpg"
        },
        "alt": "https://book.douban.com/subject/24529300/",
        "id": "24529300",
        "publisher": "机械工业出版社",
        "isbn10": "8711100001",
        "isbn13": "9788711100004",
        "title": "Lighttpd源码分析",
        "url": "https://api.douban.com/v2/book/24529300",
        "alt_title": "",
        "author_intro": "",
        "summary": "本书主要针对lighttpd源码进行了深度剖析。主要内容包括：lighttpd介绍与分析准备工作、lighttpd网络服务主模型、lighttpd数据结构、伸展树、日志系统、文件状态缓存器、配置信息加载、i/o多路复用技术模型、插件链、网络请求服务响应流程、请求响应数据快速传输方式，以及基本插件模块。本书针对的lighttpd项目版本为稳定版本1.4.20。\n本书适合使用lighttpd的人员和爱好者参考。",
        "ebook_price": "25.00",
        "price": "59.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "e75a315683dc95443eb3dd955a5271b938b4e225991b71c741cb4243bb6e39d0",
        "file": "Lighttpd源码分析.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 228,
          "average": "8.9",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "Ilya Grigorik"
        ],
        "pubdate": "2013-9",
        "tags": [
          {
            "count": 236,
            "name": "Web开发",
            "title": "Web开发"
          },
          {
            "count": 196,
            "name": "性能",
            "title": "性能"
          },
          {
            "count": 122,
            "name": "Web",
            "title": "Web"
          },
          {
            "count": 118,
            "name": "性能优化",
            "title": "性能优化"
          },
          {
            "count": 72,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 62,
            "name": "互联网",
            "title": "互联网"
          },
          {
            "count": 48,
            "name": "前端开发",
            "title": "前端开发"
          },
          {
            "count": 38,
            "name": "web",
            "title": "web"
          }
        ],
        "origin_title": "High Performance Browser Networking",
        "image": "https://img1.doubanio.com/view/subject/m/public/s27249387.jpg",
        "binding": "平装",
        "translator": [
          "李松峰"
        ],
        "catalog": "版权声明\nSteve Souders推荐序\n前言\n第一部分：网络技术概览\n第1章 延迟与带宽\n第2章 TCP的构成\n第3章 UDP的构成\n第4章 传输层安全（TLS）\n第二部分：无线网络性能\n第5章 无线网络概览\n第6章 Wi-Fi\n第7章 移动网络\n第8章 移动网络的优化建议\n第三部分：HTTP\n第9章 HTTP简史\n第10章 Web性能要点\n第11章 HTTP 1.x\n第12章 HTTP 2.0\n第13章 优化应用的交付\n第四部分 浏览器API与协议\n第14章 浏览器网络概述\n第15章 XMLHttpRequest\n第16章 服务器发送事件\n第17章 WebSocket\n第18章 WebRTC\n关于封面",
        "ebook_url": "https://read.douban.com/ebook/12055070/",
        "pages": "336",
        "images": {
          "small": "https://img1.doubanio.com/view/subject/s/public/s27249387.jpg",
          "large": "https://img1.doubanio.com/view/subject/l/public/s27249387.jpg",
          "medium": "https://img1.doubanio.com/view/subject/m/public/s27249387.jpg"
        },
        "alt": "https://book.douban.com/subject/25856314/",
        "id": "25856314",
        "publisher": "人民邮电出版社",
        "isbn10": "711534910X",
        "isbn13": "9787115349101",
        "title": "Web性能权威指南",
        "url": "https://api.douban.com/v2/book/25856314",
        "alt_title": "High Performance Browser Networking",
        "author_intro": "作者简介：\nIlya Grigorik\n是谷歌“Web加速”（Make The Web Fast）团队的性能工程师、开发大使。他每天的主要工作就是琢磨怎么让Web应用速度更快，总结并推广能够提升应用性能的最佳实践。\n在专注于研究Web性能之前，Ilya创办了PostRank公司并担任CTO，这是一家社交分析公司。他的这家公司被谷歌收购后，成为了Google Analytics中社交分析报告模块的核心。除了研究Web性能和分析，Ilya还会为开源项目做做贡献、看看书，或者写一些好玩的项目，比如VimGolf、GitHub Archive等。\n译者简介：\n李松峰\n2006年起投身翻译，出版过译著30余部，包括《JavaScript高级程序设计》、《简约至上》等畅销书。2008年进入出版业，从事技术图书编辑和审稿工作。\n2007年创立知识分享网站“为之漫笔”（cn-cuckoo.com），翻译了大量国外经典技术文章。2012年下半年创立“A List Apart中文版”站点（alistapart.cn），旨在向中文读者译介这一国际顶级Web设计与开发杂志。他经常参加技术社区活动，曾在W3ctech 2012 Mobile上分享“Dive into Responsive Web Design”。2013年1月应邀在金山网络分享“响应式Web设计”，2013年3月应邀在奇虎360分享“JS的国”。",
        "summary": "本书是谷歌公司高性能团队核心成员的权威之作，堪称实战经验与规范解读完美结合的产物。本书目标是涵盖Web 开发者技术体系中应该掌握的所有网络及性能优化知识。全书以性能优化为主线，从TCP、UDP 和TLS 协议讲起，解释了如何针对这几种协议和基础设施来优化应用。然后深入探讨了无线和移动网络的工作机制。最后，揭示了HTTP 协议的底层细节，同时详细介绍了HTTP 2.0、 XHR、SSE、WebSocket、WebRTC 和DataChannel 等现代浏览器新增的具有革命性的新能力。\n本书适合所有Web 应用及站点开发人员阅读，包括但不限于前端、后端、运维、大数据分析、\nUI/UX、存储、视频、实时消息，以及性能工程师。\nIlya Grigorik 是谷歌“Web加速”（Make The Web Fast）团队的性能工程师、开发大使。他每天的主要工作就是琢磨怎么让Web应用速度更快，总结并推广能够提升应用性能的最佳实践。",
        "ebook_price": "29.99",
        "price": "69",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "865787f9355b10f7d738dffbf42caabdc432d2a02c078d0ad0eb42726fc296c1",
        "file": "Web性能权威指南.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 8194,
          "average": "8.7",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "吴军"
        ],
        "pubdate": "2012-5-1",
        "tags": [
          {
            "count": 10936,
            "name": "数学",
            "title": "数学"
          },
          {
            "count": 4596,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 3741,
            "name": "科普",
            "title": "科普"
          },
          {
            "count": 2809,
            "name": "吴军",
            "title": "吴军"
          },
          {
            "count": 1989,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 1780,
            "name": "互联网",
            "title": "互联网"
          },
          {
            "count": 1166,
            "name": "科学",
            "title": "科学"
          },
          {
            "count": 698,
            "name": "Programming",
            "title": "Programming"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s9114855.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "出版说明\n序言1\n序言2\n前言\n第1章　文字和语言 vs 数字和信息\n第2章　自然语言处理 — 从规则到统计\n第3章　统计语言模型\n第4章　谈谈中文分词\n第5章　隐含马尔可夫模\n第6章　信息的度量和作用\n第7章　贾里尼克和现代语言处理\n第8章　简单之美 — 布尔代数和搜索引擎的索引\n第9章　图论和网络爬虫\n第10章　PageRank — Google的民主表决式网页排名技术\n第11章　如何确定网页和查询的相关性\n第12章　地图和本地搜索的最基本技术 — 有限状态机和动态规划\n第13章　Google AK-47的设计者 — 阿米特 · 辛格博士\n第14章　余弦定理和新闻的分类\n第15章　矩阵运算和文本处理中的两个分类问题\n第16章　信息指纹及其应用\n第17章　由电视剧《暗算》所想到的 — 谈谈密码学的数学原理\n第18章　闪光的不一定是金子 — 谈谈搜索引擎反作弊问题\n第19章　谈谈数学模型的重要性\n第20章　不要把鸡蛋放到一个篮子里 — 谈谈最大熵模型\n第21章　拼音输入法的数学原理\n第22章　自然语言处理的教父马库斯和他的优秀弟子们\n第23章　布隆过滤器\n第24章　马尔可夫链的扩展 — 贝叶斯网络\n第25章　条件随机场和句法分析\n第26章　维特比和他的维特比算法\n第27章　再谈文本自动分类问题 — 期望最大化算法\n第28章　逻辑回归和搜索广告\n第29章　各个击破算法和Google云计算的基础\n附录\n后记\n索引",
        "pages": "272",
        "images": {
          "small": "https://img3.doubanio.com/spic/s9114855.jpg",
          "large": "https://img3.doubanio.com/lpic/s9114855.jpg",
          "medium": "https://img3.doubanio.com/mpic/s9114855.jpg"
        },
        "alt": "https://book.douban.com/subject/10750155/",
        "id": "10750155",
        "publisher": "人民邮电出版社",
        "isbn10": "711528282X",
        "isbn13": "9787115282828",
        "title": "数学之美",
        "url": "https://api.douban.com/v2/book/10750155",
        "alt_title": "",
        "author_intro": "吴军博士，现任腾讯公司主管搜索、在线广告和云计算基础架构的副总裁，毕业于清华大学（本科、硕士）和美国约翰·霍普金斯大学（博士）。在清华大学和约翰·霍普金斯大学期间，吴军博士致力于语音识别、自然语言处理，特别是统计语言模型的研究。他曾获得1995年全国人机语音智能接口会议的最佳论文奖和2000年Eurospeech的最佳论文奖。\n吴军博士于2002年加入Google公司。在Google，他和Amit Singhal（Google院士，世界著名搜索专家）、Matt Cutts（Google反作弊官方发言人）等三位同事一起开创了网络搜索反作弊的研究领域，并因此获得Google工程奖。2003年，他和Google全球架构的总工程师朱会灿博士等共同成立了中日韩文搜索部门。吴军博士是当前Google中日韩文搜索算法的主要设计者。在Google期间，他还领导了许多研发项目，包括许多与中文相关的产品和自然语言处理的项目，并得到了当时公司首席执行官埃里克·施密特和创始人谢尔盖·布林的高度评价。\n吴军博士在国内外发表过数十篇论文，并获得和申请了十余项美国和国际专利。他撰写的《浪潮之巅》一书深受业界的好评。他于2007年起担任风险投资基金中国世纪基金的董事。2011年起，当选为约翰·霍普金斯大学工学院董事会董事，并在该校的国际事务委员会担任顾问。他是国家重大专项“新一代搜索引擎和浏览器”项目的总负责人，从2012年起任职工业与信息化部的专家和顾问。",
        "summary": "几年前，“数学之美”系列文章原刊载于谷歌黑板报，获得上百万次点击，得到读者高度评价。读者说，读了“数学之美”，才发现大学时学的数学知识，比如马尔可夫链、矩阵计算，甚至余弦函数原来都如此亲切，并且栩栩如生，才发现自然语言和信息处理这么有趣。\n今年，作者吴军博士几乎把所有文章都重写了一遍，为的是把高深的数学原理讲得更加通俗易懂，让非专业读者也能领略数学的魅力。读者通过具体的例子学到的是思考问题的方式 —— 如何化繁为简，如何用数学去解决工程问题，如何跳出固有思维不断去思考创新。",
        "price": "45.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "80c2074132e542465a3c1c51d7b6e56fede0db82abff791e58d4e329adb15aa6",
        "file": "数学之美.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 356,
          "average": "8.6",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "Ben Forta"
        ],
        "pubdate": "2007",
        "tags": [
          {
            "count": 330,
            "name": "正则表达式",
            "title": "正则表达式"
          },
          {
            "count": 116,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 99,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 55,
            "name": "正则",
            "title": "正则"
          },
          {
            "count": 44,
            "name": "Regex",
            "title": "Regex"
          },
          {
            "count": 34,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 30,
            "name": "programming",
            "title": "programming"
          },
          {
            "count": 29,
            "name": "regexp",
            "title": "regexp"
          }
        ],
        "origin_title": "Sams Teach Yourself Regular Expressions in 10 Minutes",
        "image": "https://img3.doubanio.com/view/subject/m/public/s2794811.jpg",
        "binding": "平装",
        "translator": [
          "杨涛",
          "王建桥",
          "杨晓云"
        ],
        "catalog": "第1章 正则表达式入门\n1.1 正则表达式的用途\n1.2 如何使用正则表达式\n1.3 什么是正则表达式\n1.4 使用正则表达式\n1.5 在继续学习之前\n1.6 小结\n第2章 匹配单个字符\n2.1 匹配纯文本\n2.2 匹配任意字符\n2.3 匹配特殊字符\n2.4 小结\n第3章 匹配一组字符\n3.1 匹配多个字符中的某一个\n3.2 利用字符集合区间\n3.3 取非匹配\n3.4 小结\n第4章 使用元字符\n4.1 对特殊字符进行转义\n4.2 匹配空白字符\n4.3 匹配特定的字符类别\n4.4 使用POSIX字符类\n4.5 小结\n第5章 重复匹配\n5.1 有多少个匹配\n5.2 匹配的重复次数\n5.3 防止过度匹配\n5.4 小结\n第6章 位置匹配\n6.1 边界\n6.2 单词边界\n6.3 字符串边界\n6.4 小结\n第7章 使用子表达式\n7.1 什么是子表达式\n7.2 子表达式\n7.3 子表达式的嵌套\n7.4 小结\n第8章 回溯引用：前后一致匹配\n8.1 回溯引用有什么用\n8.2 回溯引用匹配\n8.3 回溯引用在替换操作中的应用\n8.4 小结\n第9章 前后查找\n9.1 前后查找\n9.2 向前查找\n9.3 向后查找\n9.4 把向前查找和向后查找结合起来\n9.5 对前后查找取非\n9.6 小结\n第10章 嵌入条件\n10.1 为什么要嵌入条件\n10.2 正则表达式里的条件\n10.3 小结\n附录A 常见应用软件和编程语言中的正则表达式\n附录B 常见问题的正则表达式解决方案\n附录C 正则表达式测试器\n索引",
        "pages": "139",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s2794811.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s2794811.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s2794811.jpg"
        },
        "alt": "https://book.douban.com/subject/2269648/",
        "id": "2269648",
        "publisher": "人民邮电出版社",
        "isbn10": "7115164746",
        "isbn13": "9787115164742",
        "title": "正则表达式必知必会",
        "url": "https://api.douban.com/v2/book/2269648",
        "alt_title": "Sams Teach Yourself Regular Expressions in 10 Minutes",
        "author_intro": "Ben Forta是世界知名的技术作家，也是Adobe技术界最为知名的专家之一，目前担任Adobe公司的高级技术推广专家。他具有计算机行业20多年工作经验，多年来撰写了十几本技术图书，其中不少是世界畅销书，已被翻译为十几种文字。除本书外，他撰写的《SQL必知必会》也由人民邮电出版社出版。",
        "summary": "正则表达式是一种威力无比强大的武器，几乎在所有的程序设计语言里和计算机平台上都可以用它来完成各种复杂的文本处理工作。本书从简单的文本匹配开始，循序渐进地介绍了很多复杂内容，其中包括回溯引用、条件性求值和前后查找，等等。每章都为读者准备了许多简明又实用的示例，有助于全面、系统、快速掌握正则表达式，并运用它们去解决实际问题。\n本书适合各种语言和平台的开发人员。",
        "series": {
          "id": "660",
          "title": "图灵程序设计丛书"
        },
        "price": "29.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "f017675e43a11ad689d794404ca68e2bd6f5e2bdd1eff8c3afee81155a588573",
        "file": "正则表达式必知必会.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 241,
          "average": "9.9",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "Randal E.Bryant",
          "David O'Hallaron"
        ],
        "pubdate": "2016-11",
        "tags": [
          {
            "count": 225,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 201,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 152,
            "name": "计算机系统",
            "title": "计算机系统"
          },
          {
            "count": 118,
            "name": "操作系统",
            "title": "操作系统"
          },
          {
            "count": 96,
            "name": "CSAPP",
            "title": "CSAPP"
          },
          {
            "count": 92,
            "name": "计算机体系结构",
            "title": "计算机体系结构"
          },
          {
            "count": 82,
            "name": "计算机底层",
            "title": "计算机底层"
          },
          {
            "count": 57,
            "name": "CS",
            "title": "CS"
          }
        ],
        "origin_title": "Computer Systems: A Programmer's Perspective (3rd Edition)",
        "image": "https://img1.doubanio.com/view/subject/m/public/s29195878.jpg",
        "binding": "平装",
        "translator": [
          "龚奕利",
          "贺莲"
        ],
        "catalog": "出版者的话\n中文版序一\n中文版序二\n译者序\n前言\n关于作者\n第1章　计算机系统漫游1\n1.1　信息就是位+上下文1\n1.2　程序被其他程序翻译成不同的格式3\n1.3　了解编译系统如何工作是大有益处的4\n1.4　处理器读并解释储存在内存中的指令5\n1.4.1　系统的硬件组成5\n1.4.2　运行hello程序7\n1.5　高速缓存至关重要9\n1.6　存储设备形成层次结构9\n1.7　操作系统管理硬件10\n1.7.1　进程11\n1.7.2　线程12\n1.7.3　虚拟内存12\n1.7.4　文件14\n1.8　系统之间利用网络通信14\n1.9　重要主题16\n1.9.1　Amdahl定律16\n1.9.2　并发和并行17\n1.9.3　计算机系统中抽象的重要性19\n1.10　小结20\n参考文献说明20\n练习题答案20\n第一部分\n程序结构和执行\n第2章　信息的表示和处理22\n2.1　信息存储24\n2.1.1　十六进制表示法25\n2.1.2　字数据大小27\n2.1.3　寻址和字节顺序29\n2.1.4　表示字符串34\n2.1.5　表示代码34\n2.1.6　布尔代数简介35\n2.1.7　C语言中的位级运算37\n2.1.8　C语言中的逻辑运算39\n2.1.9　C语言中的移位运算40\n2.2　整数表示41\n2.2.1　整型数据类型42\n2.2.2　无符号数的编码43\n2.2.3　补码编码44\n2.2.4　有符号数和无符号数之间的转换49\n2.2.5　C语言中的有符号数与无符号数52\n2.2.6　扩展一个数字的位表示54\n2.2.7　截断数字56\n2.2.8　关于有符号数与无符号数的建议58\n2.3　整数运算60\n2.3.1　无符号加法60\n2.3.2　补码加法62\n2.3.3　补码的非66\n2.3.4　无符号乘法67\n2.3.5　补码乘法67\n2.3.6　乘以常数70\n2.3.7　除以2的幂71\n2.3.8　关于整数运算的最后思考74\n2.4　浮点数75\n2.4.1　二进制小数76\n2.4.2　IEEE浮点表示78\n2.4.3　数字示例79\n2.4.4　舍入83\n2.4.5　浮点运算85\n2.4.6　C语言中的浮点数86\n2.5　小结87\n参考文献说明88\n家庭作业88\n练习题答案97\n第3章　程序的机器级表示109\n3.1　历史观点110\n3.2　程序编码113\n3.2.1　机器级代码113\n3.2.2　代码示例114\n3.2.3　关于格式的注解117\n3.3　数据格式119\n3.4　访问信息119\n3.4.1　操作数指示符121\n3.4.2　数据传送指令122\n3.4.3　数据传送示例125\n3.4.4　压入和弹出栈数据127\n3.5　算术和逻辑操作128\n3.5.1　加载有效地址129\n3.5.2　一元和二元操作130\n3.5.3　移位操作131\n3.5.4　讨论131\n3.5.5　特殊的算术操作133\n3.6　控制135\n3.6.1　条件码135\n3.6.2　访问条件码136\n3.6.3　跳转指令138\n3.6.4　跳转指令的编码139\n3.6.5　用条件控制来实现条件分支…141\n3.6.6　用条件传送来实现条件分支…145\n3.6.7　循环149\n3.6.8　switch语句159\n3.7　过程164\n3.7.1　运行时栈164\n3.7.2　转移控制165\n3.7.3　数据传送168\n3.7.4　栈上的局部存储170\n3.7.5　寄存器中的局部存储空间172\n3.7.6　递归过程174\n3.8　数组分配和访问176\n3.8.1　基本原则176\n3.8.2　指针运算177\n3.8.3　嵌套的数组178\n3.8.4　定长数组179\n3.8.5　变长数组181\n3.9　异质的数据结构183\n3.9.1　结构183\n3.9.2　联合186\n3.9.3　数据对齐189\n3.10　在机器级程序中将控制与数据结合起来192\n3.10.1　理解指针192\n3.10.2　应用：使用GDB调试器193\n3.10.3　内存越界引用和缓冲区溢出194\n3.10.4　对抗缓冲区溢出攻击198\n3.10.5　支持变长栈帧201\n3.11　浮点代码204\n3.11.1　浮点传送和转换操作205\n3.11.2　过程中的浮点代码209\n3.11.3　浮点运算操作210\n3.11.4　定义和使用浮点常数212\n3.11.5　在浮点代码中使用位级操作212\n3.11.6　浮点比较操作213\n3.11.7　对浮点代码的观察结论215\n3.12　小结216\n参考文献说明216\n家庭作业216\n练习题答案226\n第4章　处理器体系结构243\n4.1　Y86-64指令集体系结构245\n4.1.1　程序员可见的状态245\n4.1.2　Y86-64指令245\n4.1.3　指令编码246\n4.1.4　Y86-64异常250\n4.1.5　Y86-64程序251\n4.1.6　一些Y86-64指令的详情255\n4.2　逻辑设计和硬件控制语言HCL256\n4.2.1　逻辑门257\n4.2.2　组合电路和HCL布尔表达式257\n4.2.3　字级的组合电路和HCL整数表达式258\n4.2.4　集合关系261\n4.2.5　存储器和时钟262\n4.3　Y86-64的顺序实现264\n4.3.1　将处理组织成阶段264\n4.3.2　SEQ硬件结构272\n4.3.3　SEQ的时序274\n4.3.4　SEQ阶段的实现277\n4.4　流水线的通用原理282\n4.4.1　计算流水线282\n4.4.2　流水线操作的详细说明284\n4.4.3　流水线的局限性284\n4.4.4　带反馈的流水线系统287\n4.5　Y86-64的流水线实现288\n4.5.1　SEQ+：重新安排计算阶段288\n4.5.2　插入流水线寄存器289\n4.5.3　对信号进行重新排列和标号292\n4.5.4　预测下一个PC293\n4.5.5　流水线冒险295\n4.5.6　异常处理306\n4.5.7　PIPE各阶段的实现308\n4.5.8　流水线控制逻辑314\n4.5.9　性能分析322\n4.5.10　未完成的工作323\n4.6　小结325\n参考文献说明326\n家庭作业327\n练习题答案331\n第5章　优化程序性能341\n5.1　优化编译器的能力和局限性342\n5.2　表示程序性能345\n5.3　程序示例347\n5.4　消除循环的低效率350\n5.5　减少过程调用353\n5.6　消除不必要的内存引用354\n5.7　理解现代处理器357\n5.7.1　整体操作357\n5.7.2　功能单元的性能361\n5.7.3　处理器操作的抽象模型362\n5.8　循环展开366\n5.9　提高并行性369\n5.9.1　多个累积变量370\n5.9.2　重新结合变换373\n5.10　优化合并代码的结果小结377\n5.11　一些限制因素378\n5.11.1　寄存器溢出378\n5.11.2　分支预测和预测错误处罚379\n5.12　理解内存性能382\n5.12.1　加载的性能382\n5.12.2　存储的性能383\n5.13　应用：性能提高技术387\n5.14　确认和消除性能瓶颈388\n5.14.1　程序剖析388\n5.14.2　使用剖析程序来指导优化390\n5.15　小结392\n参考文献说明393\n家庭作业393\n练习题答案395\n第6章　存储器层次结构399\n6.1　存储技术399\n6.1.1　随机访问存储器400\n6.1.2　磁盘存储406\n6.1.3　固态硬盘414\n6.1.4　存储技术趋势415\n6.2　局部性418\n6.2.1　对程序数据引用的局部性418\n6.2.2　取指令的局部性419\n6.2.3　局部性小结420\n6.3　存储器层次结构421\n6.3.1　存储器层次结构中的缓存422\n6.3.2　存储器层次结构概念小结424\n6.4　高速缓存存储器425\n6.4.1　通用的高速缓存存储器组织结构425\n6.4.2　直接映射高速缓存427\n6.4.3　组相联高速缓存433\n6.4.4　全相联高速缓存434\n6.4.5　有关写的问题437\n6.4.6　一个真实的高速缓存层次结构的解剖438\n6.4.7　高速缓存参数的性能影响439\n6.5　编写高速缓存友好的代码440\n6.6　综合：高速缓存对程序性能的影响444\n6.6.1　存储器山444\n6.6.2　重新排列循环以提高空间局部性447\n6.6.3　在程序中利用局部性450\n6.7　小结450\n参考文献说明451\n家庭作业451\n练习题答案459\n第二部分\n在系统上运行程序\n第7章　链接464\n7.1　编译器驱动程序465\n7.2　静态链接466\n7.3　目标文件466\n7.4　可重定位目标文件467\n7.5　符号和符号表468\n7.6　符号解析470\n7.6.1　链接器如何解析多重定义的全局符号471\n7.6.2　与静态库链接475\n7.6.3　链接器如何使用静态库来解析引用477\n7.7　重定位478\n7.7.1　重定位条目479\n7.7.2　重定位符号引用479\n7.8　可执行目标文件483\n7.9　加载可执行目标文件484\n7.10　动态链接共享库485\n7.11　从应用程序中加载和链接共享库487\n7.12　位置无关代码489\n7.13　库打桩机制492\n7.13.1　编译时打桩492\n7.13.2　链接时打桩492\n7.13.3　运行时打桩494\n7.14　处理目标文件的工具496\n7.15　小结496\n参考文献说明497\n家庭作业497\n练习题答案499\n第8章　异常控制流501\n8.1　异常502\n8.1.1　异常处理503\n8.1.2　异常的类别504\n8.1.3　Linux/x86-64系统中的异常505\n8.2　进程508\n8.2.1　逻辑控制流508\n8.2.2　并发流509\n8.2.3　私有地址空间509\n8.2.4　用户模式和内核模式510\n8.2.5　上下文切换511\n8.3　系统调用错误处理512\n8.4　进程控制513\n8.4.1　获取进程ID513\n8.4.2　创建和终止进程513\n8.4.3　回收子进程516\n8.4.4　让进程休眠521\n8.4.5　加载并运行程序521\n8.4.6　利用fork和execve运行程序524\n8.5　信号526\n8.5.1　信号术语527\n8.5.2　发送信号528\n8.5.3　接收信号531\n8.5.4　阻塞和解除阻塞信号532\n8.5.5　编写信号处理程序533\n8.5.6　同步流以避免讨厌的并发错误540\n8.5.7　显式地等待信号543\n8.6　非本地跳转546\n8.7　操作进程的工具550\n8.8　小结550\n参考文献说明550\n家庭作业550\n练习题答案556\n第9章　虚拟内存559\n9.1　物理和虚拟寻址560\n9.2　地址空间560\n9.3　虚拟内存作为缓存的工具561\n9.3.1　DRAM缓存的组织结构562\n9.3.2　页表562\n9.3.3　页命中563\n9.3.4　缺页564\n9.3.5　分配页面565\n9.3.6　又是局部性救了我们565\n9.4　虚拟内存作为内存管理的工具565\n9.5　虚拟内存作为内存保护的工具567\n9.6　地址翻译567\n9.6.1　结合高速缓存和虚拟内存570\n9.6.2　利用TLB加速地址翻译570\n9.6.3　多级页表571\n9.6.4　综合：端到端的地址翻译573\n9.7　案例研究：Intel Core i7/Linux内存系统576\n9.7.1　Core i7地址翻译576\n9.7.2　Linux虚拟内存系统580\n9.8　内存映射582\n9.8.1　再看共享对象583\n9.8.2　再看fork函数584\n9.8.3　再看execve函数584\n9.8.4　使用mmap函数的用户级内存映射585\n9.9　动态内存分配587\n9.9.1　malloc和free函数587\n9.9.2　为什么要使用动态内存分配589\n9.9.3　分配器的要求和目标590\n9.9.4　碎片591\n9.9.5　实现问题592\n9.9.6　隐式空闲链表592\n9.9.7　放置已分配的块593\n9.9.8　分割空闲块594\n9.9.9　获取额外的堆内存594\n9.9.10　合并空闲块594\n9.9.11　带边界标记的合并595\n9.9.12　综合：实现一个简单的分配器597\n9.9.13　显式空闲链表603\n9.9.14　分离的空闲链表604\n9.10　垃圾收集605\n9.10.1　垃圾收集器的基本知识606\n9.10.2　Mark&Sweep垃圾收集器607\n9.10.3　C程序的保守Mark&Sweep608\n9.11　C程序中常见的与内存有关的错误609\n9.11.1　间接引用坏指针609\n9.11.2　读未初始化的内存609\n9.11.3　允许栈缓冲区溢出610\n9.11.4　假设指针和它们指向的对象是相同大小的610\n9.11.5　造成错位错误611\n9.11.6　引用指针，而不是它所指向的对象611\n9.11.7　误解指针运算611\n9.11.8　引用不存在的变量612\n9.11.9　引用空闲堆块中的数据612\n9.11.10　引起内存泄漏613\n9.12　小结613\n参考文献说明613\n家庭作业614\n练习题答案617\n第三部分\n程序间的交互和通信\n第10章　系统级I/O622　10.1　Unix I/O622\n10.2　文件623\n10.3　打开和关闭文件624\n10.4　读和写文件625\n10.5　用RIO包健壮地读写626\n10.5.1　RIO的无缓冲的输入输出函数627\n10.5.2　RIO的带缓冲的输入函数627\n10.6　读取文件元数据632\n10.7　读取目录内容633\n10.8　共享文件634\n10.9　I/O重定向637\n10.10　标准I/O638\n10.11　综合：我该使用哪些I/O函数？638\n10.12　小结640\n参考文献说明640\n家庭作业640\n练习题答案641\n第11章　网络编程642\n11.1　客户端服务器编程模型642\n11.2　网络643\n11.3　全球IP因特网646\n11.3.1　IP地址647\n11.3.2　因特网域名649\n11.3.3　因特网连接651\n11.4　套接字接口652\n11.4.1　套接字地址结构653\n11.4.2　socket函数654\n11.4.3　connect函数654\n11.4.4　bind函数654\n11.4.5　listen函数655\n11.4.6　accept函数655\n11.4.7　主机和服务的转换656\n11.4.8　套接字接口的辅助函数660\n11.4.9　echo客户端和服务器的示例662\n11.5　Web服务器665\n11.5.1　Web基础665\n11.5.2　Web内容666\n11.5.3　HTTP事务667\n11.5.4　服务动态内容669\n11.6　综合：TINY Web服务器671\n11.7　小结678\n参考文献说明678\n家庭作业678\n练习题答案679\n第12章　并发编程681\n12.1　基于进程的并发编程682\n12.2　基于I/O多路复用的并发编程684\n12.3　基于线程的并发编程691\n12.4　多线程程序中的共享变量696\n12.5　用信号量同步线程698\n12.6　使用线程提高并行性710\n12.7　其他并发问题716\n12.8　小结722\n参考文献说明723\n家庭作业723\n练习题答案726\n附录A　错误处理729\n参考文献733",
        "pages": "737",
        "images": {
          "small": "https://img1.doubanio.com/view/subject/s/public/s29195878.jpg",
          "large": "https://img1.doubanio.com/view/subject/l/public/s29195878.jpg",
          "medium": "https://img1.doubanio.com/view/subject/m/public/s29195878.jpg"
        },
        "alt": "https://book.douban.com/subject/26912767/",
        "id": "26912767",
        "publisher": "机械工业出版社",
        "isbn10": "7111544935",
        "isbn13": "9787111544937",
        "title": "深入理解计算机系统（原书第3版）",
        "url": "https://api.douban.com/v2/book/26912767",
        "alt_title": "Computer Systems: A Programmer's Perspective (3rd Edition)",
        "author_intro": "Randal E. Bryant，1981年于麻省理工学院获得计算机博士学位，1984年至今一直任教于卡内基-梅隆大学。现任卡内基-梅隆大学计算机科学学院院长、教授，同时还受邀任教于电子和计算机工程系。他从事本科生和研究生计算机系统方面课程的教学近40年。他和O’Hallaron教授一起在卡内基梅隆大学开设了15-213课程“计算机系统导论”，那便是本书的基础。他还是ACM院士、IEEE院士、美国国家工程院院士和美国人文与科学研究院院士。其研究成果被Intel、IBM、Fujitsu和Microsoft等主要计算机制造商使用，他还因研究获得过Semiconductor Research Corporation、ACM、IEEE颁发的多项大奖。\n\nDavid R. O’Hallaron卡内基梅隆大学电子和计算机工程系教授。在弗吉尼亚大学（University of Virginia）获得计算机科学的博士学位，2007年-2010年为Intel匹兹堡实验室主任。他教授本科生和研究生的计算机系统方面的课程已有20余年，并和Bryant教授一起开设了“计算机系统导论”课程。曾获得CMU计算机学院颁发的Herbert Simon杰出教学奖。他主要从事计算机系统领域的研究，与Quake项目成员一起获得过高性能计算领域中的*高国际奖项——Gordon Bell奖。他目前的工作重点是研究自动分级（autograding）概念，即评价其他程序质量的程序。",
        "summary": "和第2版相比，本版内容上*大的变化是，从以IA32和x86-64为基础转变为完全以x86-64为基础。主要更新如下：\n基于x86-64，大量地重写代码，首次介绍对处理浮点数据的程序的机器级支持。\n处理器体系结构修改为支持64位字和操作的设计。\n引入更多的功能单元和更复杂的控制逻辑，使基于程序数据流表示的程序性能模型预测更加可靠。\n扩充关于用GOT和PLT创建与位置无关代码的讨论，描述了更加强大的链接技术（比如库打桩）。\n增加了对信号处理程序更细致的描述，包括异步信号安全的函数等。\n采用新函数，更新了与协议无关和线程安全的网络编程。",
        "series": {
          "id": "1163",
          "title": "计算机科学丛书"
        },
        "price": "139.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "2480c0fbd4251965df958ed088eaa64bee4e5e45fa339454f95def28f7fc1efa",
        "file": "深入理解计算机系统（原书第3版）.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 21,
          "average": "9.1",
          "min": 0
        },
        "subtitle": "第3版",
        "author": [
          "[美] Jeffrey E.F.Friedl"
        ],
        "pubdate": "2012-7",
        "tags": [
          {
            "count": 27,
            "name": "正则表达式",
            "title": "正则表达式"
          },
          {
            "count": 13,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 11,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 6,
            "name": "基础",
            "title": "基础"
          },
          {
            "count": 4,
            "name": "技术",
            "title": "技术"
          },
          {
            "count": 2,
            "name": "Java",
            "title": "Java"
          },
          {
            "count": 1,
            "name": "程序猿",
            "title": "程序猿"
          },
          {
            "count": 1,
            "name": "校图",
            "title": "校图"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/view/subject/m/public/s11292040.jpg",
        "binding": "平装",
        "translator": [
          "余晟"
        ],
        "catalog": "前言\tI\n第1章：正则表达式入门\t1\n解决实际问题\t2\n作为编程语言的正则表达式\t4\n以文件名做类比\t4\n以语言做类比\t5\n正则表达式的思维框架\t6\n对于有部分经验的读者\t6\n检索文本文件：Egrep\t6\nEgrep元字符\t8\n行的起始和结束\t8\n字符组\t9\n用点号匹配任意字符\t11\n多选结构\t13\n忽略大小写\t14\n单词分界符\t15\n小结\t16\n可选项元素\t17\n其他量词：重复出现\t18\n括号及反向引用\t20\n神奇的转义\t22\n基础知识拓展\t23\n语言的差异\t23\n正则表达式的目标\t23\n更多的例子\t23\n正则表达式术语汇总\t27\n改进现状\t30\n总结\t32\n一家之言\t33\n第2章：入门示例拓展\t35\n关于这些例子\t36\nPerl简单入门\t37\n使用正则表达式匹配文本\t38\n向更实用的程序前进\t40\n成功匹配的副作用\t40\n错综复杂的正则表达式\t43\n暂停片刻\t49\n使用正则表达式修改文本\t50\n例子：公函生成程序\t50\n举例：修整股票价格\t51\n自动的编辑操作\t53\n处理邮件的小工具\t53\n用环视功能为数值添加逗号\t59\nText-to-HTML转换\t67\n回到单词重复问题\t77\n第3章：正则表达式的特性和流派概览\t83\n在正则的世界中漫步\t85\n正则表达式的起源\t85\n最初印象\t91\n正则表达式的注意事项和处理方式\t93\n集成式处理\t94\n程序式处理和面向对象式处理\t95\n查找和替换\t98\n其他语言中的查找和替换\t100\n注意事项和处理方式：小结\t101\n字符串，字符编码和匹配模式\t101\n作为正则表达式的字符串\t101\n字符编码\t105\nUnicode\t106\n正则模式和匹配模式\t110\n常用的元字符和特性\t113\n字符表示法\t115\n字符组及相关结构\t118\n锚点及其他“零长度断言”\t129\n注释和模式修饰符\t135\n分组，捕获，条件判断和控制\t137\n高级话题引导\t142\n第4章：表达式的匹配原理\t143\n发动引擎\t143\n两类引擎\t144\n新的标准\t144\n正则引擎的分类\t145\n几句题外话\t146\n测试引擎的类型\t146\n匹配的基础\t147\n关于范例\t147\n规则1：优先选择最左端的匹配结果\t148\n引擎的构造\t149\n规则2：标准量词是匹配优先的\t151\n表达式主导与文本主导\t153\nNFA引擎：表达式主导\t153\nDFA引擎：文本主导\t155\n第一想法：比较NFA与DFA\t156\n回溯\t157\n真实世界中的例子：面包屑\t158\n回溯的两个要点\t159\n备用状态\t159\n回溯与匹配优先\t162\n关于匹配优先和回溯的更多内容\t163\n匹配优先的问题\t164\n多字符“引文”\t165\n使用忽略优先量词\t166\n匹配优先和忽略优先都期望获得匹配\t167\n匹配优先、忽略优先和回溯的要旨\t168\n占有优先量词和固化分组\t169\n占有优先量词，?+、*+、++和{m,n}+\t172\n环视中的回溯\t173\n多选结构也是匹配优先的吗\t174\n发掘有序多选结构的价值\t175\nNFA、DFA和POSIX\t177\n最左最长规则\t177\nPOSIX和最左最长规则\t178\n速度和效率\t179\n小结：NFA与DFA的比较\t180\n总结\t183\n第5章：正则表达式实用技巧\t185\n正则表达式的平衡法则\t186\n若干简单的例子\t186\n匹配连续行（续前）\t186\n匹配IP地址\t187\n处理文件名\t190\n匹配对称的括号\t193\n防备不期望的匹配\t194\n匹配分隔符之内的文本\t196\n了解数据，做出假设\t198\n去除文本首尾的空白字符\t199\nHTML相关范例\t200\n匹配HTML Tag\t200\n匹配HTML Link\t201\n检查HTTP URL\t203\n验证主机名\t203\n在真实世界中提取URL\t206\n扩展的例子\t208\n保持数据的协调性\t209\n解析CSV文件\t213\n第6章：打造高效正则表达式\t221\n典型示例\t222\n稍加修改——先迈最好使的腿\t223\n效率vs准确性\t223\n继续前进——限制匹配优先的作用范围\t225\n实测\t226\n全面考察回溯\t228\nPOSIX NFA需要更多处理\t229\n无法匹配时必须进行的工作\t230\n看清楚一点\t231\n多选结构的代价很高\t231\n性能测试\t232\n理解测量对象\t234\nPHP测试\t234\nJava测试\t235\nVB.NET测试\t237\nRuby测试\t238\nPython测试\t238\nTcl测试\t239\n常见优化措施\t240\n有得必有失\t240\n优化各有不同\t241\n正则表达式的应用原理\t241\n应用之前的优化措施\t242\n通过传动装置进行优化\t246\n优化正则表达式本身\t247\n提高表达式速度的诀窍\t252\n常识性优化\t254\n将文字文本独立出来\t255\n将锚点独立出来\t256\n忽略优先还是匹配优先？具体情况具体分析\t256\n拆分正则表达式\t257\n模拟开头字符识别\t258\n使用固化分组和占有优先量词\t259\n主导引擎的匹配\t260\n消除循环\t261\n方法1：依据经验构建正则表达式\t262\n真正的“消除循环”解法\t264\n方法2：自顶向下的视角\t266\n方法3：匹配主机名\t267\n观察\t268\n使用固化分组和占有优先量词\t268\n简单的消除循环的例子\t270\n消除C语言注释匹配的循环\t272\n流畅运转的表达式\t277\n引导匹配的工具\t277\n引导良好的正则表达式速度很快\t279\n完工\t281\n总结：开动你的大脑\t281\n第7章：Perl\t283\n作为语言组件的正则表达式\t285\nPerl的长处\t286\nPerl的短处\t286\nPerl的正则流派\t286\n正则运算符和正则文字\t288\n正则文字的解析方式\t292\n正则修饰符\t292\n正则表达式相关的Perl教义\t293\n表达式应用场合\t294\n动态作用域及正则匹配效应\t295\n匹配修改的特殊变量\t299\nqr/…/运算符与regex对象\t303\n构建和使用regex对象\t303\n探究regex对象\t305\n用regex对象提高效率\t306\nMatch运算符\t306\nMatch的正则运算元\t307\n指定目标运算元\t308\nMatch运算符的不同用途\t309\n迭代匹配：Scalar Context，使用/g\t312\nMatch运算符与环境的关系\t316\nSubstitution运算符\t318\n运算元replacement\t319\n/e修饰符\t319\n应用场合与返回值\t321\nSplit运算符\t321\nSplit基础知识\t322\n返回空元素\t324\nSplit中的特殊Regex运算元\t325\nSplit中带捕获型括号的match运算元\t326\n巧用Perl的专有特性\t326\n用动态正则表达式结构匹配嵌套结构\t328\n使用内嵌代码结构\t331\n在内嵌代码结构中使用local函数\t335\n关于内嵌代码和my变量的忠告\t338\n使用内嵌代码匹配嵌套结构\t340\n正则文字重载\t341\n正则文字重载的问题\t344\n模拟命名捕获\t344\n效率\t347\n办法不只一种\t348\n表达式编译、/o修饰符、qr/???/和效率\t348\n理解“原文”副本\t355\nStudy函数\t359\n性能测试\t360\n正则表达式调试信息\t361\n结语\t363\n第8章：Java\t365\nJava的正则流派\t366\nJava对\\p{…}和\\P{…}的支持\t369\nUnicode行终结符\t370\n使用java.util.regex\t371\nThe Pattern.compile() Factory\t372\nPattern的matcher方法\t373\nMatcher对象\t373\n应用正则表达式\t375\n查询匹配结果\t376\n简单查找-替换\t378\n高级查找-替换\t380\n原地查找-替换\t382\nMatcher的检索范围\t384\n方法链\t389\n构建扫描程序\t389\nMatcher的其他方法\t392\nPattern的其他方法\t394\nPattern的split方法，单个参数\t395\nPattern的split方法，两个参数\t396\n拓展示例\t397\n为Image Tag添加宽度和高度属性\t397\n对于每个Matcher，使用多个Pattern校验HTML\t399\n解析CSV文档\t401\nJava版本差异\t401\n1.4.2和1.5.0之间的差异\t402\n1.5.0和1.6之间的差异\t403\n第9章：.NET\t405\n.NET的正则流派\t406\n对于流派的补充\t409\n使用.NET正则表达式\t413\n正则表达式快速入门\t413\n包概览\t415\n核心对象概览\t416\n核心对象详解\t418\n创建Regex对象\t419\n使用Regex对象\t421\n使用Match对象\t427\n使用Group对象\t430\n静态“便捷”函数\t431\n正则表达式缓存\t432\n支持函数\t432\n.NET高级话题\t434\n正则表达式装配件\t434\n匹配嵌套结构\t436\nCapture对象\t437\n第10章：PHP\t439\nPHP的正则流派\t441\nPreg函数接口\t443\n“Pattern”参数\t444\nPreg函数罗列\t449\npreg_match\t449\npreg_match_all\t453\npreg_replace\t458\npreg_replace_callback\t463\npreg_split\t465\npreg_grep\t469\npreg_quote\t470\n“缺失”的preg函数\t471\npreg_regex_to_pattern\t472\n对未知的Pattern参数进行语法检查\t474\n对未知正则表达式进行语法检查\t475\n递归的正则表达式\t475\n匹配嵌套括号内的文本\t475\n不能回溯到递归调用之内\t477\n匹配一组嵌套的括号\t478\n效率\t478\n模式修饰符S：“研究”\t478\n扩展示例\t480\n用PHP解析CSV\t480\n检查tagged data的嵌套正确性\t481\n索引\t485",
        "pages": "515",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s11292040.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s11292040.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s11292040.jpg"
        },
        "alt": "https://book.douban.com/subject/11589967/",
        "id": "11589967",
        "publisher": "电子工业出版社",
        "isbn10": "7121175010",
        "isbn13": "9787121175015",
        "title": "精通正则表达式-第三版",
        "url": "https://api.douban.com/v2/book/11589967",
        "alt_title": "",
        "author_intro": "",
        "summary": "《精通正则表达式(第3版)》内容简介：随着互联网的迅速发展，几乎所有工具软件和程序语言都支持的正则表达式也变得越来越强大和易于使用。《精通正则表达式(第3版)》是讲解正则表达式的经典之作。《精通正则表达式(第3版)》主要讲解了正则表达式的特性和流派、匹配原理、优化原则、实用诀窍以及调校措施，并详细介绍了正则表达式在Perl、Java、.NET、PHP中的用法。《精通正则表达式(第3版)》自第1版开始着力于教会读者“以正则表达式来思考”，来让读者真正“精通”正则表达式。该版对PHP的相关内容、Javal.5和Javal.6的新特性作了可观的扩充讲解。任何有机会仲用正则表达式的读者都会从中获益匪浅。",
        "price": "89.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "72a0697dbe81f33d997610ac6163926dc572243ce9106582a74245471e7b6fe8",
        "file": "精通正则表达式-第三版.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 340,
          "average": "9.2",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[日]户根勤"
        ],
        "pubdate": "2017-1-1",
        "tags": [
          {
            "count": 346,
            "name": "计算机网络",
            "title": "计算机网络"
          },
          {
            "count": 249,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 214,
            "name": "网络",
            "title": "网络"
          },
          {
            "count": 131,
            "name": "科普",
            "title": "科普"
          },
          {
            "count": 109,
            "name": "互联网",
            "title": "互联网"
          },
          {
            "count": 95,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 95,
            "name": "网络编程",
            "title": "网络编程"
          },
          {
            "count": 69,
            "name": "web",
            "title": "web"
          }
        ],
        "origin_title": "ネットワークはなぜつながるのか 第2版",
        "image": "https://img1.doubanio.com/view/subject/m/public/s29370067.jpg",
        "binding": "平装",
        "translator": [
          "周自恒"
        ],
        "catalog": "第1章　浏览器生成消息　　1\n——探索浏览器内部\n1.1 生成HTTP请求消息　　5\n1.1.1 探索之旅从输入网址开始　　5\n1.1.2 浏览器先要解析URL　　7\n1.1.3 省略文件名的情况　　9\n1.1.4 HTTP的基本思路　　10\n1.1.5 生成HTTP请求消息　　14\n1.1.6 发送请求后会收到响应　　20\n1.2 向DNS服务器查询Web服务器的IP地址　　24\n1.2.1 IP地址的基本知识　　24\n1.2.2 域名和IP地址并用的理由　　28\n1.2.3 Socket库提供查询IP地址的功能　　30\n1.2.4 通过解析器向DNS服务器发出查询　　31\n1.2.5 解析器的内部原理　　32\n1.3 全世界DNS服务器的大接力　　35\n1.3.1 DNS服务器的基本工作　　35\n1.3.2 域名的层次结构　　38\n1.3.3 寻找相应的DNS服务器并获取IP地址　　40\n1.3.4 通过缓存加快DNS服务器的响应　　44\n1.4 委托协议栈发送消息　　45\n1.4.1 数据收发操作概览　　45\n1.4.2 创建套接字阶段　　48\n1.4.3 连接阶段：把管道接上去　　50\n1.4.4 通信阶段：传递消息　　52\n1.4.5 断开阶段：收发数据结束　　53\n怪杰Resolver　　55\n第2章　用电信号传输TCP/IP数据　　57\n——探索协议栈和网卡\n2.1 创建套接字　　61\n2.1.1　协议栈的内部结构　　61\n2.1.2 套接字的实体就是通信控制信息　　63\n2.1.3 调用socket时的操作　　66\n2.2 连接服务器　　68\n2.2.1 连接是什么意思　　68\n2.2.2 负责保存控制信息的头部　　70\n2.2.3 连接操作的实际过程　　73\n2.3 收发数据　　75\n2.3.1 将HTTP请求消息交给协议栈　　75\n2.3.2 对较大的数据进行拆分　　78\n2.3.3 使用ACK号确认网络包已收到　　79\n2.3.4 根据网络包平均往返时间调整ACK号等待时间　　83\n2.3.5 使用窗口有效管理ACK号　　84\n2.3.6 ACK与窗口的合并　　87\n2.3.7 接收HTTP响应消息　　89\n2.4 从服务器断开并删除套接字　　90\n2.4.1 数据发送完毕后断开连接　　90\n2.4.2 删除套接字　　92\n2.4.3 数据收发操作小结　　93\n2.5 IP与以太网的包收发操作　　95\n2.5.1 包的基本知识　　95\n2.5.2 包收发操作概览　　99\n2.5.3 生成包含接收方IP地址的IP头部　　102\n2.5.4 生成以太网用的MAC头部　　106\n2.5.5 通过ARP查询目标路由器的MAC地址　　108\n2.5.6 以太网的基本知识　　111\n2.5.7 将IP包转换成电或光信号发送出去　　114\n2.5.8 给网络包再加3个控制数据　　116\n2.5.9 向集线器发送网络包　　120\n2.5.10 接收返回包　　123\n2.5.11 将服务器的响应包从IP传递给TCP　　125\n2.6 UDP协议的收发操作　　128\n2.6.1 不需要重发的数据用UDP发送更高效　　128\n2.6.2 控制用的短数据　　129\n2.6.3 音频和视频数据　　130\n插进Socket里的是灯泡还是程序　　132\n第3章　从网线到网络设备　　135\n——探索集线器、交换机和路由器\n3.1 信号在网线和集线器中传输　　139\n3.1.1 每个包都是独立传输的　　139\n3.1.2 防止网线中的信号衰减很重要　　140\n3.1.3 “双绞”是为了抑制噪声　　141\n3.1.4 集线器将信号发往所有线路　　146\n3.2 交换机的包转发操作　　149\n3.2.1 交换机根据地址表进行转发　　149\n3.2.2 MAC地址表的维护　　153\n3.2.3 特殊操作　　154\n3.2.4 全双工模式可以同时进行发送和接收　　155\n3.2.5 自动协商：确定最优的传输速率　　156\n3.2.6 交换机可同时执行多个转发操作　　159\n3.3 路由器的包转发操作　　159\n3.3.1 路由器的基本知识　　159\n3.3.2 路由表中的信息　　162\n3.3.3 路由器的包接收操作　　166\n3.3.4 查询路由表确定输出端口　　166\n3.3.5 找不到匹配路由时选择默认路由　　168\n3.3.6 包的有效期　　169\n3.3.7 通过分片功能拆分大网络包　　170\n3.3.8 路由器的发送操作和计算机相同　　172\n3.3.9 路由器与交换机的关系　　173\n3.4 路由器的附加功能　　176\n3.4.1 通过地址转换有效利用IP地址　　176\n3.4.2 地址转换的基本原理　　178\n3.4.3 改写端口号的原因　　180\n3.4.4 从互联网访问公司内网　　181\n3.4.5 路由器的包过滤功能　　182\n集线器和路由器，换个名字身价翻倍？　　184\n第4章　通过接入网进入互联网内部　　187\n——探索接入网和网络运营商\n4.1 ADSL接入网的结构和工作方式　　191\n4.1.1 互联网的基本结构和家庭、公司网络是相同的　　191\n4.1.2 连接用户与互联网的接入网　　192\n4.1.3 ADSL Modem将包拆分成信元　　193\n4.1.4 ADSL将信元“调制”成信号　　197\n4.1.5 ADSL通过使用多个波来提高速率　　200\n4.1.6 分离器的作用　　201\n4.1.7 从用户到电话局　　203\n4.1.8 噪声的干扰　　204\n4.1.9 通过DSLAM到达BAS　　205\n4.2 光纤接入网（FTTH）　　206\n4.2.1 光纤的基本知识　　206\n4.2.2 单模与多模　　208\n4.2.3 通过光纤分路来降低成本　　213\n4.3 接入网中使用的PPP和隧道　　217\n4.3.1 用户认证和配置下发　　217\n4.3.2 在以太网上传输PPP消息　　219\n4.3.3 通过隧道将网络包发送给运营商　　223\n4.3.4 接入网的整体工作过程　　225\n4.3.5 不分配IP地址的无编号端口　　228\n4.3.6 互联网接入路由器将私有地址转换成公有地址　　228\n4.3.7 除PPPoE之外的其他方式　　230\n4.4 网络运营商的内部　　233\n4.4.1 POP和NOC　　233\n4.4.2 室外通信线路的连接　　236\n4.5 跨越运营商的网络包　　238\n4.5.1 运营商之间的连接　　238\n4.5.2 运营商之间的路由信息交换　　239\n4.5.3 与公司网络中自动更新路由表机制的区别　　241\n4.5.4 IX的必要性　　242\n4.5.5 运营商如何通过IX互相连接　　243\n名字叫服务器，其实是路由器　　246\n第5章　服务器端的局域网中有什么玄机　　249\n5.1 Web服务器的部署地点　　253\n5.1.1 在公司里部署Web服务器　　253\n5.1.2 将Web服务器部署在数据中心　　255\n5.2 防火墙的结构和原理　　256\n5.2.1 主流的包过滤方式　　256\n5.2.2 如何设置包过滤的规则　　256\n5.2.3 通过端口号限定应用程序　　260\n5.2.4 通过控制位判断连接方向　　260\n5.2.5 从公司内网访问公开区域的规则　　262\n5.2.6 从外部无法访问公司内网　　262\n5.2.7 通过防火墙　　263\n5.2.8 防火墙无法抵御的攻击　　264\n5.3 通过将请求平均分配给多台服务器来平衡负载　　265\n5.3.1 性能不足时需要负载均衡　　265\n5.3.2 使用负载均衡器分配访问　　266\n5.4 使用缓存服务器分担负载　　270\n5.4.1 如何使用缓存服务器　　270\n5.4.2 缓存服务器通过更新时间管理内容　　271\n5.4.3 最原始的代理——正向代理　　276\n5.4.4 正向代理的改良版——反向代理　　278\n5.4.5 透明代理　　279\n5.5 内容分发服务　　280\n5.5.1 利用内容分发服务分担负载　　280\n5.5.2 如何找到最近的缓存服务器　　282\n5.5.3 通过重定向服务器分配访问目标　　285\n5.5.4 缓存的更新方法会影响性能　　287\n当通信线路变成局域网　　291\n第6章　请求到达Web服务器，响应返回浏览器　　293\n——短短几秒的“漫长旅程”迎来终点\n6.1 服务器概览　　297\n6.1.1 客户端与服务器的区别　　297\n6.1.2 服务器程序的结构　　297\n6.1.3 服务器端的套接字和端口号　　299\n6.2 服务器的接收操作　　305\n6.2.1 网卡将接收到的信号转换成数字信息　　305\n6.2.2 IP模块的接收操作　　308\n6.2.3 TCP模块如何处理连接包　　309\n6.2.4 TCP模块如何处理数据包　　311\n6.2.5 TCP模块的断开操作　　312\n6.3 Web服务器程序解释请求消息并作出响应　　313\n6.3.1 将请求的URI转换为实际的文件名　　313\n6.3.2 运行CGI程序　　316\n6.3.3 Web服务器的访问控制　　319\n6.3.4 返回响应消息　　323\n6.4 浏览器接收响应消息并显示内容　　323\n6.4.1 通过响应的数据类型判断其中的内容　　323\n6.4.2 浏览器显示网页内容！访问完成！　　326\nGateway是通往异世界的入口　　328\n附录　　330\n后记　　334\n致谢　　334\n作者简介　　335",
        "pages": "336",
        "images": {
          "small": "https://img1.doubanio.com/view/subject/s/public/s29370067.jpg",
          "large": "https://img1.doubanio.com/view/subject/l/public/s29370067.jpg",
          "medium": "https://img1.doubanio.com/view/subject/m/public/s29370067.jpg"
        },
        "alt": "https://book.douban.com/subject/26941639/",
        "id": "26941639",
        "publisher": "人民邮电出版社",
        "isbn10": "7115441243",
        "isbn13": "9787115441249",
        "title": "网络是怎样连接的",
        "url": "https://api.douban.com/v2/book/26941639",
        "alt_title": "ネットワークはなぜつながるのか 第2版",
        "author_intro": "作者简介：\n户根勤\n早先从事软件开发，后进入网络行业。曾供职于日本网络设备厂商（外资企业）和国内网络集成商，从事产品开发和技术咨询等工作。在工作之余还进行演讲、写作等活动。1998年离开公司，开始以演讲、写作以及运营论坛为主业。\n译者简介：\n周自恒\n资深技术图书译者、全栈程序员、自然科学爱好者。初中时曾获得信息学奥赛天津赛区一等奖，曾任某管理咨询公司战略技术总监。译有《图解CIO工作指南（第4版）》《大数据的冲击》《代码的未来》《30天自制操作系统》《图解密码技术》《家用游戏机简史》《有趣的二进制》等。",
        "summary": "本书以探索之旅的形式，从在浏览器中输入网址开始，一路追踪了到显示出网页内容为止的整个过程，以图配文，讲解了网络的全貌，并重点介绍了实际的网络设备和软件是如何工作的。目的是帮助读者理解网络的本质意义，理解实际的设备和软件，进而熟练运用网络技术。同时，专设了“网络术语其实很简单”专栏，以对话的形式介绍了一些网络术语的词源，颇为生动有趣。\n本书图文并茂，通俗易懂，非常适合计算机、网络爱好者及相关从业人员阅读。",
        "series": {
          "id": "660",
          "title": "图灵程序设计丛书"
        },
        "price": "CNY 49.00",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "c25171cb2f9b9c31dff9424af28f856263491a471a65a98ed3f266bca71f8272",
        "file": "网络是怎样连接的.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 17,
          "average": "7.6",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[日] 青木峰郎"
        ],
        "pubdate": "2016-6",
        "tags": [
          {
            "count": 55,
            "name": "编译原理",
            "title": "编译原理"
          },
          {
            "count": 28,
            "name": "编译器",
            "title": "编译器"
          },
          {
            "count": 25,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 22,
            "name": "编译",
            "title": "编译"
          },
          {
            "count": 17,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 14,
            "name": "自制系列",
            "title": "自制系列"
          },
          {
            "count": 8,
            "name": "compiler",
            "title": "compiler"
          },
          {
            "count": 5,
            "name": "计算机科学",
            "title": "计算机科学"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s28768045.jpg",
        "binding": "平装",
        "translator": [
          "严圣逸",
          "绝云"
        ],
        "catalog": "目　录\n第1章　开始制作编译器　　1\n1.1　本书的概要　　2\n本书的主题　　2\n本书制作的编译器　　 2\n编译示例　　2\n可执行文件　　3\n编译　　4\n程序运行环境　　6\n1.2　编译过程　　8\n编译的4 个阶段　　8\n语法分析　　8\n语义分析　　9\n生成中间代码　　9\n代码生成　　10\n优化　　10\n总结　　10\n1.3　使用CЬ编译器进行编译　　11\nCЬ编译器的必要环境　　11\n安装CЬ编译器　　11\nCЬ的Hello, World!　　12\n第2章　CЬ和cbc　　13\n2.1　CЬ语言的概要　　14\nCЬ的Hello, World ！　　14\nCЬ中删减的功能　　 14\nimport 关键字　　15\n导入文件的规范　　16\n2.2　CЬ编译器cbc 的构成　　17\ncbc 的代码树　　17\ncbc 的包　　18\ncompiler 包中的类群　　18\nmain 函数的实现　　 19\ncommandMain 函数的实现　　19\nJava5 泛型　　20\nbuild 函数的实现　　 20\nJava 5 的foreach 语句　　21\ncompile 函数的实现　　21\n第1部分　代码分析\n第3章　语法分析的概要　　24\n3.1　语法分析的方法　　25\n代码分析中的问题点　　25\n代码分析的一般规律　　25\n词法分析、语法分析、语义分析　　25\n扫描器的动作　　26\n单词的种类和语义值　　27\ntoken　　28\n抽象语法树和节点　　29\n3.2　解析器生成器　　30\n什么是解析器生成器　　30\n解析器生成器的种类　　30\n解析器生成器的选择　　31\n3.3　JavaCC 的概要　　33\n什么是JavaCC　　33\n语法描述文件　　33\n语法描述文件的例子　　34\n运行JavaCC　　35\n启动JavaCC 所生成的解析器　　36\n中文的处理　　37\n第4章　词法分析　　39\n4.1　基于JavaCC 的扫描器的描述　　40\n本章的目的　　40\nJavaCC 的正则表达式　　40\n固定字符串　　41\n连接　　41\n字符组　　41\n排除型字符组　　41\n重复1 次或多次　　42\n重复0 次或多次　　42\n重复n 次到m 次　　 42\n正好重复n 次　　43\n可以省略　　43\n选择　　43\n4.2　扫描没有结构的单词　　44\nTOKEN 命令　　44\n扫描标识符和保留字　　44\n选择匹配规则　　45\n扫描数值　　46\n4.3　扫描不生成token 的单词　　48\nSKIP 命令和SPECIAL_TOKEN 命令　　48\n跳过空白符　　48\n跳过行注释　　49\n4.4 扫描具有结构的单词　　50\n最长匹配原则和它的问题　　50\n基于状态迁移的扫描　　50\nMORE 命令　　51\n跳过块注释　　52\n扫描字符串字面量　　53\n扫描字符字面量　　53\n第5章　基于JavaCC 的解析器的描述　　55\n5.1　基于EBNF 语法的描述　　56\n本章的目的　　56\n基于JavaCC 的语法描述　　56\n终端符和非终端符　　57\nJavaCC 的EBNF 表示法　　58\n连接　　58\n重复0 次或多次　　59\n重复1 次或多次　　59\n选择　　60\n可以省略　　60\n5.2　语法的二义性和token 的超前扫描　　61\n语法的二义性　　61\nJavaCC 的局限性　　62\n提取左侧共通部分　　63\ntoken 的超前扫描　　63\n可以省略的规则和冲突　　64\n重复和冲突　　65\n更灵活的超前扫描　　66\n超前扫描的相关注意事项　　66\n第6章　语法分析　　68\n6.1　定义的分析　　69\n表示程序整体的符号　　69\n语法的单位　　69\nimport 声明的语法　　70\n各类定义的语法　　71\n变量定义的语法　　72\n函数定义的语法　　73\n结构体定义和联合体定义的语法　　74\n结构体成员和联合体成员的语法　　75\ntypedef 语句的语法　　76\n类型的语法　　76\nC 语言和CЬ在变量定义上的区别　　77\n基本类型的语法　　77\n6.2　语句的分析　　79\n语句的语法　　79\nif 语句的语法　　80\n省略if 语句和大括号　　80\nwhile 语句的语法　　81\nfor 语句的语法　　81\n各类跳转语句的语法　　82\n6.3　表达式的分析　　83\n表达式的整体结构　　83\nexpr 的规则　　83\n条件表达式　　84\n二元运算符　　85\n6.4　项的分析　　88\n项的规则　　88\n前置运算符的规则　　88\n后置运算符的规则　　89\n字面量的规则　　89\n第2部分　抽象语法树和中间代码\n第7章　JavaCC 的action 和抽象语法树　　92\n7.1　JavaCC 的action　　93\n本章的目的　　93\n简单的action　　93\n执行action 的时间点　　93\n返回语义值的action　　95\n获取终端符号的语义值　　95\nToken 类的属性　　96\n获取非终端符号的语义值　　98\n语法树的结构　　99\n选择和action　　99\n重复和action　　100\n本节总结　　102\n7.2　抽象语法树和节点　　103\nNode 类群　　103\nNode 类的定义　　105\n抽象语法树的表示　　105\n基于节点表示表达式的例子　　107\n第8章　抽象语法树的生成　　110\n8.1　表达式的抽象语法树　　111\n字面量的抽象语法树　　111\n类型的表示　　112\n为什么需要TypeRef 类　　113\n一元运算的抽象语法树　　114\n二元运算的抽象语法树　　116\n条件表达式的抽象语法树　　117\n赋值表达式的抽象语法树　　118\n8.2　语句的抽象语法树　　121\nif 语句的抽象语法树　　121\nwhile 语句的抽象语法树　　122\n程序块的抽象语法树　　123\n8.3　声明的抽象语法树　　125\n变量声明列表的抽象语法树　　125\n函数定义的抽象语法树　　126\n表示声明列表的抽象语法树　　127\n表示程序整体的抽象语法树　　128\n外部符号的import　　128\n总结　　129\n8.4　cbc 的解析器的启动　　132\nParser 对象的生成　　132\n文件的解析　　133\n解析器的启动　　134\n第9章　语义分析（1）引用的消解　　135\n9.1　语义分析的概要　　136\n本章目的　　136\n抽象语法树的遍历　　137\n不使用Visitor 模式的抽象语法树的处理　　137\n基于Visitor 模式的抽象语法树的处理　　138\nVistor 模式的一般化　　140\ncbc 中Visitor 模式的实现　　141\n语义分析相关的cbc 的类　　142\n9.2　变量引用的消解　　144\n问题概要　　144\n实现的概要　　144\nScope 树的结构　　145\nLocalResolver 类的属性　　146\nLocalResolver 类的启动　　146\n变量定义的添加　　147\n函数定义的处理　　148\npushScope 方法　　149\ncurrentScope 方法　　149\npopScope 方法　　150\n添加临时作用域　　150\n建立VariableNode 和变量定义的关联　　151\n从作用域树取得变量定义　　151\n9.3　类型名称的消解　　153\n问题概要　　153\n实现的概要　　153\nTypeResolver 类的属性　　153\nTypeResolver 类的启动　　154\n类型的声明　　154\n类型和抽象语法树的遍历　　155\n变量定义的类型消解　　156\n函数定义的类型消解　　157\n第10章　语义分析（2）静态类型检查　　159\n10.1　类型定义的检查　　160\n问题概要　　160\n实现的概要　　161\n检测有向图中的闭环的算法　　162\n结构体、联合体的循环定义检查　　163\n10.2　表达式的有效性检查　　165\n问题概要　　165\n实现的概要　　165\nDereferenceChecker 类的启动　　166\nSemanticError 异常的捕获　　167\n非指针类型取值操作的检查　　167\n获取非左值表达式地址的检查　　168\n隐式的指针生成　　169\n10.3　静态类型检查　　170\n问题概要　　170\n实现的概要　　170\nCЬ中操作数的类型　　171\n隐式类型转换　　172\nTyperChecker 类的启动　　173\n二元运算符的类型检查　　174\n隐式类型转换的实现　　175\n第11章　中间代码的转换　　178\n11.1　cbc 的中间代码　　179\n组成中间代码的类　　180\n中间代码节点类的属性　　181\n中间代码的运算符和类型　　182\n各类中间代码　　183\n中间代码的意义　　184\n11.2　IRGenerator 类的概要　　185\n抽象语法树的遍历和返回值　　185\nIRGenerator 类的启动　　185\n函数本体的转换　　186\n作为语句的表达式的判别　　187\n11.3　流程控制语句的转换　　189\nif 语句的转换（1）概要　　189\nif 语句的转换（2）没有else 部分的情况　　190\nif 语句的转换（3）存在else 部分的情况　　191\nwhile 语句的转换　　191\nbreak 语句的转换（1）问题的定义　　192\nbreak 语句的转换（2）实现的方针　　193\nbreak 语句的转换（3）实现　　194\n11.4　没有副作用的表达式的转换　　196\nUnaryOpNode 对象的转换　　196\nBinaryOpNode 对象的转换　　197\n指针加减运算的转换　　198\n11.5　左值的转换　　200\n左边和右边　　200\n左值和右值　　200\ncbc 中左值的表现　　201\n结构体成员的偏移　　202\n成员引用（expr.memb）的转换　　203\n左值转换的例外：数组和函数　　204\n成员引用的表达式（ptr->memb）的转换　　205\n11.6　存在副作用的表达式的转换　　206\n表达式的副作用　　206\n有副作用的表达式的转换方针　　206\n简单赋值表达式的转换（1）语句　　207\n临时变量的引入　　208\n简单赋值表达式的转换（2）表达式　　209\n后置自增的转换　　210\n第3部分　汇编代码\n第12章　x86 架构的概要　　214\n12.1　计算机的系统结构　　215\nCPU 和存储器　　215\n寄存器　　215\n地址　　216\n物理地址和虚拟地址　　216\n各类设备　　217\n缓存　　218\n12.2　x86 系列CPU 的历史　　220\nx86 系列CPU　　220\n32 位CPU　　220\n指令集　　221\nIA-32 的变迁　　222\nIA-32 的64 位扩展——AMD64　　222\n12.3　IA-32 的概要　　224\nIA-32 的寄存器　　224\n通用寄存器　　225\n机器栈　　226\n机器栈的操作　　227\n机器栈的用途　　227\n栈帧　　228\n指令指针　　229\n标志寄存器　　229\n12.4　数据的表现形式和格式　　231\n无符号整数的表现形式　　231\n有符号整数的表现形式　　231\n负整数的表现形式和二进制补码　　232\n字节序　　233\n对齐　　233\n结构体的表现形式　　234\n第13章　x86 汇编器编程　　236\n13.1　基于GNU 汇编器的编程　　237\nGNU 汇编器　　237\n汇编语言的Hello, World!　　237\n基于GNU 汇编器的汇编代码　　238\n13.2　GNU 汇编器的语法　　240\n汇编版的Hello, World!　　240\n指令　　241\n汇编伪操作　　241\n标签　　241\n注释　　242\n助记符后缀　　242\n各种各样的操作数　　243\n间接内存引用　　244\nx86 指令集的概要　　245\n13.3　传输指令　　246\nmov 指令　　246\npush 指令和pop 指令　　247\nlea 指令　　248\nmovsx 指令和movzx 指令　　249\n符号扩展和零扩展　　250\n13.4　算术运算指令　　251\nadd 指令　　251\n进位标志　　252\nsub 指令　　252\nimul 指令　　252\nidiv 指令和div 指令　　253\ninc 指令　　254\ndec 指令　　255\nneg 指令　　255\n13.5　位运算指令　　256\nand 指令　　256\nor 指令　　257\nxor 指令　　257\nnot 指令　　257\nsal 指令　　258\nsar 指令　　258\nshr 指令　　259\n13.6　流程的控制　　260\njmp 指令　　260\n条件跳转指令（jz、jnz、je、jne、……）　　261\ncmp 指令　　262\ntest 指令　　263\n标志位获取指令（SETcc）　　263\ncall 指令　　264\nret 指令　　265\n第14章　函数和变量　　266\n14.1　程序调用约定　　267\n什么是程序调用约定　　267\nLinux/x86 下的程序调用约定　　267\n14.2　Linux/x86 下的函数调用　　269\n到函数调用完成为止　　269\n到函数开始执行为止　　270\n到返回原处理流程为止　　271\n到清理操作完成为止　　271\n函数调用总结　　272\n14.3　Linux/x86 下函数调用的细节　　274\n寄存器的保存和复原　　274\ncaller-save 寄存器和callee-save 寄存器　　274\ncaller-save 寄存器和callee-save 寄存器的灵活应用　　275\n大数值和浮点数的返回方法　　276\n其他平台的程序调用约定　　277\n第15章　编译表达式和语句　　278\n15.1　确认编译结果　　279\n利用cbc 进行确认的方法　　279\n利用gcc 进行确认的方法　　280\n15.2　x86 汇编的对象与DSL　　282\n表示汇编的类　　282\n表示汇编对象　　283\n15.3　cbc 的x86 汇编DSL　　285\n利用DSL 生成汇编对象　　285\n表示寄存器　　286\n表示立即数和内存引用　　287\n表示指令　　287\n表示汇编伪操作、标签和注释　　288\n15.4　CodeGenerator 类的概要　　290\nCodeGenerator 类的字段　　290\nCodeGenerator 类的处理概述　　290\n实现compileStmts 方法　　291\ncbc 的编译策略　　 292\n15.5　编译单纯的表达式　　294\n编译Int 节点　　294\n编译Str 节点　　294\n编译Uni 节点(1) 按位取反　　295\n编译Uni 节点(2) 逻辑非　　297\n15.6　编译二元运算　　298\n编译Bin 节点　　298\n实现compileBinaryOp 方法　　299\n实现除法和余数　　300\n实现比较运算　　300\n15.7　引用变量和赋值　　301\n编译Var 节点　　301\n编译Addr 节点　　302\n编译Mem 节点　　 303\n编译Assign 节点　　303\n15.8　编译jump 语句　　305\n编译LabelStmt 节点　　305\n编译Jump 节点　　305\n编译CJump 节点　　305\n编译Call 节点　　306\n编译Return 节点　　307\n第16章　分配栈帧　　308\n16.1　操作栈　　309\ncbc 中的栈帧　　309\n栈指针操作原则　　310\n函数体编译顺序　　310\n16.2　参数和局部变量的内存分配　　312\n本节概述　　312\n参数的内存分配　　312\n局部变量的内存分配：原则　　313\n局部变量的内存分配　　314\n处理作用域内的局部变量　　315\n对齐的计算　　316\n子作用域变量的内存分配　　316\n16.3　利用虚拟栈分配临时变量　　318\n虚拟栈的作用　　318\n虚拟栈的接口　　319\n虚拟栈的结构　　319\nvirtualPush 方法的实现　　320\nVirtualStack#extend 方法的实现　　320\nVirtualStack#top 方法的实现　　321\nvirtualPop 方法的实现　　321\nVirtualStack#rewind 方法的实现　　321\n虚拟栈的运作　　322\n16.4　调整栈访问的偏移量　　323\n本节概要　　323\nStackFrameInfo 类　　323\n计算正在使用的callee-save 寄存器　　324\n计算临时变量区域的大小　　325\n调整局部变量的偏移量　　325\n调整临时变量的偏移量　　326\n16.5　生成函数序言和尾声　　327\n本节概要　　327\n生成函数序言　　327\n生成函数尾声　　328\n16.6　alloca 函数的实现　　330\n什么是alloca 函数　　330\n实现原则　　330\nalloca 函数的影响　　331\nalloca 函数的实现　　331\n第17章　优化的方法 333\n17.1　什么是优化　　334\n各种各样的优化　　334\n优化的案例　　334\n常量折叠　　334\n代数简化　　335\n降低运算强度　　335\n削除共同子表达式　　335\n消除无效语句　　336\n函数内联　　336\n17.2　优化的分类　　337\n基于方法的优化分类　　337\n基于作用范围的优化分类　　337\n基于作用阶段的优化分类　　338\n17.3　cbc 中的优化　　339\ncbc 中的优化原则　　339\ncbc 中实现的优化　　339\ncbc 中优化的实现　　339\n17.4　更深层的优化　　341\n基于模式匹配选择指令　　341\n分配寄存器　　342\n控制流分析　　342\n大规模的数据流分析和SSA 形式　　342\n总结　　343\n第4部分　链接和加载\n第18章　生成目标文件 346\n18.1　ELF 文件的结构　　347\nELF 的目的　　347\nELF 的节和段　　348\n目标文件的主要ELF 节　　348\n使用readelf 命令输出节头　　349\n使用readelf 命令输出程序头　　350\n使用readelf 命令输出符号表　　351\nreadelf 命令的选项　　351\n什么是DWARF 格式　　352\n18.2　全局变量及其在ELF 文件中的表示　　354\n分配给任意ELF 节　　354\n分配给通用ELF 节　　354\n分配.bss 节　　355\n通用符号　　355\n记录全局变量对应的符号　　357\n记录符号的附加信息　　357\n记录通用符号的附加信息　　358\n总结　　358\n18.3　编译全局变量　　360\ngenerate 方法的实现　　360\ngenerateAssemblyCode 方法的实现　　360\n编译全局变量　　361\n编译立即数　　362\n编译通用符号　　363\n编译字符串字面量　　364\n生成函数头　　365\n计算函数的代码大小　　366\n总结　　366\n18.4　生成目标文件　　367\nas 命令调用的概要　　367\n引用GNUAssembler 类　　367\n调用as 命令　　367\n第19章　链接和库　　369\n19.1　链接的概要　　370\n链接的执行示例　　370\ngcc 和GNU ld　　371\n链接器处理的文件　　372\n常用库　　374\n链接器的输入和输出　　374\n19.2　什么是链接　　375\n链接时进行的处理　　375\n合并节　　375\n重定位　　376\n符号消解　　377\n19.3　动态链接和静态链接　　379\n两种链接方法　　379\n动态链接的优点　　379\n动态链接的缺点　　380\n动态链接示例　　380\n静态链接示例　　381\n库的检索规则　　381\n19.4　生成库　　383\n生成静态库　　383\nLinux 中共享库的管理　　383\n生成共享库　　384\n链接生成的共享库　　385\n第20章　加载程序　　387\n20.1 加载ELF 段　　388\n利用mmap 系统调用进行文件映射　　388\n进程的内存镜像　　389\n内存空间的属性　　390\nELF 段对应的内存空间　　390\n和ELF 文件不对应的内存空间　　392\nELF 文件加载的实现　　393\n20.2　动态链接过程　　395\n动态链接加载器　　395\n程序从启动到终止的过程　　395\n启动ld.so　　396\n系统内核传递的信息　　397\nAUX 矢量　　397\n读入共享库　　398\n符号消解和重定位　　399\n运行初始化代码　　400\n执行主程序　　401\n执行终止处理　　402\nld.so 解析的环境变量　　402\n20.3　动态加载　　404\n所谓动态加载　　404\nLinux 下的动态加载　　404\n动态加载的架构　　405\n20.4　GNU ld 的链接　　406\n用于cbc 的ld 选项的结构　　406\nC 运行时　　407\n生成可执行文件　　408\n生成共享库　　408\n第21章　生成地址无关代码　　410\n21.1　地址无关代码　　411\n什么是地址无关代码　　411\n全局偏移表（GOT）　　412\n获取GOT 地址　　412\n使用GOT 地址访问全局变量　　413\n访问使用GOT 地址的文件内部的全局变量　　414\n过程链接表（PLT）　　414\n调用PLT 入口　　416\n地址无关的可执行文件：PIE　　416\n21.2　全局变量引用的实现　　418\n获取GOT 地址　　418\nPICThunk 函数的实现　　418\n删除重复函数并设置不可见属性　　419\n加载GOT 地址　　420\nlocateSymbols 函数的实现　　421\n全局变量的引用　　421\n访问全局变量：地址无关代码的情况下　　 422\n函数的符号　　423\n字符串常量的引用　　424\n21.3　链接器调用的实现　　425\n生成可执行文件　　425\ngenerateSharedLibrary 方法　　426\n21.4　从程序解析到执行　　428\nbuild 和加载的过程　　428\n词法分析　　429\n语法分析　　429\n生成中间代码　　430\n生成代码　　431\n汇编　　432\n生成共享库　　432\n生成可执行文件　　433\n加载　　433\n第22章　扩展阅读　　434\n22.1 参考书推荐　　435\n编译器相关　　435\n语法分析相关　　435\n汇编语言相关　　436\n22.2 链接、加载相关　　437\n22.3 各种编程语言的功能　　438\n异常封装相关的图书　　438\n垃圾回收　　438\n垃圾回收相关的图书　　439\n面向对象编程语言的实现　　439\n函数式语言　　440\n附　　录　　441\nA.1 参考文献　　442\nA.2 在线资料　　444\nA.3 源代码　　445",
        "pages": "472",
        "images": {
          "small": "https://img3.doubanio.com/spic/s28768045.jpg",
          "large": "https://img3.doubanio.com/lpic/s28768045.jpg",
          "medium": "https://img3.doubanio.com/mpic/s28768045.jpg"
        },
        "alt": "https://book.douban.com/subject/26806041/",
        "id": "26806041",
        "publisher": "人民邮电出版社",
        "isbn10": "7115422184",
        "isbn13": "9787115422187",
        "title": "自制编译器",
        "url": "https://api.douban.com/v2/book/26806041",
        "alt_title": "",
        "author_intro": "作者简介：\n青木峰郎\n程序员，著有《Ruby程序设计268技（第2版）》《Ruby源代码完全解说》《Linux程序设计》等多部编程相关著作。并积极参与标准库维护、文档维护等各种各样的活动。\n译者简介：\n严圣逸\n毕业于上海交通大学。8年软件开发经验，期间赴日本工作。现就职于想能信息科技（上海）有限公司，从事基于云平台的客户关系管理及各类营销自动化系统的开发工作。译有《高效团队开发：工具与方法》。\n\n绝云\n毕业于清华大学软件学院。曾在日本创意公司KAYAC从事即时通讯软件及社交游戏的开发工作，现任蚂蚁金服前端架构专家。译有《图解简单算法》等图书，曾参与《像外行一样思考，像专家一样实践（修订版）》的审校。",
        "summary": "本书将带领读者从头开始制作一门语言的编译器。笔者特意为本书设计了CЬ语言，CЬ可以说是C语言的子集，实现了包括指针运算等在内的C语言的主要部分。本书所实现的编译器就是C Ь语言的编译器， 是实实在在的编译器，而非有诸多限制的玩具。另外，除编译器之外，本书对以编译器为中心的编程语言的运行环境，即编译器、汇编器、链接器、硬件、运行时环境等都有所提及，介绍了程序运行的所有环节。",
        "series": {
          "id": "34137",
          "title": "自制系列"
        },
        "price": "99.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "d66d7f8982411628163d95ee978ad9166849e16072b67995309406c6cbcbba41",
        "file": "自制编译器.pdf"
      }
    ]
  },
  {
    "dir_name": "python",
    "name": "Python",
    "books": [
      {
        "creator": "Latex With Hyperref Package",
        "producer": "Xdvipdfmx (0.7.8)",
        "creation_date": "D:20160401103437+08'00'",
        "meta_type": "pdf",
        "type": "pdf",
        "sha_256": "682209267f55b840d75a7fb74da74e93bfb0ac4e800f96ad88370d524f160105",
        "file": "Python-Cookbook第三版中文v2.0.0.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 61,
          "average": "9.0",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "David M. Beazley",
          "Brian K. Jones"
        ],
        "pubdate": "2015-5-1",
        "tags": [
          {
            "count": 128,
            "name": "Python",
            "title": "Python"
          },
          {
            "count": 45,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 29,
            "name": "python",
            "title": "python"
          },
          {
            "count": 25,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 22,
            "name": "cookbook",
            "title": "cookbook"
          },
          {
            "count": 17,
            "name": "O'Reilly",
            "title": "O'Reilly"
          },
          {
            "count": 9,
            "name": "代码",
            "title": "代码"
          },
          {
            "count": 7,
            "name": "技术",
            "title": "技术"
          }
        ],
        "origin_title": "Python Cookbook, 3rd Edtioni",
        "image": "https://img3.doubanio.com/mpic/s28259942.jpg",
        "binding": "平装",
        "translator": [
          "陈舸"
        ],
        "catalog": "目录\n第1章 数据结构和算法 1\n1.1 将序列分解为单独的变量 1\n1.2 从任意长度的可迭代对象中分解元素 3\n1.3 保存最后N个元素 5\n1.4 找到最大或最小的N个元素 7\n1.5 实现优先级队列 9\n1.6 在字典中将键映射到多个值上 11\n1.7 让字典保持有序 13\n1.8 与字典有关的计算问题 14\n1.9 在两个字典中寻找相同点 15\n1.10 从序列中移除重复项且保持元素间顺序不变 17\n1.11 对切片命名 18\n1.12 找出序列中出现次数最多的元素 20\n1.13 通过公共键对字典列表排序 22\n1.14 对不原生支持比较操作的对象排序 23\n1.15 根据字段将记录分组 25\n1.16 筛选序列中的元素 26\n1.17 从字典中提取子集 29\n1.18 将名称映射到序列的元素中 30\n1.19 同时对数据做转换和换算 33\n1.20 将多个映射合并为单个映射 34\n第2章 字符串和文本 37\n2.1 针对任意多的分隔符拆分字符串 37\n2.2 在字符串的开头或结尾处做文本匹配 38\n2.3 利用Shell通配符做字符串匹配 40\n2.4 文本模式的匹配和查找 42\n2.5 查找和替换文本 45\n2.6 以不区分大小写的方式对文本做查找和替换 47\n2.7 定义实现最短匹配的正则表达式 48\n2.8 编写多行模式的正则表达式 49\n2.9 将Unicode文本统一表示为规范形式 50\n2.10 用正则表达式处理Unicode字符 52\n2.11 从字符串中去掉不需要的字符 53\n2.12 文本过滤和清理 54\n2.13 对齐文本字符串 57\n2.14 字符串连接及合并 59\n2.15 给字符串中的变量名做插值处理 62\n2.16 以固定的列数重新格式化文本 64\n2.17 在文本中处理HTML和XML实体 66\n2.18 文本分词 67\n2.19 编写一个简单的递归下降解析器 70\n2.20 在字节串上执行文本操作 80\n第3章 数字、日期和时间 83\n3.1 对数值进行取整 83\n3.2 执行精确的小数计算 85\n3.3 对数值做格式化输出 87\n3.4 同二进制、八进制和十六进制数打交道 89\n3.5 从字节串中打包和解包大整数 90\n3.6 复数运算 92\n3.7 处理无穷大和NaN 94\n3.8 分数的计算 96\n3.9 处理大型数组的计算 97\n3.10 矩阵和线性代数的计算 101\n3.11 随机选择 103\n3.12 时间换算 105\n3.13 计算上周5的日期 107\n3.14 找出当月的日期范围 108\n3.15 将字符串转换为日期 110\n3.16 处理涉及到时区的日期问题 112\n第4章 迭代器和生成器 114\n4.1 手动访问迭代器中的元素 114\n4.2 委托迭代 115\n4.3 用生成器创建新的迭代模式 116\n4.4 实现迭代协议 118\n4.5 反向迭代 121\n4.6 定义带有额外状态的生成器函数 122\n4.7 对迭代器做切片操作 123\n4.8 跳过可迭代对象中的前一部分元素 124\n4.9 迭代所有可能的组合或排列 127\n4.10 以索引-值对的形式迭代序列 129\n4.11 同时迭代多个序列 131\n4.12 在不同的容器中进行迭代 133\n4.13 创建处理数据的管道 134\n4.14 扁平化处理嵌套型的序列 137\n4.15 合并多个有序序列，再对整个有序序列进行迭代 139\n4.16 用迭代器取代while循环 140\n第5章 文件和I/O 142\n5.1 读写文本数据 142\n5.2 将输出重定向到文件中 145\n5.3 以不同的分隔符或行结尾符完成打印 145\n5.4 读写二进制数据 146\n5.5 对已不存在的文件执行写入操作 149\n5.6 在字符串上执行I/O操作 150\n5.7 读写压缩的数据文件 151\n5.8 对固定大小的记录进行迭代 152\n5.9 将二进制数据读取到可变缓冲区中 153\n5.10 对二进制文件做内存映射 155\n5.11 处理路径名 157\n5.12 检测文件是否存在 158\n5.13 获取目录内容的列表 159\n5.14 绕过文件名编码 161\n5.15 打印无法解码的文件名 162\n5.16 为已经打开的文件添加或修改编码方式 164\n5.17 将字节数据写入文本文件 166\n5.18 将已有的文件描述符包装为文件对象 167\n5.19 创建临时文件和目录 169\n5.20 同串口进行通信 171\n5.21 序列化Python对象 172\n第6章 数据编码与处理 177\n6.1 读写CSV数据 177\n6.2 读写JSON数据 181\n6.3 解析简单的XML文档 186\n6.4 以增量方式解析大型XML文件 188\n6.5 将字典转换为XML 192\n6.6 解析、修改和重写XML 194\n6.7 用命名空间来解析XML文档 196\n6.8 同关系型数据库进行交互 198\n6.9 编码和解码十六进制数字 201\n6.10 Base64编码和解码 202\n6.11 读写二进制结构的数组 203\n6.12 读取嵌套型和大小可变的二进制结构 207\n6.13 数据汇总和统计 218\n第7章 函数 221\n7.1 编写可接受任意数量参数的函数 221\n7.2 编写只接受关键字参数的函数 223\n7.3 将元数据信息附加到函数参数上 224\n7.4 从函数中返回多个值 225\n7.5 定义带有默认参数的函数 226\n7.6 定义匿名或内联函数 229\n7.7 在匿名函数中绑定变量的值 230\n7.8 让带有N个参数的可调用对象以较少的参数形式调用 232\n7.9 用函数替代只有单个方法的类 235\n7.10 在回调函数中携带额外的状态 236\n7.11 内联回调函数 240\n7.12 访问定义在闭包内的变量 242\n第8章 类与对象 246\n8.1 修改实例的字符串表示 246\n8.2 自定义字符串的输出格式 248\n8.3 让对象支持上下文管理协议 249\n8.4 当创建大量实例时如何节省内存 251\n8.5 将名称封装到类中 252\n8.6 创建可管理的属性 254\n8.7 调用父类中的方法 259\n8.8 在子类中扩展属性 263\n8.9 创建一种新形式的类属性或实例属性 267\n8.10 让属性具有惰性求值的能力 271\n8.11 简化数据结构的初始化过程 274\n8.12 定义一个接口或抽象基类 278\n8.13 实现一种数据模型或类型系统 281\n8.14 实现自定义的容器 287\n8.15 委托属性的访问 291\n8.16 在类中定义多个构造函数 296\n8.17 不通过调用init来创建实例 298\n8.18 用Mixin技术来扩展类定义 299\n8.19 实现带有状态的对象或状态机 305\n8.20 调用对象上的方法，方法名以字符串形式给出 311\n8.21 实现访问者模式 312\n8.22 实现非递归的访问者模式 317\n8.23 在环状数据结构中管理内存 324\n8.24 让类支持比较操作 327\n8.25 创建缓存实例 330\n第9章 元编程 335\n9.1 给函数添加一个包装 335\n9.2 编写装饰器时如何保存函数的元数据 337\n9.3 对装饰器进行解包装 339\n9.4 定义一个可接受参数的装饰器 341\n9.5 定义一个属性可由用户修改的装饰器 342\n9.6 定义一个能接收可选参数的装饰器 346\n9.7 利用装饰器对函数参数强制执行类型检查 348\n9.8 在类中定义装饰器 352\n9.9 把装饰器定义成类 354\n9.10 把装饰器作用到类和静态方法上 357\n9.11 编写装饰器为被包装的函数添加参数 359\n9.12 利用装饰器给类定义打补丁 362\n9.13 利用元类来控制实例的创建 364\n9.14 获取类属性的定义顺序 367\n9.15 定义一个能接受可选参数的元类 370\n9.16 在*args和**kwargs上强制规定一种参数签名 372\n9.17 在类中强制规定编码约定 375\n9.18 通过编程的方式来定义类 378\n9.19 在定义的时候初始化类成员 382\n9.20 通过函数注解来实现方法重载 384\n9.21 避免出现重复的属性方法 391\n9.22 以简单的方式定义上下文管理器 393\n9.23 执行带有局部副作用的代码 395\n9.24 解析并分析Python源代码 398\n9.25 将Python源码分解为字节码 402\n第10章 模块和包 406\n10.1 把模块按层次结构组织成包 406\n10.2 对所有符号的导入进行精确控制 407\n10.3 用相对名称来导入包中的子模块 408\n10.4 将模块分解成多个文件 410\n10.5 让各个目录下的代码在统一的命名空间下导入 413\n10.6 重新加载模块 415\n10.7 让目录或zip文件成为可运行的脚本 416\n10.8 读取包中的数据文件 417\n10.9 添加目录到sys.path中 418\n10.10 使用字符串中给定的名称来导入模块 420\n10.11 利用import钩子从远端机器上加载模块 421\n10.12 在模块加载时为其打补丁 439\n10.13 安装只为自己所用的包 441\n10.14 创建新的Python环境 442\n10.15 发布自定义的包 444\n第11章 网络和Web编程 446\n11.1 以客户端的形式同HTTP服务交互 446\n11.2 创建一个TCP服务器 450\n11.3 创建一个UDP服务器 454\n11.4 从CIDR地址中生成IP地址的范围 456\n11.5 创建基于REST风格的简单接口 458\n11.6 利用XML-RPC实现简单的远端过程调用 463\n11.7 在不同的解释器间进行通信 466\n11.8 实现远端过程调用 468\n11.9 以简单的方式验证客户端身份 472\n11.10 为网络服务增加SSL支持 474\n11.11 在进程间传递socket文件描述符 481\n11.12 理解事件驱动型I/O 486\n11.13 发送和接收大型数组 493\n第12章 并发 496\n12.1 启动和停止线程 496\n12.2 判断线程是否已经启动 499\n12.3 线程间通信 503\n12.4 对临界区加锁 508\n12.5 避免死锁 511\n12.6 保存线程专有状态 515\n12.7 创建线程池 517\n12.8 实现简单的并行编程 521\n12.9 如何规避GIL带来的限制 525\n12.10 定义一个Actor任务 528\n12.11 实现发布者/订阅者消息模式 532\n12.12 使用生成器作为线程的替代方案 536\n12.13 轮询多个线程队列 544\n12.14 在UNIX上加载守护进程 547\n第13章 实用脚本和系统管理 552\n13.1 通过重定向、管道或输入文件来作为脚本的输入 552\n13.2 终止程序并显示错误信息 553\n13.3 解析命令行选项 554\n13.4 在运行时提供密码输入提示 557\n13.5 获取终端大小 558\n13.6 执行外部命令并获取输出 558\n13.7 拷贝或移动文件和目录 560\n13.8 创建和解包归档文件 562\n13.9 通过名称来查找文件 563\n13.10 读取配置文件 565\n13.11 给脚本添加日志记录 568\n13.12 给库添加日志记录 571\n13.13 创建一个秒表计时器 573\n13.14 给内存和CPU使用量设定限制 575\n13.15 加载Web浏览器 576\n第14章 测试、调试以及异常 578\n14.1 测试发送到stdout上的输出 578\n14.2 在单元测试中为对象打补丁 579\n14.3 在单元测试中检测异常情况 583\n14.4 将测试结果作为日志记录到文件中 585\n14.5 跳过测试，或者预计测试结果为失败 586\n14.6 处理多个异常 587\n14.7 捕获所有的异常 589\n14.8 创建自定义的异常 591\n14.9 通过引发异常来响应另一个异常 593\n14.10 重新抛出上一个异常 595\n14.11 发出告警信息 596\n14.12 对基本的程序崩溃问题进行调试 598\n14.13 对程序做性能分析以及计时统计 600\n14.14 让你的程序运行得更快 603\n第15章 C语言扩展 610\n15.1 利用ctypes来访问C代码 612\n15.2 编写简单的C语言扩展模块 618\n15.3 编写一个可操作数组的扩展函数 622\n15.4 在C扩展模块中管理不透明指针 625\n15.5 在扩展模块中定义并导出C API 628\n15.6 从C中调用Python 633\n15.7 在C扩展模块中释放GIL 639\n15.8 混合使用C和Python环境中的线程 639\n15.9 用Swig来包装C代码 640\n15.10 用Cython来包装C代码 646\n15.11 用Cython来高效操作数组 652\n15.12 把函数指针转换为可调用对象 657\n15.13 把以NULL结尾的字符串传给C库 659\n15.14 把Unicode字符串传递给C库 663\n15.15 把C字符串转换到Python中 667\n15.16 同编码方式不确定的C字符串打交道 669\n15.17 把文件名传给C扩展模块 672\n15.18 把打开的文件传给C扩展模块 673\n15.19 在C中读取文件型对象 674\n15.20 从C中访问可迭代对象 677\n15.21 排查段错误 678\n附录A 补充阅读 680",
        "pages": "684",
        "images": {
          "small": "https://img3.doubanio.com/spic/s28259942.jpg",
          "large": "https://img3.doubanio.com/lpic/s28259942.jpg",
          "medium": "https://img3.doubanio.com/mpic/s28259942.jpg"
        },
        "alt": "https://book.douban.com/subject/26381341/",
        "id": "26381341",
        "publisher": "人民邮电出版社",
        "isbn10": "7115379599",
        "isbn13": "9787115379597",
        "title": "Python Cookbook 中文版，第 3 版",
        "url": "https://api.douban.com/v2/book/26381341",
        "alt_title": "Python Cookbook, 3rd Edtioni",
        "author_intro": "David Beazley是一位居住在芝加哥的独立软件开发者以及图书作者。他主要的工作在于编程工具，提供定制化的软件开发服务，以及为软件开发者、科学家和工程师教授编程实践课程。他最为人熟知的工作在于Python编程语言，他已为此创建了好几个开源的软件包（例如Swig和PLY），并且是备受赞誉的图书Python Essential Reference的作者。他也对C、C++以及汇编语言下的系统编程有着丰富的经验。\nBrain K. Jones是普林斯顿大学计算机系的一位系统管理员。",
        "summary": "《Python Cookbook（第3版）中文版》介绍了Python应用在各个领域中的一些使用技巧和方法，其主题涵盖了数据结构和算法，字符串和文本，数字、日期和时间，迭代器和生成器，文件和I/O，数据编码与处理，函数，类与对象，元编程，模块和包，网络和Web编程，并发，实用脚本和系统管理，测试、调试以及异常，C语言扩展等。\n本书覆盖了Python应用中的很多常见问题，并提出了通用的解决方案。书中包含了大量实用的编程技巧和示例代码，并在Python 3.3环境下进行了测试，可以很方便地应用到实际项目中去。此外，《Python Cookbook（第3版）中文版》还详细讲解了解决方案是如何工作的，以及为什么能够工作。\n《Python Cookbook（第3版）中文版》非常适合具有一定编程基础的Python程序员阅读参考。",
        "price": "108.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "8a36c8b3b5845186bff6652bf237bd99409cfae3ff76889e516178b45c5558ed",
        "file": "Python_Cookbook-第三版 Jones.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 1412,
          "average": "7.7",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[美]Wesley J. Chun（陳仲才）"
        ],
        "pubdate": "2008-06",
        "tags": [
          {
            "count": 1414,
            "name": "Python",
            "title": "Python"
          },
          {
            "count": 649,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 287,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 268,
            "name": "程序语言",
            "title": "程序语言"
          },
          {
            "count": 206,
            "name": "python",
            "title": "python"
          },
          {
            "count": 191,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 174,
            "name": "programming",
            "title": "programming"
          },
          {
            "count": 113,
            "name": "开发",
            "title": "开发"
          }
        ],
        "origin_title": "Core Python Programming, 2nd Edition",
        "image": "https://img3.doubanio.com/mpic/s3140466.jpg",
        "binding": "平装",
        "translator": [
          "CPUG"
        ],
        "catalog": "第1部分　Python核心\n第1章　欢迎来到Python世界\n1.1　什么是Python\n1.2　起源\n1.3　特点\n1.3.1　高级\n1.3.2　面向对象\n1.3.3　可升级\n1.3.4　可扩展\n1.3.5　可移植性\n1.3.6　易学\n1.3.7　易读\n1.3.8　易维护\n1.3.9　健壮性\n1.3.10　高效的快速原型开发工具\n1.3.11　内存管理器\n1.3.12　解释性和（字节）编译性\n1.4　下载和安装Python\n1.5　运行Python\n1.5.1　命令行上的交互式解释器\n1.5.2　从命令行启动脚本\n1.5.3　集成开发环境\n1.5.4　其他的集成开发环境和执行环境\n1.6　Python文档\n1.7　比较Python（Python与其他语言的比较）\n1.8　其他实现\n1.9　练习\n第2章　快速入门\n2.1　程序输出，print语句及“Hello World!”\n2.2　程序输入和raw_input（）内建函数\n2.3　注释\n2.4　操作符\n2.5　变量和赋值\n2.6　数字\n2.7　字符串\n2.8　列表和元组\n2.9　字典\n2.10　代码块及缩进对齐\n2.11　if语句\n2.12　while循环\n2.13　for循环和range（）内建函数\n2.14　列表解析\n2.15　文件和内建函数open（）、file（）\n2.16　错误和异常\n2.17　函数\n2.17.1　如何定义函数\n2.17.2　如何调用函数\n2.17.3　默认参数\n2.18　类\n2.19　模块\n2.19.1　如何导入模块\n2.19.2　如何访问一个模块函数或访问一个模块变量\n2.20　实用的函数\n2.21　练习\n第3章　Python基础\n3.1　语句和语法\n3.1.1　注释（#）\n3.1.2　继续（\\）\n3.1.3　多个语句构成代码组（:）\n3.1.4　代码组由不同的缩进分隔\n3.1.5　同一行书写多个语句（;）\n3.1.6　模块\n3.2　变量赋值\n3.2.1　赋值操作符\n3.2.2　增量赋值\n3.2.3　多重赋值\n3.2.4　“多元”赋值\n3.3　标识符\n3.3.1　合法的Python标识符\n3.3.2　关键字\n3.3.3　内建\n3.3.4　专用下划线标识符\n3.4　基本风格指南\n3.4.1　模块结构和布局\n3.4.2　在主程序中书写测试代码\n3.5　内存管理\n3.5.1　变量定义\n3.5.2　动态类型\n3.5.3　内存分配\n3.5.4　引用计数\n3.5.5　垃圾收集\n3.6　第一个Python程序\n3.7　相关模块和开发工具\n3.8　练习\n第4章　Python对象\n4.1　Python 对象\n4.2　标准类型\n4.3　其他内建类型\n4.3.1　类型对象和type类型对象\n4.3.2　None--Python的Null对象\n4.4　内部类型\n4.4.1　代码对象\n4.4.2　帧对象\n4.4.3　跟踪记录对象\n4.4.4　切片对象\n4.4.5　省略对象\n4.4.6　XRange 对象\n4.5　标准类型操作符\n4.5.1　对象值的比较\n4.5.2　对象身份比较\n4.5.3　布尔类型\n4.6　标准类型内建函数\n4.6.1　type（）\n4.6.2　cmp（）\n4.6.3　str（）和repr（）（及``操作符）\n4.6.4　type（）和isinstance（）\n4.6.5　Python类型操作符和内建函数总结\n4.7　类型工厂函数\n4.8　标准类型的分类\n4.8.1　存储模型\n4.8.2　更新模型\n4.8.3　访问模型\n4.9　不支持的类型\n4.10　练习\n第5章　数字\n5.1　数字简介\n5.1.1　如何创建数值对象并用其赋值（数字对象）\n5.1.2　如何更新数字对象\n5.1.3　如何删除数字对象\n5.2　整型\n5.2.1　布尔型\n5.2.2　标准整型\n5.2.3　长整型\n5.2.4　整型和长整型的统一\n5.3　双精度浮点型\n5.4　复数\n5.5　操作符\n5.5.1　混合模式操作符\n5.5.2　标准类型操作符\n5.5.3　算术操作符\n5.5.4　*位操作符（只适用于整型）\n5.6　内建函数与工厂函数\n5.6.1　标准类型函数\n5.6.2　数字类型函数\n5.6.3　仅用于整型的函数\n5.7　其他数字类型\n5.7.1　布尔“数”\n5.7.2　十进制浮点型\n5.8　相关模块\n5.9　练习\n第6章　序列：字符串、列表和元组\n6.1　序列\n6.1.1　标准类型操作符\n6.1.2　序列类型操作符\n6.1.3　内建函数（BIF）\n6.2　字符串\n6.3　字符串和操作符\n6.3.1　标准类型操作符\n6.3.2　序列操作符切片（[]和[:]）\n6.4　只适用于字符串的操作符\n6.4.1　格式化操作符（％）\n6.4.2　字符串模板: 更简单的替代品\n6.4.3　原始字符串操作符（r/R）\n6.4.4　Unicode字符串操作符（u/U）\n6.5　内建函数\n6.5.1　标准类型函数\n6.5.2　序列类型函数\n6.5.3　字符串类型函数\n6.6　字符串内建函数\n6.7　字符串的独特特性\n6.7.1　特殊字符串和控制字符\n6.7.2　三引号\n6.7.3　字符串不变性\n6.8　Unicode\n6.8.1　术语\n6.8.2　什么是Unicode\n6.8.3　怎样使用Unicode\n6.8.4　Codec是什么\n6.8.5　编码解码\n6.8.6　把Unicode应用到实际应用中\n6.8.7　从现实中得来的教训\n6.8.8　Python的Unicode支持\n6.9　相关模块\n6.10　字符串关键点总结\n6.11　列表\n6.12　操作符\n6.12.1　标准类型操作符\n6.12.2　序列类型操作符\n6.12.3　列表类型操作符和列表解析\n6.13　内建函数\n6.13.1　标准类型函数\n6.13.2　序列类型函数\n6.13.3　列表类型内建函数\n6.14　列表类型的内建函数\n6.15　列表的特殊特性\n6.16　元组\n6.17　元组操作符和内建函数\n6.17.1　标准类型操作符、序列类型操作符和内建函数\n6.17.2　元组类型操作符和内建函数、内建方法\n6.18　元组的特殊特性\n6.18.1　不可变性给元组带来了什么影响\n6.18.2　元组也不是那么“不可变”\n6.18.3　默认集合类型\n6.18.4　单元素元组\n6.18.5　字典的关键字\n6.19　相关模块\n6.20　*拷贝Python对象、浅拷贝和深拷贝\n6.21　序列类型小结\n6.22　练习\n第7章　映像和集合类型\n7.1　映射类型：字典\n7.1.1　如何创建字典和给字典赋值\n7.1.2　如何访问字典中的值\n7.1.3　如何更新字典\n7.1.4　如何删除字典元素和字典\n7.2　映射类型操作符\n7.2.1　标准类型操作符\n7.2.2　映射类型操作符\n7.3　映射类型的内建函数和工厂函数\n7.3.1　标准类型函数[type（）、str（）和cmp（）]\n7.3.2　映射类型相关的函数\n7.4　映射类型内建方法\n7.5　字典的键\n7.5.1　不允许一个键对应多个值\n7.5.2　键必须是可哈希的\n7.6　集合类型\n7.6.1　如何创建集合类型和给集合赋值\n7.6.2　如何访问集合中的值\n7.6.3　如何更新集合\n7.6.4　如何删除集合中的成员和集合\n7.7　集合类型操作符\n7.7.1　标准类型操作符（所有的集合类型）\n7.7.2　集合类型操作符（所有的集合类型）\n7.7.3　集合类型操作符（仅适用于可变集合）\n7.8　内建函数\n7.8.1　标准类型函数\n7.8.2　集合类型工厂函数\n7.9　集合类型内建方法\n7.9.1　方法（所有的集合方法）\n7.9.2　方法（仅适用于可变集合）\n7.9.3　操作符和内建方法比较\n7.10　集合类型总结表\n7.11　相关模块\n7.12　练习\n第8章　条件和循环\n8.1　if语句\n8.1.1　多重条件表达式\n8.1.2　单一语句的代码块\n8.2　else语句\n8.3　elif（即else-if）语句\n8.4　条件表达式（即“三元操作符”）\n8.5　while语句\n8.5.1　一般语法\n8.5.2　计数循环\n8.5.3　无限循环\n8.6　for语句\n8.6.1　一般语法\n8.6.2　用于序列类型\n8.6.3　用于迭代器类型\n8.6.4　range（）内建函数\n8.6.5　xrange（） 内建函数\n8.6.6　与序列相关的内建函数\n8.7　break语句\n8.8　continue语句\n8.9　pass语句\n8.10　再谈else语句\n8.11　迭代器和iter（）函数\n8.11.1　什么是迭代器\n8.11.2　为什么要迭代器\n8.11.3　如何迭代\n8.11.4　使用迭代器\n8.11.5　可变对象和迭代器\n8.11.6　如何创建迭代器\n8.12　列表解析\n8.13　生成器表达式\n8.14　相关模块\n8.15　练习\n第9章　文件和输入输出\n9.1　文件对象\n9.2　文件内建函数（open（）和file（））\n9.2.1　工厂函数file（）\n9.2.2　通用换行符支持（UNS）\n9.3　文件内建方法\n9.3.1　输入\n9.3.2　输出\n9.3.3　文件内移动\n9.3.4　文件迭代\n9.3.5　其他\n9.3.6　文件方法杂项\n9.4　文件内建属性\n9.5　标准文件\n9.6　命令行参数\n9.7　文件系统\n9.8　文件执行\n9.9　永久存储模块\n9.9.1　pickle和marshal模块\n9.9.2　DBM风格的模块\n9.9.3　shelve模块\n9.10　相关模块\n9.11　练习\n第10章　错误和异常\n10.1　什么是异常\n10.1.1　错误\n10.1.2　异常\n10.2　Python 中的异常\n10.3　检测和处理异常\n10.3.1　try-except语句\n10.3.2　包装内建函数\n10.3.3　带有多个except的try语句\n10.3.4　处理多个异常的except语句\n10.3.5　捕获所有异常\n10.3.6　“异常参数”\n10.3.7　在应用使用我们封装的函数\n10.3.8　else子句\n10.3.9　finally子句\n10.3.10　try-finally语句\n10.3.11　try-except-else-finally：厨房一锅端\n10.4　上下文管理\n10.4.1　with语句\n10.4.2　*上下文管理协议\n10.5　*字符串作为异常\n10.6　触发异常\n10.7　断言\n10.8　标准异常\n10.9　*创建异常\n10.10　（现在）为什么用异常\n10.11　到底为什么要异常\n10.12　异常和sys模块\n10.13　相关模块\n10.14　练习\n第11章　函数和函数式编程\n11.1　什么是函数？\n11.1.1　函数vs过程\n11.1.2　返回值与函数类型\n11.2　调用函数\n11.2.1　函数操作符\n11.2.2　关键字参数\n11.2.3　默认参数\n11.2.4　参数组\n11.3　创建函数\n11.3.1　def语句\n11.3.2　声明与定义比较\n11.3.3　前向引用\n11.3.4　函数属性\n11.3.5　内部/内嵌函数\n11.3.6　*函数（与方法）装饰器\n11.4　传递函数\n11.5　Formal Arguments\n11.5.1　位置参数\n11.5.2　默认参数\n11.6　可变长度的参数\n11.6.1　非关键字可变长参数（元组）\n11.6.2　关键字变量参数（字典）\n11.6.3　调用带有可变长参数对象函数\n11.7　函数式编程\n11.7.1　匿名函数与lambda\n11.7.2　内建函数apply（）、filter（）、map（）、reduce（）\n11.7.3　偏函数应用\n11.8　变量作用域\n11.8.1　全局变量与局部变量\n11.8.2　globa语句\n11.8.3　作用域的数字\n11.8.4　闭包\n11.8.5　作用域和lambda\n11.8.6　变量作用域和名称空间\n11.9　*递归\n11.10　生成器\n11.10.1　简单的生成器特性\n11.10.2　加强的生成器特性\n11.11　练习\n第12章　模块\n12.1　什么是模块\n12.2　模块和文件\n12.2.1　模块名称空间\n12.2.2　搜索路径和路径搜索\n12.3　名称空间\n12.3.1　名称空间与变量作用域比较\n12.3.2　名称查找、确定作用域、覆盖\n12.3.3　无限制的名称空间\n12.4　导入模块\n12.4.1　import语句\n12.4.2　from-import语句\n12.4.3　多行导入\n12.4.4　扩展的import语句（as）\n12.5　模块导入的特性\n12.5.1　载入时执行模块\n12.5.2　导入（import）和加载（load）\n12.5.3　导入到当前名称空间的名称\n12.5.4　被导入到导入者作用域的名字\n12.5.5　关于__future__\n12.5.6　警告框架\n12.5.7　从ZIP文件中导入模块\n12.5.8　“新的”导入钩子\n12.6　模块内建函数\n12.6.1　__import__（）\n12.6.2　globals（）和locals（）\n12.6.3　reload（）\n12.7　包\n12.7.1　目录结构\n12.7.2　使用from-import导入包\n12.8　模块的其他特性\n12.8.1　自动载入的模块\n12.8.2　阻止属性导入\n12.8.3　不区分大小的导入\n12.8.4　源代码编码\n12.8.5　导入循环\n12.8.6　模块执行\n12.9　相关模块\n12.10　练习\n第13章　面向对象编程\n13.1　引言\n13.2　面向对象编程\n13.2.1　面向对象设计与面向对象编程的关系\n13.2.2　现实中的问题\n13.2.3　*常用术语\n13.3　类\n13.3.1　创建类\n13.3.2　声明与定义\n13.4　类属性\n13.4.1　类的数据属性\n13.4.2　Methods\n13.4.3　决定类的属性\n13.4.4　特殊的类属性\n13.5　实例\n13.5.1　初始化：通过调用类对象来创建实例\n13.5.2　__init__（）“构造器”方法\n13.5.3　__new__（）“构造器”方法\n13.5.4　__del__（）“解构器”方法\n13.6　实例属性\n13.6.1　“实例化”实例属性（或创建一个更好的构造器）\n13.6.2　查看实例属性\n13.6.3　特殊的实例属性\n13.6.4　建类型属性\n13.6.5　实例属性vs类属性\n13.7　绑定和方法调用\n13.7.1　调用绑定方法\n13.7.2　调用非绑定方法\n13.8　静态方法和类方法\n13.8.1　staticmethod（）和classmethod（）内建函数\n13.8.2　使用函数修饰符\n13.9　组合\n13.10　子类和派生\n13.11　继承\n13.11.1　__bases__类属性\n13.11.2　通过继承覆盖方法\n13.11.3　从标准类型派生\n13.11.4　多重继承\n13.12　类、实例和其他对象的内建函数\n13.12.1　issubclass（）\n13.12.2　isinstance（）\n13.12.3　hasattr（）、getattr（）、setattr（）、delattr（）\n13.12.4　dir（）\n13.12.5　super（）\n13.12.6　vars（）\n13.13　用特殊方法定制类\n13.13.1　简单定制（RoundFloat2）\n13.13.2　数值定制（Time60）\n13.13.3　迭代器（RandSeq和AnyIter）\n13.13.4　*多类型定制（NumStr）\n13.14　私有化\n13.15　*授权\n13.15.1　包装\n13.15.2　实现授权\n13.16　新式类的高级特性（Python 2.2+）\n13.16.1　新式类的通用特性\n13.16.2　__slots__类属性\n13.16.3　__getattribute__（）特殊方法\n13.16.4　描述符\n13.16.5　元类和__metaclass__\n13.17　相关模块和文档\n13.18　练习\n第14章　执行环境\n14.1　可调用对象\n14.1.1　函数\n14.1.2　方法\n14.1.3　类\n14.1.4　类的实例\n14.2　代码对象\n14.3　可执行的对象声明和内建函数\n14.3.1　callable（）\n14.3.2　compile（）\n14.3.3　eval（）\n14.3.4　exec\n14.3.5　input（）\n14.3.6　使用Python在运行时生成和执行Python代码\n14.4　执行其他（Python）程序\n14.4.1　导入\n14.4.2　execfile（）\n14.4.3　将模块作为脚本执行\n14.5　执行其他（非Python）程序\n14.5.1　os.system（）\n14.5.2　os.popen（）\n14.5.3　os.fork（）、os.exec*（）、os.wait*（）\n14.5.4　os.spawn*（）\n14.5.5　subprocess 模块\n14.5.6　相关函数\n14.6　受限执行\n14.7　结束执行\n14.7.1　sys.exit（） and SystemExit\n14.7.2　sys.exitfunc（）\n14.7.3　os._exit（） 函数\n14.7.4　os.kill（） Function\n14.8　各种操作系统接口\n14.9　相关模块\n14.10　练习\n第2部分　高级主题\n第15章　正则表达式\n15.1　引言/动机\n15.2　正则表达式使用的特殊符号和字符\n15.2.1　用管道符号（|）匹配多个正则表达式模式\n15.2.2　匹配任意一个单个的字符（.）\n15.2.3　从字符串的开头或结尾或单词边界开始匹配（^/$ /\\b /\\B ）\n15.2.4　创建字符类（[]）\n15.2.5　指定范围（-）和否定（^）\n15.2.6　使用闭包操作符（*，+，?，{}）实现多次出现/重复匹配\n15.2.7　特殊字符表示、字符集\n15.2.8　用圆括号（（））组建组\n15.3　正则表达式和Python语言\n15.3.1　re模块：核心函数和方法\n15.3.2　使用compile（）编译正则表达式\n15.3.3　匹配对象和group（）、groups（）方法\n15.3.4　用match（）匹配字符串\n15.3.5　search（）在一个字符串中查找一个模式（搜索与匹配的比较）\n15.3.6　匹配多个字符串（|）\n15.3.7　匹配任意单个字符（.）\n15.3.8　创建字符集合（[]）\n15.3.9　重复、特殊字符和子组\n15.3.10　从字符串的开头或结尾匹配及在单词边界上的匹配\n15.3.11　用findall（）找到每个出现的匹配部分\n15.3.12　用sub（）（和subn（））进行搜索和替换\n15.3.13　用split（）分割（分隔模式）\n15.4　正则表达式示例\n15.4.1　匹配一个字符串\n15.4.2　搜索与匹配的比较，“贪婪”匹配\n15.5　练习\n第16章　网络编程\n16.1　引言\n16.1.1　什么是客户端/服务器架构\n16.1.2　客户端/服务器网络编程\n16.2　套接字：通信端点\n16.2.1　什么是套接字\n16.2.2　套接字地址：主机与端口\n16.2.3　面向连接与无连接\n16.3　Python中的网络编程\n16.3.1　socket（）模块函数\n16.3.2　套接字对象（内建）方法\n16.3.3　创建一个TCP服务器\n16.3.4　创建TCP客户端\n16.3.5　运行我们的客户端与TCP服务器\n16.3.6　创建一个UDP服务器\n16.3.7　创建一个UDP客户端\n16.3.8　执行UDP服务器和客户端\n16.3.9　Socket模块属性\n16.4　*SocketServer模块\n16.4.1　创建一个SocketServerTCP服务器\n16.4.2　创建SocketServerTCP客户端\n16.4.3　执行TCP服务器和客户端\n16.5　Twisted框架介绍\n16.5.1　创建一个Twisted Reactor TCP服务器\n16.5.2　创建一个Twisted Reactor TCP客户端\n16.5.3　执行TCP服务器和客户端\n16.6　相关模块\n16.7　练习\n第17章　网络客户端编程\n17.1　什么是因特网客户端\n17.2　文件传输\n17.2.1　文件传输网际协议\n17.2.2　文件传输协议（FTP）\n17.2.3　Python和FTP\n17.2.4　ftplib.FTP类方法\n17.2.5　交互式FTP示例\n17.2.6　客户端FTP程序举例\n17.2.7　FTP的其他方面\n17.3　网络新闻\n17.3.1　Usenet与新闻组\n17.3.2　网络新闻传输协议（NNTP）\n17.3.3　Python和NNTP\n17.3.4　nntplib.NNTP类方法\n17.3.5　交互式NNTP举例\n17.3.6　客户端程序NNTP举例\n17.3.7　NNTP的其他方面\n17.4　电子邮件\n17.4.1　电子邮件系统组件和协议\n17.4.2　发送电子邮件\n17.4.3　Python和SMTP\n17.4.4　smtplib.SMTP类方法\n17.4.5　交互式SMTP示例\n17.4.6　SMTP的其他方面\n17.4.7　接收电子邮件\n17.4.8　POP和IMAP\n17.4.9　Python和POP3\n17.4.10　交互式POP3举例\n17.4.11　poplib.POP3类方法\n17.4.12　客户端程序SMTP和POP3举例\n17.5　相关模块\n17.5.1　电子邮件\n17.5.2　其他网络协议\n17.6　练习\n第18章　多线程编程\n18.1　引言/动机\n18.2　线程和进程\n18.2.1　什么是进程\n18.2.2　什么是线程\n18.3　Python、线程和全局解释器锁\n18.3.1　全局解释器锁（GIL）\n18.3.2　退出线程\n18.3.3　在Python中使用线程\n18.3.4　没有线程支持的情况\n18.3.5　Python的threading模块\n18.4　thread模块\n18.5　threading模块\n18.5.1　Thread类\n18.5.2　斐波那契、阶乘和累加和\n18.5.3　threading模块中的其他函数\n18.5.4　生产者-消费者问题和Queue模块\n18.6　相关模块\n18.7　练习\n第19章　图形用户界面编程\n19.1　简介\n19.1.1　什么是Tcl、Tk和Tkinter\n19.1.2　安装和使用Tkinter　533\n19.1.3　客户端/服务器架构　534\n19.2　Tkinter与Python编程　534\n19.2.1　Tkinter模块：把Tk引入你的程序\n19.2.2　GUI程序开发简介\n19.2.3　顶层窗口：Tkinter.Tk（）\n19.2.4　Tk组件\n19.3　Tkinter举例\n19.3.1　标签组件\n19.3.2　按钮组件\n19.3.3　标签和按钮组件\n19.3.4　标签、按钮和进度条组件\n19.3.5　偏函数应用举例\n19.3.6　中级Tkinter范例\n19.4　其他GUI简介\n19.4.1　Tk Interface eXtensions （Tix）\n19.4.2　Python MegaWidgets （PMW）\n19.4.3　wxWidgets和wxPython\n19.4.4　GTK+和PyGTK\n19.5　相关模块和其他GUI\n19.6　练习\n第20章　Web编程\n20.1　介绍\n20.1.1　Web应用：客户端/服务器计算\n20.1.2　因特网\n20.2　使用Python进行Web应用：创建一个简单的Web客户端\n20.2.1　统一资源定位符\n20.2.2　urlparse模块\n20.2.3　urllib模块\n20.2.4　urllib2模块\n20.3　高级Web客户端\n20.4　CGI：帮助Web服务器处理客户端数据\n20.4.1　CGI介绍\n20.4.2　CGI应用程序\n20.4.3　cgi模块\n20.5　建立CGI应用程序\n20.5.1　建立Web服务器\n20.5.2　建立表单页\n20.5.3　生成结果页\n20.5.4　生成表单和结果页面\n20.5.5　全面交互的Web站点\n20.6　在CGI中使用Unicode编码\n20.7　高级CGI\n20.7.1　Mulitipart表单提交和文件的上传\n20.7.2　多值字段\n20.7.3　cookie\n20.7.4　使用高级CGI\n20.8　Web（HTTP）服务器\n20.9　相关模块\n20.10　练习\n第21章　数据库编程\n21.1　介绍\n21.1.1　持久存储\n21.1.2　基本的数据库操作和SQL语言\n21.1.3　数据库和Python\n21.2　Python数据库应用程序程序员接口（DB-API）\n21.2.1　模块属性\n21.2.2　连接对象\n21.2.3　游标对象\n21.2.4　类型对象和构造器\n21.2.5　关系数据库\n21.2.6　数据库和Python：接口程序\n21.2.7　使用数据库接口程序举例\n21.3　对象-关系管理器（ORM）\n21.3.1　考虑对象，而不是SQL\n21.3.2　Python和ORM\n21.3.3　雇员数据库举例\n21.3.4　总结\n21.4　相关模块\n21.5　练习\n第22章　扩展Python　623\n22.1　引言/动机\n22.1.1　什么是扩展\n22.1.2　为什么要扩展Python\n22.2　创建Python扩展\n22.2.1　创建您的应用程序代码\n22.2.2　用样板来包装你的代码\n22.2.3　编译\n22.2.4　导入和测试\n22.2.5　引用计数\n22.2.6　线程和全局解释器锁（GIL）\n22.3　相关话题\n22.4　练习\n第23章　其他话题\n23.1　Web服务\n23.2　用Win32的COM来操作微软Office\n23.2.1　客户端COM编程\n23.2.2 微软Excel\n23.2.3　微软Word　第1部分　Python核心\n23.2.4　微软PowerPoint\n23.2.5　微软Outlook\n23.2.6　中等规模的例子\n23.3　用Jython写Python和Java的程序\n23.3.1　什么是Jython\n23.3.2　Swing GUI开发（Java或者Python!）\n23.4　练习\n23.2.4　微软PowerPoint\n23.2.5　微软Outlook\n23.2.6　中等规模的例子\n23.3　用Jython写Python和Java的程序\n23.3.1　什么是Jython\n23.3.2　Swing GUI开发（Java或者Python!）\n23.4　练习",
        "pages": "654",
        "images": {
          "small": "https://img3.doubanio.com/spic/s3140466.jpg",
          "large": "https://img3.doubanio.com/lpic/s3140466.jpg",
          "medium": "https://img3.doubanio.com/mpic/s3140466.jpg"
        },
        "alt": "https://book.douban.com/subject/3112503/",
        "id": "3112503",
        "publisher": "人民邮电出版社",
        "isbn10": "711517850X",
        "isbn13": "9787115178503",
        "title": "Python核心编程（第二版）",
        "url": "https://api.douban.com/v2/book/3112503",
        "alt_title": "Core Python Programming, 2nd Edition",
        "author_intro": "",
        "summary": "本书是Python开发者的完全指南——针对 Python 2.5全面升级\n·学习专业的Python风格、最佳实践和好的编程习惯；\n·加强对Python对象、内存模型和Python面向对象特性的深入理解；\n·构建更有效的Web、CGI、互联网、网络和其他客户端/服务器架构应用程序及软件；\n·学习如何使用Python中的Tkinter和其他工具来开发自己的GUI应用程序及软件；\n·通过用C等语言编写扩展来提升Python应用程序的性能，或者通过使用多线程增强I/0相关的应用程序的能力；\n·学习Python中有关数据库的API，以及如何在Python中使用各种不同的数据库系统，包括MySQL、Postgres和 SQLite。",
        "price": "89.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "b513fe6ab947987b2f77f4a1b3170f564c00c232252d14acc28f97aa4ff51548",
        "file": "Python核心编程.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 1412,
          "average": "7.7",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[美]Wesley J. Chun（陳仲才）"
        ],
        "pubdate": "2008-06",
        "tags": [
          {
            "count": 1414,
            "name": "Python",
            "title": "Python"
          },
          {
            "count": 649,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 287,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 268,
            "name": "程序语言",
            "title": "程序语言"
          },
          {
            "count": 206,
            "name": "python",
            "title": "python"
          },
          {
            "count": 191,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 174,
            "name": "programming",
            "title": "programming"
          },
          {
            "count": 113,
            "name": "开发",
            "title": "开发"
          }
        ],
        "origin_title": "Core Python Programming, 2nd Edition",
        "image": "https://img3.doubanio.com/mpic/s3140466.jpg",
        "binding": "平装",
        "translator": [
          "CPUG"
        ],
        "catalog": "第1部分　Python核心\n第1章　欢迎来到Python世界\n1.1　什么是Python\n1.2　起源\n1.3　特点\n1.3.1　高级\n1.3.2　面向对象\n1.3.3　可升级\n1.3.4　可扩展\n1.3.5　可移植性\n1.3.6　易学\n1.3.7　易读\n1.3.8　易维护\n1.3.9　健壮性\n1.3.10　高效的快速原型开发工具\n1.3.11　内存管理器\n1.3.12　解释性和（字节）编译性\n1.4　下载和安装Python\n1.5　运行Python\n1.5.1　命令行上的交互式解释器\n1.5.2　从命令行启动脚本\n1.5.3　集成开发环境\n1.5.4　其他的集成开发环境和执行环境\n1.6　Python文档\n1.7　比较Python（Python与其他语言的比较）\n1.8　其他实现\n1.9　练习\n第2章　快速入门\n2.1　程序输出，print语句及“Hello World!”\n2.2　程序输入和raw_input（）内建函数\n2.3　注释\n2.4　操作符\n2.5　变量和赋值\n2.6　数字\n2.7　字符串\n2.8　列表和元组\n2.9　字典\n2.10　代码块及缩进对齐\n2.11　if语句\n2.12　while循环\n2.13　for循环和range（）内建函数\n2.14　列表解析\n2.15　文件和内建函数open（）、file（）\n2.16　错误和异常\n2.17　函数\n2.17.1　如何定义函数\n2.17.2　如何调用函数\n2.17.3　默认参数\n2.18　类\n2.19　模块\n2.19.1　如何导入模块\n2.19.2　如何访问一个模块函数或访问一个模块变量\n2.20　实用的函数\n2.21　练习\n第3章　Python基础\n3.1　语句和语法\n3.1.1　注释（#）\n3.1.2　继续（\\）\n3.1.3　多个语句构成代码组（:）\n3.1.4　代码组由不同的缩进分隔\n3.1.5　同一行书写多个语句（;）\n3.1.6　模块\n3.2　变量赋值\n3.2.1　赋值操作符\n3.2.2　增量赋值\n3.2.3　多重赋值\n3.2.4　“多元”赋值\n3.3　标识符\n3.3.1　合法的Python标识符\n3.3.2　关键字\n3.3.3　内建\n3.3.4　专用下划线标识符\n3.4　基本风格指南\n3.4.1　模块结构和布局\n3.4.2　在主程序中书写测试代码\n3.5　内存管理\n3.5.1　变量定义\n3.5.2　动态类型\n3.5.3　内存分配\n3.5.4　引用计数\n3.5.5　垃圾收集\n3.6　第一个Python程序\n3.7　相关模块和开发工具\n3.8　练习\n第4章　Python对象\n4.1　Python 对象\n4.2　标准类型\n4.3　其他内建类型\n4.3.1　类型对象和type类型对象\n4.3.2　None--Python的Null对象\n4.4　内部类型\n4.4.1　代码对象\n4.4.2　帧对象\n4.4.3　跟踪记录对象\n4.4.4　切片对象\n4.4.5　省略对象\n4.4.6　XRange 对象\n4.5　标准类型操作符\n4.5.1　对象值的比较\n4.5.2　对象身份比较\n4.5.3　布尔类型\n4.6　标准类型内建函数\n4.6.1　type（）\n4.6.2　cmp（）\n4.6.3　str（）和repr（）（及``操作符）\n4.6.4　type（）和isinstance（）\n4.6.5　Python类型操作符和内建函数总结\n4.7　类型工厂函数\n4.8　标准类型的分类\n4.8.1　存储模型\n4.8.2　更新模型\n4.8.3　访问模型\n4.9　不支持的类型\n4.10　练习\n第5章　数字\n5.1　数字简介\n5.1.1　如何创建数值对象并用其赋值（数字对象）\n5.1.2　如何更新数字对象\n5.1.3　如何删除数字对象\n5.2　整型\n5.2.1　布尔型\n5.2.2　标准整型\n5.2.3　长整型\n5.2.4　整型和长整型的统一\n5.3　双精度浮点型\n5.4　复数\n5.5　操作符\n5.5.1　混合模式操作符\n5.5.2　标准类型操作符\n5.5.3　算术操作符\n5.5.4　*位操作符（只适用于整型）\n5.6　内建函数与工厂函数\n5.6.1　标准类型函数\n5.6.2　数字类型函数\n5.6.3　仅用于整型的函数\n5.7　其他数字类型\n5.7.1　布尔“数”\n5.7.2　十进制浮点型\n5.8　相关模块\n5.9　练习\n第6章　序列：字符串、列表和元组\n6.1　序列\n6.1.1　标准类型操作符\n6.1.2　序列类型操作符\n6.1.3　内建函数（BIF）\n6.2　字符串\n6.3　字符串和操作符\n6.3.1　标准类型操作符\n6.3.2　序列操作符切片（[]和[:]）\n6.4　只适用于字符串的操作符\n6.4.1　格式化操作符（％）\n6.4.2　字符串模板: 更简单的替代品\n6.4.3　原始字符串操作符（r/R）\n6.4.4　Unicode字符串操作符（u/U）\n6.5　内建函数\n6.5.1　标准类型函数\n6.5.2　序列类型函数\n6.5.3　字符串类型函数\n6.6　字符串内建函数\n6.7　字符串的独特特性\n6.7.1　特殊字符串和控制字符\n6.7.2　三引号\n6.7.3　字符串不变性\n6.8　Unicode\n6.8.1　术语\n6.8.2　什么是Unicode\n6.8.3　怎样使用Unicode\n6.8.4　Codec是什么\n6.8.5　编码解码\n6.8.6　把Unicode应用到实际应用中\n6.8.7　从现实中得来的教训\n6.8.8　Python的Unicode支持\n6.9　相关模块\n6.10　字符串关键点总结\n6.11　列表\n6.12　操作符\n6.12.1　标准类型操作符\n6.12.2　序列类型操作符\n6.12.3　列表类型操作符和列表解析\n6.13　内建函数\n6.13.1　标准类型函数\n6.13.2　序列类型函数\n6.13.3　列表类型内建函数\n6.14　列表类型的内建函数\n6.15　列表的特殊特性\n6.16　元组\n6.17　元组操作符和内建函数\n6.17.1　标准类型操作符、序列类型操作符和内建函数\n6.17.2　元组类型操作符和内建函数、内建方法\n6.18　元组的特殊特性\n6.18.1　不可变性给元组带来了什么影响\n6.18.2　元组也不是那么“不可变”\n6.18.3　默认集合类型\n6.18.4　单元素元组\n6.18.5　字典的关键字\n6.19　相关模块\n6.20　*拷贝Python对象、浅拷贝和深拷贝\n6.21　序列类型小结\n6.22　练习\n第7章　映像和集合类型\n7.1　映射类型：字典\n7.1.1　如何创建字典和给字典赋值\n7.1.2　如何访问字典中的值\n7.1.3　如何更新字典\n7.1.4　如何删除字典元素和字典\n7.2　映射类型操作符\n7.2.1　标准类型操作符\n7.2.2　映射类型操作符\n7.3　映射类型的内建函数和工厂函数\n7.3.1　标准类型函数[type（）、str（）和cmp（）]\n7.3.2　映射类型相关的函数\n7.4　映射类型内建方法\n7.5　字典的键\n7.5.1　不允许一个键对应多个值\n7.5.2　键必须是可哈希的\n7.6　集合类型\n7.6.1　如何创建集合类型和给集合赋值\n7.6.2　如何访问集合中的值\n7.6.3　如何更新集合\n7.6.4　如何删除集合中的成员和集合\n7.7　集合类型操作符\n7.7.1　标准类型操作符（所有的集合类型）\n7.7.2　集合类型操作符（所有的集合类型）\n7.7.3　集合类型操作符（仅适用于可变集合）\n7.8　内建函数\n7.8.1　标准类型函数\n7.8.2　集合类型工厂函数\n7.9　集合类型内建方法\n7.9.1　方法（所有的集合方法）\n7.9.2　方法（仅适用于可变集合）\n7.9.3　操作符和内建方法比较\n7.10　集合类型总结表\n7.11　相关模块\n7.12　练习\n第8章　条件和循环\n8.1　if语句\n8.1.1　多重条件表达式\n8.1.2　单一语句的代码块\n8.2　else语句\n8.3　elif（即else-if）语句\n8.4　条件表达式（即“三元操作符”）\n8.5　while语句\n8.5.1　一般语法\n8.5.2　计数循环\n8.5.3　无限循环\n8.6　for语句\n8.6.1　一般语法\n8.6.2　用于序列类型\n8.6.3　用于迭代器类型\n8.6.4　range（）内建函数\n8.6.5　xrange（） 内建函数\n8.6.6　与序列相关的内建函数\n8.7　break语句\n8.8　continue语句\n8.9　pass语句\n8.10　再谈else语句\n8.11　迭代器和iter（）函数\n8.11.1　什么是迭代器\n8.11.2　为什么要迭代器\n8.11.3　如何迭代\n8.11.4　使用迭代器\n8.11.5　可变对象和迭代器\n8.11.6　如何创建迭代器\n8.12　列表解析\n8.13　生成器表达式\n8.14　相关模块\n8.15　练习\n第9章　文件和输入输出\n9.1　文件对象\n9.2　文件内建函数（open（）和file（））\n9.2.1　工厂函数file（）\n9.2.2　通用换行符支持（UNS）\n9.3　文件内建方法\n9.3.1　输入\n9.3.2　输出\n9.3.3　文件内移动\n9.3.4　文件迭代\n9.3.5　其他\n9.3.6　文件方法杂项\n9.4　文件内建属性\n9.5　标准文件\n9.6　命令行参数\n9.7　文件系统\n9.8　文件执行\n9.9　永久存储模块\n9.9.1　pickle和marshal模块\n9.9.2　DBM风格的模块\n9.9.3　shelve模块\n9.10　相关模块\n9.11　练习\n第10章　错误和异常\n10.1　什么是异常\n10.1.1　错误\n10.1.2　异常\n10.2　Python 中的异常\n10.3　检测和处理异常\n10.3.1　try-except语句\n10.3.2　包装内建函数\n10.3.3　带有多个except的try语句\n10.3.4　处理多个异常的except语句\n10.3.5　捕获所有异常\n10.3.6　“异常参数”\n10.3.7　在应用使用我们封装的函数\n10.3.8　else子句\n10.3.9　finally子句\n10.3.10　try-finally语句\n10.3.11　try-except-else-finally：厨房一锅端\n10.4　上下文管理\n10.4.1　with语句\n10.4.2　*上下文管理协议\n10.5　*字符串作为异常\n10.6　触发异常\n10.7　断言\n10.8　标准异常\n10.9　*创建异常\n10.10　（现在）为什么用异常\n10.11　到底为什么要异常\n10.12　异常和sys模块\n10.13　相关模块\n10.14　练习\n第11章　函数和函数式编程\n11.1　什么是函数？\n11.1.1　函数vs过程\n11.1.2　返回值与函数类型\n11.2　调用函数\n11.2.1　函数操作符\n11.2.2　关键字参数\n11.2.3　默认参数\n11.2.4　参数组\n11.3　创建函数\n11.3.1　def语句\n11.3.2　声明与定义比较\n11.3.3　前向引用\n11.3.4　函数属性\n11.3.5　内部/内嵌函数\n11.3.6　*函数（与方法）装饰器\n11.4　传递函数\n11.5　Formal Arguments\n11.5.1　位置参数\n11.5.2　默认参数\n11.6　可变长度的参数\n11.6.1　非关键字可变长参数（元组）\n11.6.2　关键字变量参数（字典）\n11.6.3　调用带有可变长参数对象函数\n11.7　函数式编程\n11.7.1　匿名函数与lambda\n11.7.2　内建函数apply（）、filter（）、map（）、reduce（）\n11.7.3　偏函数应用\n11.8　变量作用域\n11.8.1　全局变量与局部变量\n11.8.2　globa语句\n11.8.3　作用域的数字\n11.8.4　闭包\n11.8.5　作用域和lambda\n11.8.6　变量作用域和名称空间\n11.9　*递归\n11.10　生成器\n11.10.1　简单的生成器特性\n11.10.2　加强的生成器特性\n11.11　练习\n第12章　模块\n12.1　什么是模块\n12.2　模块和文件\n12.2.1　模块名称空间\n12.2.2　搜索路径和路径搜索\n12.3　名称空间\n12.3.1　名称空间与变量作用域比较\n12.3.2　名称查找、确定作用域、覆盖\n12.3.3　无限制的名称空间\n12.4　导入模块\n12.4.1　import语句\n12.4.2　from-import语句\n12.4.3　多行导入\n12.4.4　扩展的import语句（as）\n12.5　模块导入的特性\n12.5.1　载入时执行模块\n12.5.2　导入（import）和加载（load）\n12.5.3　导入到当前名称空间的名称\n12.5.4　被导入到导入者作用域的名字\n12.5.5　关于__future__\n12.5.6　警告框架\n12.5.7　从ZIP文件中导入模块\n12.5.8　“新的”导入钩子\n12.6　模块内建函数\n12.6.1　__import__（）\n12.6.2　globals（）和locals（）\n12.6.3　reload（）\n12.7　包\n12.7.1　目录结构\n12.7.2　使用from-import导入包\n12.8　模块的其他特性\n12.8.1　自动载入的模块\n12.8.2　阻止属性导入\n12.8.3　不区分大小的导入\n12.8.4　源代码编码\n12.8.5　导入循环\n12.8.6　模块执行\n12.9　相关模块\n12.10　练习\n第13章　面向对象编程\n13.1　引言\n13.2　面向对象编程\n13.2.1　面向对象设计与面向对象编程的关系\n13.2.2　现实中的问题\n13.2.3　*常用术语\n13.3　类\n13.3.1　创建类\n13.3.2　声明与定义\n13.4　类属性\n13.4.1　类的数据属性\n13.4.2　Methods\n13.4.3　决定类的属性\n13.4.4　特殊的类属性\n13.5　实例\n13.5.1　初始化：通过调用类对象来创建实例\n13.5.2　__init__（）“构造器”方法\n13.5.3　__new__（）“构造器”方法\n13.5.4　__del__（）“解构器”方法\n13.6　实例属性\n13.6.1　“实例化”实例属性（或创建一个更好的构造器）\n13.6.2　查看实例属性\n13.6.3　特殊的实例属性\n13.6.4　建类型属性\n13.6.5　实例属性vs类属性\n13.7　绑定和方法调用\n13.7.1　调用绑定方法\n13.7.2　调用非绑定方法\n13.8　静态方法和类方法\n13.8.1　staticmethod（）和classmethod（）内建函数\n13.8.2　使用函数修饰符\n13.9　组合\n13.10　子类和派生\n13.11　继承\n13.11.1　__bases__类属性\n13.11.2　通过继承覆盖方法\n13.11.3　从标准类型派生\n13.11.4　多重继承\n13.12　类、实例和其他对象的内建函数\n13.12.1　issubclass（）\n13.12.2　isinstance（）\n13.12.3　hasattr（）、getattr（）、setattr（）、delattr（）\n13.12.4　dir（）\n13.12.5　super（）\n13.12.6　vars（）\n13.13　用特殊方法定制类\n13.13.1　简单定制（RoundFloat2）\n13.13.2　数值定制（Time60）\n13.13.3　迭代器（RandSeq和AnyIter）\n13.13.4　*多类型定制（NumStr）\n13.14　私有化\n13.15　*授权\n13.15.1　包装\n13.15.2　实现授权\n13.16　新式类的高级特性（Python 2.2+）\n13.16.1　新式类的通用特性\n13.16.2　__slots__类属性\n13.16.3　__getattribute__（）特殊方法\n13.16.4　描述符\n13.16.5　元类和__metaclass__\n13.17　相关模块和文档\n13.18　练习\n第14章　执行环境\n14.1　可调用对象\n14.1.1　函数\n14.1.2　方法\n14.1.3　类\n14.1.4　类的实例\n14.2　代码对象\n14.3　可执行的对象声明和内建函数\n14.3.1　callable（）\n14.3.2　compile（）\n14.3.3　eval（）\n14.3.4　exec\n14.3.5　input（）\n14.3.6　使用Python在运行时生成和执行Python代码\n14.4　执行其他（Python）程序\n14.4.1　导入\n14.4.2　execfile（）\n14.4.3　将模块作为脚本执行\n14.5　执行其他（非Python）程序\n14.5.1　os.system（）\n14.5.2　os.popen（）\n14.5.3　os.fork（）、os.exec*（）、os.wait*（）\n14.5.4　os.spawn*（）\n14.5.5　subprocess 模块\n14.5.6　相关函数\n14.6　受限执行\n14.7　结束执行\n14.7.1　sys.exit（） and SystemExit\n14.7.2　sys.exitfunc（）\n14.7.3　os._exit（） 函数\n14.7.4　os.kill（） Function\n14.8　各种操作系统接口\n14.9　相关模块\n14.10　练习\n第2部分　高级主题\n第15章　正则表达式\n15.1　引言/动机\n15.2　正则表达式使用的特殊符号和字符\n15.2.1　用管道符号（|）匹配多个正则表达式模式\n15.2.2　匹配任意一个单个的字符（.）\n15.2.3　从字符串的开头或结尾或单词边界开始匹配（^/$ /\\b /\\B ）\n15.2.4　创建字符类（[]）\n15.2.5　指定范围（-）和否定（^）\n15.2.6　使用闭包操作符（*，+，?，{}）实现多次出现/重复匹配\n15.2.7　特殊字符表示、字符集\n15.2.8　用圆括号（（））组建组\n15.3　正则表达式和Python语言\n15.3.1　re模块：核心函数和方法\n15.3.2　使用compile（）编译正则表达式\n15.3.3　匹配对象和group（）、groups（）方法\n15.3.4　用match（）匹配字符串\n15.3.5　search（）在一个字符串中查找一个模式（搜索与匹配的比较）\n15.3.6　匹配多个字符串（|）\n15.3.7　匹配任意单个字符（.）\n15.3.8　创建字符集合（[]）\n15.3.9　重复、特殊字符和子组\n15.3.10　从字符串的开头或结尾匹配及在单词边界上的匹配\n15.3.11　用findall（）找到每个出现的匹配部分\n15.3.12　用sub（）（和subn（））进行搜索和替换\n15.3.13　用split（）分割（分隔模式）\n15.4　正则表达式示例\n15.4.1　匹配一个字符串\n15.4.2　搜索与匹配的比较，“贪婪”匹配\n15.5　练习\n第16章　网络编程\n16.1　引言\n16.1.1　什么是客户端/服务器架构\n16.1.2　客户端/服务器网络编程\n16.2　套接字：通信端点\n16.2.1　什么是套接字\n16.2.2　套接字地址：主机与端口\n16.2.3　面向连接与无连接\n16.3　Python中的网络编程\n16.3.1　socket（）模块函数\n16.3.2　套接字对象（内建）方法\n16.3.3　创建一个TCP服务器\n16.3.4　创建TCP客户端\n16.3.5　运行我们的客户端与TCP服务器\n16.3.6　创建一个UDP服务器\n16.3.7　创建一个UDP客户端\n16.3.8　执行UDP服务器和客户端\n16.3.9　Socket模块属性\n16.4　*SocketServer模块\n16.4.1　创建一个SocketServerTCP服务器\n16.4.2　创建SocketServerTCP客户端\n16.4.3　执行TCP服务器和客户端\n16.5　Twisted框架介绍\n16.5.1　创建一个Twisted Reactor TCP服务器\n16.5.2　创建一个Twisted Reactor TCP客户端\n16.5.3　执行TCP服务器和客户端\n16.6　相关模块\n16.7　练习\n第17章　网络客户端编程\n17.1　什么是因特网客户端\n17.2　文件传输\n17.2.1　文件传输网际协议\n17.2.2　文件传输协议（FTP）\n17.2.3　Python和FTP\n17.2.4　ftplib.FTP类方法\n17.2.5　交互式FTP示例\n17.2.6　客户端FTP程序举例\n17.2.7　FTP的其他方面\n17.3　网络新闻\n17.3.1　Usenet与新闻组\n17.3.2　网络新闻传输协议（NNTP）\n17.3.3　Python和NNTP\n17.3.4　nntplib.NNTP类方法\n17.3.5　交互式NNTP举例\n17.3.6　客户端程序NNTP举例\n17.3.7　NNTP的其他方面\n17.4　电子邮件\n17.4.1　电子邮件系统组件和协议\n17.4.2　发送电子邮件\n17.4.3　Python和SMTP\n17.4.4　smtplib.SMTP类方法\n17.4.5　交互式SMTP示例\n17.4.6　SMTP的其他方面\n17.4.7　接收电子邮件\n17.4.8　POP和IMAP\n17.4.9　Python和POP3\n17.4.10　交互式POP3举例\n17.4.11　poplib.POP3类方法\n17.4.12　客户端程序SMTP和POP3举例\n17.5　相关模块\n17.5.1　电子邮件\n17.5.2　其他网络协议\n17.6　练习\n第18章　多线程编程\n18.1　引言/动机\n18.2　线程和进程\n18.2.1　什么是进程\n18.2.2　什么是线程\n18.3　Python、线程和全局解释器锁\n18.3.1　全局解释器锁（GIL）\n18.3.2　退出线程\n18.3.3　在Python中使用线程\n18.3.4　没有线程支持的情况\n18.3.5　Python的threading模块\n18.4　thread模块\n18.5　threading模块\n18.5.1　Thread类\n18.5.2　斐波那契、阶乘和累加和\n18.5.3　threading模块中的其他函数\n18.5.4　生产者-消费者问题和Queue模块\n18.6　相关模块\n18.7　练习\n第19章　图形用户界面编程\n19.1　简介\n19.1.1　什么是Tcl、Tk和Tkinter\n19.1.2　安装和使用Tkinter　533\n19.1.3　客户端/服务器架构　534\n19.2　Tkinter与Python编程　534\n19.2.1　Tkinter模块：把Tk引入你的程序\n19.2.2　GUI程序开发简介\n19.2.3　顶层窗口：Tkinter.Tk（）\n19.2.4　Tk组件\n19.3　Tkinter举例\n19.3.1　标签组件\n19.3.2　按钮组件\n19.3.3　标签和按钮组件\n19.3.4　标签、按钮和进度条组件\n19.3.5　偏函数应用举例\n19.3.6　中级Tkinter范例\n19.4　其他GUI简介\n19.4.1　Tk Interface eXtensions （Tix）\n19.4.2　Python MegaWidgets （PMW）\n19.4.3　wxWidgets和wxPython\n19.4.4　GTK+和PyGTK\n19.5　相关模块和其他GUI\n19.6　练习\n第20章　Web编程\n20.1　介绍\n20.1.1　Web应用：客户端/服务器计算\n20.1.2　因特网\n20.2　使用Python进行Web应用：创建一个简单的Web客户端\n20.2.1　统一资源定位符\n20.2.2　urlparse模块\n20.2.3　urllib模块\n20.2.4　urllib2模块\n20.3　高级Web客户端\n20.4　CGI：帮助Web服务器处理客户端数据\n20.4.1　CGI介绍\n20.4.2　CGI应用程序\n20.4.3　cgi模块\n20.5　建立CGI应用程序\n20.5.1　建立Web服务器\n20.5.2　建立表单页\n20.5.3　生成结果页\n20.5.4　生成表单和结果页面\n20.5.5　全面交互的Web站点\n20.6　在CGI中使用Unicode编码\n20.7　高级CGI\n20.7.1　Mulitipart表单提交和文件的上传\n20.7.2　多值字段\n20.7.3　cookie\n20.7.4　使用高级CGI\n20.8　Web（HTTP）服务器\n20.9　相关模块\n20.10　练习\n第21章　数据库编程\n21.1　介绍\n21.1.1　持久存储\n21.1.2　基本的数据库操作和SQL语言\n21.1.3　数据库和Python\n21.2　Python数据库应用程序程序员接口（DB-API）\n21.2.1　模块属性\n21.2.2　连接对象\n21.2.3　游标对象\n21.2.4　类型对象和构造器\n21.2.5　关系数据库\n21.2.6　数据库和Python：接口程序\n21.2.7　使用数据库接口程序举例\n21.3　对象-关系管理器（ORM）\n21.3.1　考虑对象，而不是SQL\n21.3.2　Python和ORM\n21.3.3　雇员数据库举例\n21.3.4　总结\n21.4　相关模块\n21.5　练习\n第22章　扩展Python　623\n22.1　引言/动机\n22.1.1　什么是扩展\n22.1.2　为什么要扩展Python\n22.2　创建Python扩展\n22.2.1　创建您的应用程序代码\n22.2.2　用样板来包装你的代码\n22.2.3　编译\n22.2.4　导入和测试\n22.2.5　引用计数\n22.2.6　线程和全局解释器锁（GIL）\n22.3　相关话题\n22.4　练习\n第23章　其他话题\n23.1　Web服务\n23.2　用Win32的COM来操作微软Office\n23.2.1　客户端COM编程\n23.2.2 微软Excel\n23.2.3　微软Word　第1部分　Python核心\n23.2.4　微软PowerPoint\n23.2.5　微软Outlook\n23.2.6　中等规模的例子\n23.3　用Jython写Python和Java的程序\n23.3.1　什么是Jython\n23.3.2　Swing GUI开发（Java或者Python!）\n23.4　练习\n23.2.4　微软PowerPoint\n23.2.5　微软Outlook\n23.2.6　中等规模的例子\n23.3　用Jython写Python和Java的程序\n23.3.1　什么是Jython\n23.3.2　Swing GUI开发（Java或者Python!）\n23.4　练习",
        "pages": "654",
        "images": {
          "small": "https://img3.doubanio.com/spic/s3140466.jpg",
          "large": "https://img3.doubanio.com/lpic/s3140466.jpg",
          "medium": "https://img3.doubanio.com/mpic/s3140466.jpg"
        },
        "alt": "https://book.douban.com/subject/3112503/",
        "id": "3112503",
        "publisher": "人民邮电出版社",
        "isbn10": "711517850X",
        "isbn13": "9787115178503",
        "title": "Python核心编程（第二版）",
        "url": "https://api.douban.com/v2/book/3112503",
        "alt_title": "Core Python Programming, 2nd Edition",
        "author_intro": "",
        "summary": "本书是Python开发者的完全指南——针对 Python 2.5全面升级\n·学习专业的Python风格、最佳实践和好的编程习惯；\n·加强对Python对象、内存模型和Python面向对象特性的深入理解；\n·构建更有效的Web、CGI、互联网、网络和其他客户端/服务器架构应用程序及软件；\n·学习如何使用Python中的Tkinter和其他工具来开发自己的GUI应用程序及软件；\n·通过用C等语言编写扩展来提升Python应用程序的性能，或者通过使用多线程增强I/0相关的应用程序的能力；\n·学习Python中有关数据库的API，以及如何在Python中使用各种不同的数据库系统，包括MySQL、Postgres和 SQLite。",
        "price": "89.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "1c8ea09c04f546a8a671dafe56dccad86ee9914c4f84d75e33a2f3ee391b20f6",
        "file": "Python核心编程（中文第二版）带目录.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 659,
          "average": "8.7",
          "min": 0
        },
        "subtitle": "深度探索动态语言核心技术",
        "author": [
          "陈儒"
        ],
        "pubdate": "2008-6",
        "tags": [
          {
            "count": 1471,
            "name": "python",
            "title": "python"
          },
          {
            "count": 554,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 420,
            "name": "Python",
            "title": "Python"
          },
          {
            "count": 291,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 225,
            "name": "编译原理",
            "title": "编译原理"
          },
          {
            "count": 217,
            "name": "程序语言",
            "title": "程序语言"
          },
          {
            "count": 217,
            "name": "programming",
            "title": "programming"
          },
          {
            "count": 173,
            "name": "脚本引擎",
            "title": "脚本引擎"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s3435132.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "",
        "ebook_url": "https://read.douban.com/ebook/1499455/",
        "pages": "480",
        "images": {
          "small": "https://img3.doubanio.com/spic/s3435132.jpg",
          "large": "https://img3.doubanio.com/lpic/s3435132.jpg",
          "medium": "https://img3.doubanio.com/mpic/s3435132.jpg"
        },
        "alt": "https://book.douban.com/subject/3117898/",
        "id": "3117898",
        "publisher": "电子工业出版社",
        "isbn10": "7121068745",
        "isbn13": "9787121068744",
        "title": "Python源码剖析",
        "url": "https://api.douban.com/v2/book/3117898",
        "alt_title": "",
        "author_intro": "",
        "summary": "作为主流的动态语言，Python不仅简单易学、移植性好，而且拥有强大丰富的库的支持。此外，Python强大的可扩展性，让开发人员既可以非常容易地利用C/C++编写Python的扩展模块，还能将Python嵌入到C/C++程序中，为自己的系统添加动态扩展和动态编程的能力。.\n为了更好地利用Python语言，无论是使用Python语言本身，还是将Python与C/C++交互使用，深刻理解Python的运行原理都是非常重要的。本书以CPython为研究对象，在C代码一级，深入细致地剖析了Python的实现。书中不仅包括了对大量Python内置对象的剖析，更将大量的篇幅用于对Python虚拟机及Python高级特性的剖析。通过此书，读者能够透彻地理解Python中的一般表达式、控制结构、异常机制、类机制、多线程机制、模块的动态加载机制、内存管理机制等核心技术的运行原理，同时，本书所揭示的动态语言的核心技术对于理解其他动态语言，如 Javascript、Ruby等也有较大的参考价值。..\n本书适合于Python程序员、动态语言爱好者、C程序员阅读",
        "ebook_price": "38.39",
        "price": "69.80元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "9042f9784c4c11a1c99edc57a2ab093ed0283013915a64a171da1ca7c72f44ba",
        "file": "Python源码剖析.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 223,
          "average": "7.6",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "Tarek Ziadé"
        ],
        "pubdate": "2010-1",
        "tags": [
          {
            "count": 341,
            "name": "python",
            "title": "python"
          },
          {
            "count": 120,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 117,
            "name": "Python",
            "title": "Python"
          },
          {
            "count": 66,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 50,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 45,
            "name": "programming",
            "title": "programming"
          },
          {
            "count": 44,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 36,
            "name": "Programming",
            "title": "Programming"
          }
        ],
        "origin_title": "Expert Python Programming",
        "image": "https://img3.doubanio.com/mpic/s4163751.jpg",
        "binding": "平装",
        "translator": [
          "姚军",
          "夏海轮",
          "译"
        ],
        "catalog": "第1章　准备工作\n1.1　安装Python\n1.1.1　Python实现版本\n1.1.2　在Linux环境下安装\n1.1.3　在Windows环境下安装\n1.1.4　在Mac OS X环境下安装\n1.2　Python命令行\n1.2.1　定制交互式命令行\n1.2.2　iPython：增强型命令行\n1.3　安装setuptools\n1.3.1　工作原理\n1.3.2　使用EasyInstall安装setuptools\n1.3.3　将MinGW整合到distutils中\n1.4　工作环境\n1.4.1　使用文本编辑器与辅助工具的组合\n1.4.2　使用集成开发环境\n1.5　小结\n第2章　语法最佳实践——低于类级\n2.1　列表推导\n2.2　迭代器和生成器\n2.2.1　生成器\n2.2.2　协同程序\n2.2.3　生成器表达式\n2.2.4　itertools模块\n2.3　装饰器\n2.3.1　如何编写装饰器\n2.3.2　参数检查\n2.3.3　缓存\n2.3.4　代理\n2.3.5　上下文提供者\n2.4　with和contextlib\n2.4.1　contextlib模块\n2.4.2　上下文实例\n2.5　小结\n第3章　语法最佳实践——类级\n3.1　子类化内建类型\n3.2　访问超类中的方法\n3.2.1　理解Python的方法解析顺序\n3.2.2　super的缺陷\n3.3　最佳实践\n3.4　描述符和属性\n3.4.1　描述符\n3.4.2　属性\n3.5　槽\n3.6　元编程\n3.6.1　__new__方法\n3.6.2　__metaclass__方法\n3.7　小结\n第4章　选择好的名称\n4.1　PEP 8和命名最佳实践\n4.2　命名风格\n4.2.1　变量\n4.2.2　函数和方法\n4.2.3　属性\n4.2.4　类\n4.2.5　模块和包\n4.3　命名指南\n4.3.1　使用“has”或“is”前缀命名布尔元素\n4.3.2　用复数形式命名序列元素\n4.3.3　用显式的名称命名字典\n4.3.4　避免通用名称\n4.3.5　避免现有名称\n4.4　参数最佳实践\n4.4.1　根据迭代设计构建参数\n4.4.2　信任参数和测试\n4.4.3　小心使用*args和**kw魔法参数\n4.5　类名\n4.6　模块和包名称\n4.7　使用API\n4.7.1　跟踪冗长\n4.7.2　构建命名空间树\n4.7.3　分解代码\n4.7.4　使用Egg\n4.7.5　使用deprecation过程\n4.8　有用的工具\n4.8.1　Pylint\n4.8.2　CloneDigger\n4.9　小结\n第5章　编写一个包\n第6章　编写一个应用程序\n第7章　使用zc.buildout\n第8章　代码管理\n第9章　生命周期管理\n第10章　编写项目文档\n第11章　测试驱动开发\n第12章　优化：通用原则和剖析技术\n第13章　优化：解决方案\n第14章　有用的设计模式",
        "pages": "306",
        "images": {
          "small": "https://img3.doubanio.com/spic/s4163751.jpg",
          "large": "https://img3.doubanio.com/lpic/s4163751.jpg",
          "medium": "https://img3.doubanio.com/mpic/s4163751.jpg"
        },
        "alt": "https://book.douban.com/subject/4212921/",
        "id": "4212921",
        "publisher": "人民邮电出版社",
        "isbn10": "7115217033",
        "isbn13": "9787115217035",
        "title": "Python高级编程",
        "url": "https://api.douban.com/v2/book/4212921",
        "alt_title": "Expert Python Programming",
        "author_intro": "Tarek Ziadé，是巴黎Ingeniweb公司的CTO，其工作方向为Python、Zope、Plone技术和质量保证。他参与Zope社区已经有5年了，并且曾经为Zope自身贡献过代码。\nTarek创建了Afpy，这是法国的Python用户组，并且编写了两本法语的Python书籍。他还在诸如Solutions Linux、Pycon、OSCON和EuroPython等法国及国际会议上发表了许多演讲，并且主持了许多课程。",
        "summary": "《Python高级编程》通过大量的实例，介绍了Python语言的最佳实践和敏捷开发方法，并涉及整个软件生命周期的高级主题，诸如持续集成、版本控制系统、包的发行和分发、开发模式、文档编写等。《Python高级编程》首先介绍如何设置最优的开发环境，然后以Python敏捷开发方法为线索，阐述如何将已被验证的面向对象原则应用到设计中。这些内容为开发人员和项目管理人员提供了整个软件工程中的许多高级概念以及专家级的建议，其中有些内容的意义甚至超出了Python语言本身。\n《Python高级编程》针对具备一定Python基础并希望通过在项目中应用最佳实践和新的开发技术来提升自己的Python开发人员。",
        "price": "45.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "868b8d165e79d0fc056ce0912d513bc802f50e143b626dec20cb1e0c3bc0bfdc",
        "file": "Python高级编程.pdf"
      },
      {
        "timestamp": "2016-04-27T04:21:14.605277+00:00",
        "contributor": "GitBook",
        "description": "连载介绍信息: zone.wooyun.org/content/23138",
        "language": "zh",
        "identifier": {
          "uuid": "bbc13614-2b30-44d0-a30c-4079fd0082df"
        },
        "title": "Violent Python 中文版",
        "creator": "wizardforcel",
        "publisher": "GitBook",
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "b44a9aa7cdcf84a400571daaf88e7f32e103170395ff40e5be69a2bc6e54ca2b",
        "file": "violent-python.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 49,
          "average": "7.6",
          "min": 0
        },
        "subtitle": "运用设计模式、并发和程序库创建高质量程序",
        "author": [
          "[美] Mark Summerfield"
        ],
        "pubdate": "2014-8",
        "tags": [
          {
            "count": 144,
            "name": "Python",
            "title": "Python"
          },
          {
            "count": 53,
            "name": "设计模式",
            "title": "设计模式"
          },
          {
            "count": 30,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 24,
            "name": "python",
            "title": "python"
          },
          {
            "count": 20,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 12,
            "name": "Programming",
            "title": "Programming"
          },
          {
            "count": 10,
            "name": "自我修练",
            "title": "自我修练"
          },
          {
            "count": 8,
            "name": "计算机科学",
            "title": "计算机科学"
          }
        ],
        "origin_title": "Python in Practice: Create Better Programs Using Concurrency, Libraries, and Patterns",
        "image": "https://img3.doubanio.com/mpic/s27397566.jpg",
        "binding": "平裝",
        "translator": [
          "爱飞翔"
        ],
        "catalog": "译者序\n序\n前言\n第1章　python的创建型设计模式 1\n1.1　抽象工厂模式 1\n1.1.1　经典的抽象工厂模式 2\n1.1.2　python风格的抽象工厂模式 4\n1.2　建造者模式 6\n1.3　工厂方法模式 12\n1.4　原型模式 18\n1.5　单例模式 19\n第2章　python的结构型设计模式 21\n2.1　适配器模式 21\n2.2　桥接模式 26\n2.3　组合模式 31\n2.3.1　常规的“组合体/非组合体”式层级 32\n2.3.2　只用一个类来表示组合体与非组合体 35\n2.4　修饰器模式 37\n2.4.1　函数修饰器与方法修饰器 38\n2.4.2　类修饰器 42\n2.5　外观模式 47\n2.6　享元模式 52\n2.7　代理模式 54\n第3章　python的行为型设计模式 58\n3.1　责任链模式 58\n3.1.1　用常规方式实现责任链 59\n3.1.2　基于协程的责任链 60\n3.2　命令模式 63\n3.3　解释器模式 66\n3.3.1　用eval()函数求表达式的值 67\n3.3.2　用exec()函数执行代码 70\n3.3.3　用子进程执行代码 73\n3.4　迭代器模式 76\n3.4.1　通过序列协议实现迭代器 77\n3.4.2　通过双参数iter()函数实现迭代器 77\n3.4.3　通过迭代器协议实现迭代器 79\n3.5　中介者模式 81\n3.5.1　用常规方式实现中介者 82\n3.5.2　基于协程的中介者 85\n3.6　备忘录模式 87\n3.7　观察者模式 87\n3.8　状态模式 91\n3.8.1　用同一套方法来处理不同的状态 93\n3.8.2　用不同的方法来处理不同的状态 94\n3.9　策略模式 95\n3.10　模板方法模式 98\n3.11　访问者模式 101\n3.12　案例研究：图像处理程序包 102\n3.12.1　通用的图像处理模块 103\n3.12.2　xpm模块概述 111\n3.12.3　png包装器模块 113\n第4章　python的高级并发技术 116\n4.1　计算密集型并发 119\n4.1.1　用队列及多进程实现并发 121\n4.1.2　用future及多进程实现并发 126\n4.2　i/o密集型并发 128\n4.2.1　用队列及线程实现并发 129\n4.2.2　用future及线程实现并发 134\n4.3　案例研究：并发式gui应用程序 136\n4.3.1　创建gui 138\n4.3.2　编写与工作线程配套的imagescale模块 144\n4.3.3　在gui中显示图像处理进度 146\n4.3.4　处理gui程序终止时的相关事宜 148\n第5章　扩充python 150\n5.1　用ctypes访问c程序库 151\n5.2　cython的用法 159\n5.2.1　用cython访问c程序库 159\n5.2.2　编写cython模块以进一步提升程序执行速度 164\n5.3　案例研究：用cython优化图像处理程序包 169\n第6章　python高级网络编程 173\n6.1　编写xml-rpc应用程序 174\n6.1.1　数据包装器 174\n6.1.2　编写xml-rpc服务器 178\n6.1.3　编写xml-rpc客户端 180\n6.2　编写rpyc应用程序 188\n6.2.1　线程安全的数据包装器 188\n6.2.2　编写rpyc服务器 193\n6.2.3　编写rpyc客户端 195\n第7章　用tkinter开发图形用户界面 199\n7.1　tkinter简介 201\n7.2　用tkinter创建对话框 203\n7.2.1　创建对话框式应用程序 205\n7.2.2　创建应用程序中的对话框 212\n7.3　用tkinter创建主窗口式应用程序 220\n7.3.1　创建主窗口 222\n7.3.2　创建菜单 224\n7.3.3　创建带计分器的状态栏 226\n第8章　用opengl绘制3d图形 229\n8.1　用透视投影法创建场景 230\n8.1.1　用pyopengl编写cylinder程序 231\n8.1.2　用pyglet编写cylinder程序 235\n8.2　用正交投影法制作游戏 238\n8.2.1　绘制游戏场景 240\n8.2.2　判断用户是否选中了场景里的物体 242\n8.2.3　处理用户操作 244\n附录a　结束语 248\n附录b　参考书目摘录 250",
        "pages": "252",
        "images": {
          "small": "https://img3.doubanio.com/spic/s27397566.jpg",
          "large": "https://img3.doubanio.com/lpic/s27397566.jpg",
          "medium": "https://img3.doubanio.com/mpic/s27397566.jpg"
        },
        "alt": "https://book.douban.com/subject/25955274/",
        "id": "25955274",
        "publisher": "机械工业出版社",
        "isbn10": "7111473949",
        "isbn13": "9787111473947",
        "title": "Python编程实战",
        "url": "https://api.douban.com/v2/book/25955274",
        "alt_title": "Python in Practice: Create Better Programs Using Concurrency, Libraries, and Patterns",
        "author_intro": "Mark Summerfield Qtrac公司创始人，独立的培训讲师、顾问、技术编辑，Go、Python、C++、Qt和PyQt方面的技术作家。他撰写了大量畅销图书，包括《Rapid GUI Programming with Python and Qt》、《C++ GUI Programming with Qt 4，Second Edition》(与Jasmin Blanchette合著)、《Programming in Python 3，Second Edition》、《Advanced Qt Programming》和《Programming in Go》等。",
        "summary": "《python编程实战：运用设计模式、并发和程序库创建高质量程序》由python开发者社区知名技术专家mark summerfield亲笔撰写，全球资深python专家doug hellmann作序鼎力推荐，是python领域最有影响力的著作之一。书中通过大量实用的范例代码和三个完整的案例研究，全面而系统地讲解了如何运用设计模式来规划代码结构，如何通过并发与cython等技术提升代码执行速度，以及如何利用各种python程序库来快速开发具体的应用程序和游戏。\n《python编程实战：运用设计模式、并发和程序库创建高质量程序》共8章：第1～3章分别介绍了python的几种设计模式(创建型设计模式、结构型设计模式和行为型设计模式)；第4章和第5章详细讲解了python的高级并发技术以及cython的用法；第6章具体介绍了python的高级网络编程；第7章阐释了如何用tkinter开发图形用户界面；第8章讲解了如何用opengl绘制3d图形。",
        "series": {
          "id": "12919",
          "title": "华章程序员书库"
        },
        "price": "69.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "9d75c34089bcfbd57948a9ccf3b80dfb727a3b959c57e3621816fba995a3121e",
        "file": "《Python编程实战：运用设计模式、冰法和程序库创建高质量程序》迷你书.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 83,
          "average": "9.2",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[巴西] Luciano Ramalho"
        ],
        "pubdate": "2017-5-15",
        "tags": [
          {
            "count": 186,
            "name": "Python",
            "title": "Python"
          },
          {
            "count": 77,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 60,
            "name": "python",
            "title": "python"
          },
          {
            "count": 49,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 32,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 28,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 21,
            "name": "图灵社区",
            "title": "图灵社区"
          },
          {
            "count": 14,
            "name": "进阶",
            "title": "进阶"
          }
        ],
        "origin_title": "Fluent Python",
        "image": "https://img3.doubanio.com/mpic/s29434304.jpg",
        "binding": "平装",
        "translator": [
          "安道",
          "吴珂"
        ],
        "catalog": "",
        "pages": "628",
        "images": {
          "small": "https://img3.doubanio.com/spic/s29434304.jpg",
          "large": "https://img3.doubanio.com/lpic/s29434304.jpg",
          "medium": "https://img3.doubanio.com/mpic/s29434304.jpg"
        },
        "alt": "https://book.douban.com/subject/27028517/",
        "id": "27028517",
        "publisher": "人民邮电出版社",
        "isbn10": "7115454159",
        "isbn13": "9787115454157",
        "title": "流畅的Python",
        "url": "https://api.douban.com/v2/book/27028517",
        "alt_title": "Fluent Python",
        "author_intro": "Luciano Ramalho，从1998年起就成为了Python程序员。他是Python软件基金会的成员，Python.pro.br（巴西的一家培训公司）的共同所有者，还是巴西第一个众创空间Garoa Hacker Clube的联合创始人。他领导过多个软件开发团队，还在巴西的媒体、银行和政府部门教授Python课程。",
        "summary": "【技术大咖推荐】\n“很荣幸担任这本优秀图书的技术审校。这本书能帮助很多中级Python程序员掌握这门语言，我也从中学到了相当多的知识！”——Alex Martelli，Python软件基金会成员\n“对于想要扩充知识的中级和高级Python程序员来说，这本书是充满了实用编程技巧的宝藏。”——Daniel Greenfeld和Audrey Roy Greenfeld，Two Scoops of Django作者\n【本书特色】\n本书由奋战在Python开发一线近20年的Luciano Ramalho执笔，Victor Stinner、Alex Martelli等Python大咖担纲技术审稿人，从语言设计层面剖析编程细节，兼顾Python 3和Python 2，告诉你Python中不亲自动手实践就无法理解的语言陷阱成因和解决之道，教你写出风格地道的Python代码。\n●\tPython数据模型：理解为什么特殊方法是对象行为一致的关键。\n●\t数据结构：充分利用内置类型，理解Unicode文本和字节二象性。\n●\t把函数视作对象：把Python函数视作一等对象，并了解这一点对流行的设计模式的影响。\n●\t面向对象习惯用法：通过构建类学习引用、可变性、接口、运算符重载和多重继承。\n●\t控制流程：学习使用上下文管理器、生成器、协程，以及通过concurrent.futures和asyncio包实现的并发。\n●\t元编程：理解特性、描述符、类装饰器和元类的工作原理。\n【主要内容】\n本书致力于帮助Python开发人员挖掘这门语言及相关程序库的优秀特性，避免重复劳动，同时写出简洁、流畅、易读、易维护，并且具有地道Python风格的代码。本书尤其深入探讨了Python语言的高级用法，涵盖数据结构、Python风格的对象、并行与并发，以及元编程等不同的方面。\n本书适合中高级Python软件开发人员阅读参考。\n【译者简介】\n安道\n专注于现代计算机技术的自由翻译，译有《Flask Web 开发》《Python 网络编程攻略》《Ruby on Rails 教程》等书。\n个人网站：http://about.ac/。\n吴珂\n现为Airbnb公司软件工程师，所在团队主要负责开发和维护各类可伸缩、高性能服务，并在Airbnb内推广面向服务的系统架构。在分布式系统、云存储服务和跨平台SDK开发，以及大规模数据处理等方面有多年经验。",
        "price": "139元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "f649c0ee64454bc9790c3f9a98dc9be74bc4c99d7c4d86eadb93d5eceb71fa4f",
        "file": "流畅的Python.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 381,
          "average": "7.4",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "张颖",
          "赖勇浩"
        ],
        "pubdate": "2014-6",
        "tags": [
          {
            "count": 245,
            "name": "python",
            "title": "python"
          },
          {
            "count": 205,
            "name": "Python",
            "title": "Python"
          },
          {
            "count": 123,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 70,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 58,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 53,
            "name": "Programming",
            "title": "Programming"
          },
          {
            "count": 50,
            "name": "编程语言",
            "title": "编程语言"
          },
          {
            "count": 29,
            "name": "软件工程",
            "title": "软件工程"
          }
        ],
        "origin_title": "",
        "image": "https://img9.doubanio.com/view/subject/m/public/s27308066.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "前　言\n第1章　引论 1\n建议1：理解Pythonic概念 1\n建议2：编写Pythonic代码 5\n建议3：理解Python与C语言的不同之处 8\n建议4：在代码中适当添加注释 10\n建议5：通过适当添加空行使代码布局更为优雅、合理 12\n建议6：编写函数的4个原则 15\n建议7：将常量集中到一个文件 18\n第2章　编程惯用法 20\n建议8：利用assert语句来发现问题 20\n建议9：数据交换值的时候不推荐使用中间变量 22\n建议10：充分利用Lazy evaluation的特性 24\n建议11：理解枚举替代实现的缺陷 25\n建议12：不推荐使用type来进行类型检查 27\n建议13：尽量转换为浮点类型后再做除法 29\n建议14：警惕eval()的安全漏洞 31\n建议15：使用enumerate()获取序列迭代的索引和值 33\n建议16：分清==与is的适用场景 35\n建议17：考虑兼容性，尽可能使用Unicode 37\n建议18：构建合理的包层次来管理module 42\n第3章　基础语法 45\n建议19：有节制地使用from...import语句 45\n建议20：优先使用absolute import来导入模块 48\n建议21：i+=1不等于++i 50\n建议22：使用with自动关闭资源 50\n建议23：使用else子句简化循环（异常处理） 53\n建议24：遵循异常处理的几点基本原则 55\n建议25：避免finally中可能发生的陷阱 59\n建议26：深入理解None，正确判断对象是否为空 60\n建议27：连接字符串应优先使用join而不是+ 62\n建议28：格式化字符串时尽量使用.format方式而不是% 64\n建议29：区别对待可变对象和不可变对象 68\n建议30：[]、()和{}：一致的容器初始化形式 71\n建议31：记住函数传参既不是传值也不是传引用 73\n建议32：警惕默认参数潜在的问题 77\n建议33：慎用变长参数 78\n建议34：深入理解str()和repr()的区别 80\n建议35：分清staticmethod和classmethod的适用场景 82\n第4章　库 86\n建议36：掌握字符串的基本用法 86\n建议37：按需选择sort()或者sorted() 89\n建议38：使用copy模块深拷贝对象 92\n建议39：使用Counter进行计数统计 95\n建议40：深入掌握ConfigParser 97\n建议41：使用argparse处理命令行参数 99\n建议42：使用pandas处理大型CSV文件 103\n建议43：一般情况使用ElementTree解析XML 107\n建议44：理解模块pickle优劣 111\n建议45：序列化的另一个不错的选择——JSON 113\n建议46：使用traceback获取栈信息 116\n建议47：使用logging记录日志信息 119\n建议48：使用threading模块编写多线程程序 122\n建议49：使用Queue使多线程编程更安全 125\n第5章　设计模式 129\n建议50：利用模块实现单例模式 129\n建议51：用mixin模式让程序更加灵活 132\n建议52：用发布订阅模式实现松耦合 134\n建议53：用状态模式美化代码 137\n第6章　内部机制 141\n建议54：理解built-in objects 141\n建议55：__init__()不是构造方法 143\n建议56：理解名字查找机制 147\n建议57：为什么需要self参数 151\n建议58：理解MRO与多继承 154\n建议59：理解描述符机制 157\n建议60：区别__getattr__()和__getattribute__()方法 160\n建议61：使用更为安全的property 164\n建议62：掌握metaclass 169\n建议63：熟悉Python对象协议 176\n建议64：利用操作符重载实现中缀语法 179\n建议65：熟悉 Python 的迭代器协议 181\n建议66：熟悉 Python 的生成器 185\n建议67：基于生成器的协程及greenlet 188\n建议68：理解GIL的局限性 192\n建议69：对象的管理与垃圾回收 194\n第7章　使用工具辅助项目开发 197\n建议70：从PyPI安装包 197\n建议71：使用pip和yolk安装、管理包 199\n建议72：做paster创建包 202\n建议73：理解单元测试概念 209\n建议74：为包编写单元测试 212\n建议75：利用测试驱动开发提高代码的可测性 216\n建议76：使用Pylint检查代码风格 218\n建议77：进行高效的代码审查 221\n建议78：将包发布到PyPI 224\n第8章　性能剖析与优化 227\n建议79：了解代码优化的基本原则 227\n建议80：借助性能优化工具 228\n建议81：利用cProfile定位性能瓶颈 229\n建议82：使用memory_profiler 和 objgraph 剖析内存使用 235\n建议83：努力降低算法复杂度 237\n建议84：掌握循环优化的基本技巧 238\n建议85：使用生成器提高效率 240\n建议86：使用不同的数据结构优化性能 243\n建议87：充分利用set的优势 245\n建议88：使用multiprocessing克服GIL的缺陷 248\n建议89：使用线程池提高效率 254\n建议90：使用C/C++模块扩展提高性能 257\n建议91：使用 Cython 编写扩展模块 259",
        "ebook_url": "https://read.douban.com/ebook/8712705/",
        "pages": "272",
        "images": {
          "small": "https://img9.doubanio.com/view/subject/s/public/s27308066.jpg",
          "large": "https://img9.doubanio.com/view/subject/l/public/s27308066.jpg",
          "medium": "https://img9.doubanio.com/view/subject/m/public/s27308066.jpg"
        },
        "alt": "https://book.douban.com/subject/25910544/",
        "id": "25910544",
        "publisher": "机械工业出版社",
        "isbn10": "7111467043",
        "isbn13": "9787111467045",
        "title": "编写高质量代码：改善Python程序的91个建议",
        "url": "https://api.douban.com/v2/book/25910544",
        "alt_title": "",
        "author_intro": "张颖，资深软件开发工程师，精通Java、Python、Perl等技术，以及多种脚本语言，有多年开发经验。曾就职于阿尔卡特朗讯上海公司的LTE无线事业部，现就职于IBM CSTL，工作期间获得过多种奖励，并于2012年获得一项云计算相关的专利。\n赖勇浩，资深软件开发工程师，自2006年起以编写Python代码为生，现已创业。在Python领域有深厚的积累，CSDN博客专家，博客浏览量超过200万。也是珠三角技术沙龙创始人之一，从2009年起担任沙龙组委，长年活跃在社区第一线，在国内Python圈子里有较高的知名度和影响力。有超过7年的游戏开发经验，擅长Python、C++等网游相关的技术，曾就职于网易等网游研发厂商；现专注于中国彩票事业，开发互联网、电话和自助终端彩票销售平台，以促进行业信息化为己任。",
        "summary": "在通往“Python技术殿堂”的路上，本书将为你编写健壮、优雅、高质量的Python代码提供切实帮助！内容全部由Python编码的最佳实践组成，从基本原则、惯用法、语法、库、设计模式、内部机制、开发工具和性能优化8个方面深入探讨了编写高质量Python代码的技巧与禁忌，一共总结出91条宝贵的建议。每条建议对应Python程序员可能会遇到的一个问题。本书不仅以建议的方式从正反两方面给出了被实践证明为十分优秀的解决方案或非常糟糕的解决方案，而且分析了问题产生的根源，会使人有一种醍醐灌顶的感觉，豁然开朗。\n《编写高质量代码：改善Python程序的91个建议》针对每个问题所选择的应用场景都非常典型，给出的建议也都与实践紧密结合。书中的每一条建议都可能在你的下一行代码、下一个应用或下一个项目中显露锋芒。建议你将本书搁置在手边，随时查阅，相信这么做一定能使你的学习和开发工作事半功倍。",
        "ebook_price": "25.00",
        "series": {
          "id": "34529",
          "title": "Effective系列丛书"
        },
        "price": "59.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "4eaf157d1cc081f997be222fe0289628de42c033adde2e05b5c2f0e1e2c173b4",
        "file": "编写高质量的代码_改善Python程序的91个建议.epub"
      }
    ]
  },
  {
    "dir_name": "safety",
    "name": "安全",
    "books": [
      {
        "timestamp": "2017-09-20T02:12:35.306572+00:00",
        "description": "A book to introduce blockchain technologies, including the key techniques, algorithms, usage scenarios, and projects.",
        "identifier": {
          "uuid": "8dd343f9-5d16-417a-923e-530f2ccb1177"
        },
        "publisher": "GitBook",
        "contributor": "GitBook",
        "title": "区块链技术指南",
        "language": "zh",
        "creator": "yeasy",
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "e074ed66981f3776e7f7e60d71f2b18bea4a2273fbd5fae67f354cbaa14e886c",
        "file": "blockchain_guide.epub"
      },
      {
        "title_sort": "加密与解密(第3版)",
        "timestamp": "2017-08-29T14:48:08.901034+00:00",
        "language": "zh",
        "creator": "段钢",
        "title": "加密与解密(第3版)",
        "date": "2013-08-24T16:00:00+00:00",
        "contributor": "calibre (3.7.0) [https://calibre-ebook.com]",
        "identifier": {
          "mobi-asin": "d96460dc-44aa-418c-9471-b6b5016eaacf",
          "uuid": "5ee84d0c-680a-44c4-aa30-19be7cfa77d7",
          "calibre": "5ee84d0c-680a-44c4-aa30-19be7cfa77d7"
        },
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "e04a11fd723f2bb9bb42bef006115ebf5a30a26b6f4642eacf00d9f863cbf6cc",
        "file": "解密与加密(第3版).epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 117,
          "average": "8.6",
          "min": 0
        },
        "subtitle": "Web实战篇（第2版）",
        "author": [
          "[英] Dafydd Stuttard",
          "[英] Marcus Pinto"
        ],
        "pubdate": "2012-6-26",
        "tags": [
          {
            "count": 313,
            "name": "网络安全",
            "title": "网络安全"
          },
          {
            "count": 246,
            "name": "黑客",
            "title": "黑客"
          },
          {
            "count": 152,
            "name": "安全",
            "title": "安全"
          },
          {
            "count": 124,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 86,
            "name": "WEB渗透",
            "title": "WEB渗透"
          },
          {
            "count": 77,
            "name": "Web",
            "title": "Web"
          },
          {
            "count": 70,
            "name": "互联网",
            "title": "互联网"
          },
          {
            "count": 54,
            "name": "Security",
            "title": "Security"
          }
        ],
        "origin_title": "The Web Application Hacker’s Handbook",
        "image": "https://img3.doubanio.com/view/subject/m/public/s10321223.jpg",
        "binding": "平装",
        "translator": [
          "石华耀",
          "傅志红"
        ],
        "catalog": "目　　录\n第1章　 Web应用程序安全与风险　　1\n1.1　 Web应用程序的发展历程　　1\n1.1.1　 Web应用程序的常见功能　　3\n1.1.2　 Web应用程序的优点　　4\n1.2　 Web应用程序安全　　4\n1.2.1　 “本站点是安全的”　　5\n1.2.2　 核心安全问题：用户可提交任意输入　　6\n1.2.3　 关键问题因素　　7\n1.2.4　 新的安全边界　　8\n1.2.5　 Web应用程序安全的未来　　10\n1.3　 小结　　10\n第2章　 核心防御机制　　12\n2.1　 处理用户访问　　12\n2.1.1　 身份验证　　13\n2.1.2　 会话管理　　13\n2.1.3　 访问控制　　14\n2.2　 处理用户输入　　15\n2.2.1　 输入的多样性　　15\n2.2.2　 输入处理方法　　16\n2.2.3　 边界确认　　18\n2.2.4　 多步确认与规范化　　20\n2.3　 处理攻击者　　21\n2.3.1　 处理错误　　21\n2.3.2　 维护审计日志　　22\n2.3.3　 向管理员发出警报　　23\n2.3.4　 应对攻击　　24\n2.4　 管理应用程序　　25\n2.5　 小结　　26\n2.6　 问题　　26\n第3章　 Web应用程序技术　　27\n3.1　 HTTP　　27\n3.1.1　 HTTP请求　　27\n3.1.2　 HTTP响应　　28\n3.1.3　 HTTP方法　　29\n3.1.4　 URL　　30\n3.1.5　 REST　　31\n3.1.6　 HTTP消息头　　31\n3.1.7　 cookie　　33\n3.1.8　 状态码　　33\n3.1.9　 HTTPS　　34\n3.1.10　 HTTP代理　　35\n3.1.11　 HTTP身份验证　　35\n3.2　 Web功能　　36\n3.2.1　 服务器端功能　　36\n3.2.2　 客户端功能　　40\n3.2.3　 状态与会话　　46\n3.3　 编码方案　　47\n3.3.1　 URL编码　　47\n3.3.2　 Unicode编码　　48\n3.3.3　 HTML编码　　48\n3.3.4　 Base64编码　　49\n3.3.5　 十六进制编码　　49\n3.3.6　 远程和序列化框架　　49\n3.4　 下一步　　50\n3.5　 问题　　50\n第4章　 解析应用程序　　51\n4.1　 枚举内容与功能　　51\n4.1.1　 Web抓取　　51\n4.1.2　 用户指定的抓取　　54\n4.1.3　 发现隐藏的内容　　56\n4.1.4　 应用程序页面与功能路径　　67\n4.1.5　 发现隐藏的参数　　69\n4.2　 分析应用程序　　69\n4.2.1　 确定用户输入入口点　　70\n4.2.2　 确定服务器端技术　　72\n4.2.3　 确定服务器端功能　　76\n4.2.4　 解析受攻击面　　79\n4.2.5　 解析Extreme Internet Shopping应用程序　　80\n4.3　 小结　　81\n4.4　 问题　　82\n第5章　 避开客户端控件　　83\n5.1　 通过客户端传送数据　　83\n5.1.1　 隐藏表单字段　　84\n5.1.2　 HTTP cookie　　86\n5.1.3　 URL参数　　86\n5.1.4　 Referer消息头　　86\n5.1.5　 模糊数据　　88\n5.1.6　 ASP.NET ViewState　　89\n5.2　 收集用户数据：HTML表单　　91\n5.2.1　 长度限制　　91\n5.2.2　 基于脚本的确认　　93\n5.2.3　 禁用的元素　　94\n5.3　 收集用户数据：浏览器扩展　　95\n5.3.1　 常见的浏览器扩展技术　　96\n5.3.2　 攻击浏览器扩展的方法　　97\n5.3.3　 拦截浏览器扩展的流量　　97\n5.3.4　 反编译浏览器扩展　　100\n5.3.5　 附加调试器　　109\n5.3.6　 本地客户端组件　　111\n5.4　 安全处理客户端数据　　112\n5.4.1　 通过客户端传送数据　　112\n5.4.2　 确认客户端生成的数据　　112\n5.4.3　 日志与警报　　113\n5.5　 小结　　114\n5.6　 问题　　114\n第6章　 攻击验证机制　　115\n6.1　 验证技术　　115\n6.2　 验证机制设计缺陷　　116\n6.2.1　 密码保密性不强　　116\n6.2.2　 蛮力攻击登录　　117\n6.2.3　 详细的失败消息　　120\n6.2.4　 证书传输易受攻击　　122\n6.2.5　 密码修改功能　　124\n6.2.6　 忘记密码功能　　125\n6.2.7　 “记住我”功能　　127\n6.2.8　 用户伪装功能　　129\n6.2.9　 证书确认不完善　　131\n6.2.10　 非唯一性用户名　　131\n6.2.11　 可预测的用户名　　132\n6.2.12　 可预测的初始密码　　133\n6.2.13　 证书分配不安全　　133\n6.3　 验证机制执行缺陷　　134\n6.3.1　 故障开放登录机制　　134\n6.3.2　 多阶段登录机制中的缺陷　　135\n6.3.3　 不安全的证书存储　　138\n6.4　 保障验证机制的安全　　139\n6.4.1　 使用可靠的证书　　140\n6.4.2　 安全处理证书　　140\n6.4.3　 正确确认证书　　141\n6.4.4　 防止信息泄露　　142\n6.4.5　 防止蛮力攻击　　143\n6.4.6　 防止滥用密码修改功能　　144\n6.4.7　 防止滥用账户恢复功能　　145\n6.4.8　 日志、监控与通知　　146\n6.5　 小结　　146\n6.6　 问题　　147\n第7章　 攻击会话管理　　148\n7.1　 状态要求　　148\n7.2　 会话令牌生成过程中的薄弱环节　　151\n7.2.1　 令牌有一定含义　　152\n7.2.2　 令牌可预测　　153\n7.2.3　 加密令牌　　162\n7.3　 会话令牌处理中的薄弱环节　　170\n7.3.1　 在网络上泄露令牌　　170\n7.3.2　 在日志中泄露令牌　　173\n7.3.3　 令牌—会话映射易受攻击　　175\n7.3.4　 会话终止易受攻击　　176\n7.3.5　 客户端暴露在令牌劫持风险之中　　177\n7.3.6　 宽泛的cookie范围　　178\n7.4　 保障会话管理的安全　　180\n7.4.1　 生成强大的令牌　　181\n7.4.2　 在整个生命周期保障令牌的安全　　182\n7.4.3　 日志、监控与警报　　184\n7.5　 小结　　185\n7.6　 问题　　185\n第8章　 攻击访问控制　　187\n8.1　 常见漏洞　　187\n8.1.1　 完全不受保护的功能　　188\n8.1.2　 基于标识符的功能　　190\n8.1.3　 多阶段功能　　191\n8.1.4　 静态文件　　191\n8.1.5　 平台配置错误　　192\n8.1.6　 访问控制方法不安全　　192\n8.2　 攻击访问控制　　193\n8.2.1　 使用不同用户账户进行测试　　194\n8.2.2　 测试多阶段过程　　197\n8.2.3　 通过有限访问权限进行测试　　199\n8.2.4　 测试“直接访问方法”　　201\n8.2.5　 测试对静态资源的控制　　202\n8.2.6　 测试对HTTP方法实施的限制　　202\n8.3　 保障访问控制的安全　　203\n8.4　 小结　　206\n8.5　 问题　　207\n第9章　 攻击数据存储区　　208\n9.1　 注入解释型语言　　208\n9.2　 注入SQL　　210\n9.2.1　 利用一个基本的漏洞　　211\n9.2.2　 注入不同的语句类型　　213\n9.2.3　 查明SQL注入漏洞　　216\n9.2.4　 “指纹”识别数据库　　219\n9.2.5　 UNION操作符　　220\n9.2.6　 提取有用的数据　　224\n9.2.7　 使用UNION提取数据　　224\n9.2.8　 避开过滤　　226\n9.2.9　 二阶SQL注入　　227\n9.2.10　 高级利用　　229\n9.2.11　 SQL注入之外：扩大数据库攻击范围　　236\n9.2.12　 使用SQL注入工具　　238\n9.2.13　 SQL语法与错误参考　　241\n9.2.14　 防止SQL注入　　246\n9.3　 注入NoSQL　　249\n9.4　 注入XPath　　250\n9.4.1　 破坏应用程序逻辑　　251\n9.4.2　 谨慎XPath注入　　252\n9.4.3　 盲目XPath注入　　252\n9.4.4　 查找XPath注入漏洞　　253\n9.4.5　 防止XPath注入　　254\n9.5　 注入LDAP　　254\n9.5.1　 利用LDAP注入　　255\n9.5.2　 查找LDAP注入漏洞　　257\n9.5.3　 防止LDAP注入　　258\n9.6　 小结　　258\n9.7　 问题　　258\n第10章　 测试后端组件　　260\n10.1　 注入操作系统命令　　260\n10.1.1　 例1：通过Perl注入　　261\n10.1.2　 例2：通过ASP注入　　262\n10.1.3　 通过动态执行注入　　264\n10.1.4　 查找OS命令注入漏洞　　264\n10.1.5　 查找动态执行漏洞　　267\n10.1.6　 防止OS命令注入　　268\n10.1.7　 防止脚本注入漏洞　　268\n10.2　 操作文件路径　　268\n10.2.1　 路径遍历漏洞　　269\n10.2.2　 文件包含漏洞　　278\n10.3　 注入XML解释器　　279\n10.3.1　 注入XML外部实体　　279\n10.3.2　 注入SOAP　　281\n10.3.3　 查找并利用SOAP注入　　283\n10.3.4　 防止SOAP注入　　284\n10.4　 注入后端HTTP请求　　284\n10.4.1　 服务器端HTTP重定向　　285\n10.4.2　 HTTP参数注入　　287\n10.5　 注入电子邮件　　290\n10.5.1　 操纵电子邮件标头　　290\n10.5.2　 SMTP命令注入　　291\n10.5.3　 查找SMTP注入漏洞　　292\n10.5.4　 防止SMTP注入　　293\n10.6　 小结　　294\n10.7　 问题　　294\n第11章　 攻击应用程序逻辑　　296\n11.1　 逻辑缺陷的本质　　296\n11.2　 现实中的逻辑缺陷　　297\n11.2.1　 例1：征求提示　　297\n11.2.2　 例2：欺骗密码修改功能　　298\n11.2.3　 例3：直接结算　　299\n11.2.4　 例4：修改保险单　　300\n11.2.5　 例5：入侵银行　　302\n11.2.6　 例6：规避交易限制　　303\n11.2.7　 例7：获得大幅折扣　　305\n11.2.8　 例8：避免转义　　305\n11.2.9　 例9：避开输入确认　　306\n11.2.10　 例10：滥用搜索功能　　308\n11.2.11　 例11：利用调试消息　　310\n11.2.12　 例12：与登录机制竞赛　　311\n11.3　 避免逻辑缺陷　　312\n11.4　 小结　　313\n11.5　 问题　　314\n第12章　 攻击其他用户　　315\n12.1　 XSS的分类　　316\n12.1.1　 反射型XSS漏洞　　316\n12.1.2　 保存型XSS漏洞　　320\n12.1.3　 基于DOM的XSS漏洞　　322\n12.2　 进行中的XSS攻击　　323\n12.2.1　 真实XSS攻击　　323\n12.2.2　 XSS攻击有效载荷　　324\n12.2.3　 XSS攻击的传送机制　　327\n12.3　 查找并利用XSS漏洞　　329\n12.3.1　 查找并利用反射型XSS漏洞　　331\n12.3.2　 查找并利用保存型XSS漏洞　　352\n12.3.3　 查找并利用基于DOM的XSS漏洞　　357\n12.4　 防止XSS攻击　　360\n12.4.1　 防止反射型与保存型XSS漏洞　　360\n12.4.2　 防止基于DOM的XSS漏洞　　364\n12.5　 小结　　365\n12.6　 问题　　365\n第13章　 攻击用户：其他技巧　　366\n13.1　 诱使用户执行操作　　366\n13.1.1　 请求伪造　　366\n13.1.2　 UI伪装　　374\n13.2　 跨域捕获数据　　377\n13.2.1　 通过注入HTML捕获数据　　377\n13.2.2　 通过注入CSS捕获数据　　378\n13.2.3　 JavaScript劫持　　380\n13.3　 同源策略深入讨论　　384\n13.3.1　 同源策略与浏览器扩展　　384\n13.3.2　 同源策略与HTML5　　386\n13.3.3　 通过代理服务应用程序跨域　　388\n13.4　 其他客户端注入攻击　　389\n13.4.1　 HTTP消息头注入　　389\n13.4.2　 cookie注入　　393\n13.4.3　 开放式重定向漏洞　　396\n13.4.4　 客户端SQL注入　　402\n13.4.5　 客户端HTTP参数污染　　402\n13.5　 本地隐私攻击　　403\n13.5.1　 持久性cookie　　404\n13.5.2　 缓存Web内容　　404\n13.5.3　 浏览历史记录　　405\n13.5.4　 自动完成　　406\n13.5.5　 Flash本地共享对象　　406\n13.5.6　 Silverlight独立存储　　406\n13.5.7　 Internet Explorer userData　　407\n13.5.8　 HTML5本地存储机制　　407\n13.5.9　 防止本地隐私攻击　　407\n13.6　 攻击ActiveX控件　　408\n13.6.1　 查找ActiveX漏洞　　409\n13.6.2　 防止ActiveX漏洞　　410\n13.7　 攻击浏览器　　411\n13.7.1　 记录键击　　411\n13.7.2　 窃取浏览器历史记录与搜索查询　　412\n13.7.3　 枚举当前使用的应用程序　　412\n13.7.4　 端口扫描　　412\n13.7.5　 攻击其他网络主机　　413\n13.7.6　 利用非HTTP服务　　413\n13.7.7　 利用浏览器漏洞　　414\n13.7.8　 DNS重新绑定　　414\n13.7.9　 浏览器利用框架　　415\n13.7.10　 中间人攻击　　416\n13.8　 小结　　418\n13.9　 问题　　418\n第14章　 定制攻击自动化　　419\n14.1　 应用定制自动化攻击　　419\n14.2　 枚举有效的标识符　　420\n14.2.1　 基本步骤　　420\n14.2.2　 探测“触点”　　421\n14.2.3　 编写攻击脚本　　422\n14.2.4　 JAttack　　423\n14.3　 获取有用的数据　　428\n14.4　 常见漏洞模糊测试　　431\n14.5　 整合全部功能：Burp Intruder　　434\n14.6　 实施自动化的限制　　442\n14.6.1　 会话处理机制　　443\n14.6.2　 CAPTCHA控件　　448\n14.7　 小结　　451\n14.8　 问题　　451\n第15章　 利用信息泄露　　453\n15.1　 利用错误消息　　453\n15.1.1　 错误消息脚本　　453\n15.1.2　 栈追踪　　454\n15.1.3　 详尽的调试消息　　455\n15.1.4　 服务器与数据库消息　　456\n15.1.5　 使用公共信息　　458\n15.1.6　 制造详尽的错误消息　　459\n15.2　 收集公布的信息　　460\n15.3　 使用推论　　461\n15.4　 防止信息泄露　　462\n15.4.1　 使用常规错误消息　　462\n15.4.2　 保护敏感信息　　462\n15.4.3　 尽量减少客户端信息泄露　　463\n15.5　 小结　　463\n15.6　 问题　　463\n第16章　 攻击本地编译型应用程序　　466\n16.1　 缓冲区溢出漏洞　　467\n16.1.1　 栈溢出　　467\n16.1.2　 堆溢出　　467\n16.1.3　 “一位偏移”漏洞　　468\n16.1.4　 查找缓冲区溢出漏洞　　470\n16.2　 整数漏洞　　472\n16.2.1　 整数溢出　　472\n16.2.2　 符号错误　　472\n16.2.3　 查找整数漏洞　　473\n16.3　 格式化字符串漏洞　　474\n16.4　 小结　　475\n16.5　 问题　　475\n第17章　 攻击应用程序架构　　477\n17.1　 分层架构　　477\n17.1.1　 攻击分层架构　　478\n17.1.2　 保障分层架构的安全　　482\n17.2　 共享主机与应用程序服务提供商　　483\n17.2.1　 虚拟主机　　484\n17.2.2　 共享的应用程序服务　　484\n17.2.3　 攻击共享环境　　485\n17.2.4　 保障共享环境的安全　　490\n17.3　 小结　　491\n17.4　 问题　　491\n第18章　 攻击Web服务器　　493\n18.1　 Web服务器配置缺陷　　493\n18.1.1　 默认证书　　493\n18.1.2　 默认内容　　494\n18.1.3　 目录列表　　499\n18.1.4　 WebDAV方法　　500\n18.1.5　 Web服务器作为代理服务器　　503\n18.1.6　 虚拟主机配置缺陷　　504\n18.1.7　 保障Web服务器配置的安全　　504\n18.2　 易受攻击的服务器软件　　505\n18.2.1　 应用程序框架缺陷　　505\n18.2.2　 内存管理漏洞　　507\n18.2.3　 编码与规范化漏洞　　508\n18.2.4　 查找Web服务器漏洞　　512\n18.2.5　 保障Web服务器软件的安全　　513\n18.3　 Web应用程序防火墙　　514\n18.4　 小结　　515\n18.5　 问题　　516\n第19章　 查找源代码中的漏洞　　517\n19.1　 代码审查方法　　517\n19.1.1  “黑盒”测试与“白盒”\n测试　　517\n19.1.2　 代码审查方法　　518\n19.2　 常见漏洞签名　　519\n19.2.1　 跨站点脚本　　519\n19.2.2　 SQL注入　　520\n19.2.3　 路径遍历　　520\n19.2.4　 任意重定向　　521\n19.2.5　 OS命令注入　　522\n19.2.6　 后门密码　　522\n19.2.7　 本地代码漏洞　　522\n19.2.8　 源代码注释　　524\n19.3　 Java平台　　524\n19.3.1　 确定用户提交的数据　　524\n19.3.2　 会话交互　　525\n19.3.3　 潜在危险的API　　526\n19.3.4　 配置Java环境　　528\n19.4　 ASP.NET　　529\n19.4.1　 确定用户提交的数据　　529\n19.4.2　 会话交互　　530\n19.4.3　 潜在危险的API　　531\n19.4.4　 配置ASP.NET环境　　533\n19.5　 PHP　　534\n19.5.1　 确定用户提交的数据　　534\n19.5.2　 会话交互　　536\n19.5.3　 潜在危险的API　　536\n19.5.4　 配置 PHP 环境　　540\n19.6　 Perl　　542\n19.6.1　 确定用户提交的数据　　542\n19.6.2　 会话交互　　543\n19.6.3　 潜在危险的API　　543\n19.6.4　 配置Perl环境　　544\n19.7　 JavaScript　　545\n19.8　 数据库代码组件　　546\n19.8.1　 SQL注入　　546\n19.8.2　 调用危险的函数　　547\n19.9　 代码浏览工具　　547\n19.10　 小结　　548\n19.11　 问题　　548\n第20章　 Web应用程序黑客工具包　　550\n20.1　 Web浏览器　　550\n20.1.1　 Internet Explorer　　550\n20.1.2　 Firefox　　551\n20.1.3　 Chrome　　552\n20.2　 集成测试套件　　552\n20.2.1　 工作原理　　553\n20.2.2　 测试工作流程　　566\n20.2.3　 拦截代理服务器替代工具　　568\n20.3　 独立漏洞扫描器　　570\n20.3.1　 扫描器探测到的漏洞　　570\n20.3.2　 扫描器的内在限制　　571\n20.3.3　 扫描器面临的技术挑战　　572\n20.3.4　 当前产品　　574\n20.3.5　 使用漏洞扫描器　　576\n20.4　 其他工具　　577\n20.4.1　 Wikto/Nikto　　577\n20.4.2　 Firebug　　577\n20.4.3　 Hydra　　578\n20.4.4　 定制脚本　　578\n20.5　 小结　　581\n第21章　 Web应用程序渗透测试方法论　　582\n21.1　 解析应用程序内容　　584\n21.1.1　 搜索可见的内容　　584\n21.1.2　 浏览公共资源　　585\n21.1.3　 发现隐藏的内容　　586\n21.1.4　 查找默认的内容　　586\n21.1.5　 枚举标识符指定的功能　　586\n21.1.6　 调试参数　　587\n21.2　 分析应用程序　　587\n21.2.1　 确定功能　　587\n21.2.2　 确定数据进入点　　587\n21.2.3　 确定所使用的技术　　588\n21.2.4　 解析受攻击面　　588\n21.3　 测试客户端控件　　588\n21.3.1　 通过客户端传送数据　　589\n21.3.2　 客户端输入控件　　589\n21.3.3　 测试浏览器扩展组件　　590\n21.4　 测试验证机制　　592\n21.4.1　 了解验证机制　　592\n21.4.2　 测试密码强度　　593\n21.4.3　 测试用户名枚举　　593\n21.4.4　 测试密码猜测的适应性　　593\n21.4.5　 测试账户恢复功能　　594\n21.4.6　 测试“记住我”功能　　594\n21.4.7　 测试伪装功能　　594\n21.4.8　 测试用户名唯一性　　595\n21.4.9　 测试证书的可预测性　　595\n21.4.10　 检测不安全的证书传输　　595\n21.4.11　 检测不安全的证书分配　　596\n21.4.12　 测试不安全的存储　　596\n21.4.13　 测试逻辑缺陷　　596\n21.4.14　 利用漏洞获取未授权访问　　597\n21.5　 测试会话管理机制　　598\n21.5.1　 了解会话管理机制　　598\n21.5.2　 测试令牌的含义　　599\n21.5.3　 测试令牌的可预测性　　599\n21.5.4　 检查不安全的令牌传输　　600\n21.5.5　 检查在日志中泄露的令牌　　600\n21.5.6　 测试令牌?会话映射　　601\n21.5.7　 测试会话终止　　601\n21.5.8　 测试会话固定　　602\n21.5.9　 检查 CSRF　　602\n21.5.10　 检查cookie范围　　602\n21.6　 测试访问控件　　603\n21.6.1　 了解访问控制要求　　603\n21.6.2　 使用多个账户测试　　604\n21.6.3　 使用有限的权限测试　　604\n21.6.4　 测试不安全的访问控制方法　　605\n21.7　 测试基于输入的漏洞　　605\n21.7.1　 模糊测试所有请求参数　　605\n21.7.2　 测试 SQL 注入　　607\n21.7.3　 测试 XSS和其他响应注入　　609\n21.7.4　 测试 OS 命令注入　　611\n21.7.5　 测试路径遍历　　612\n21.7.6　 测试脚本注入　　613\n21.7.7　 测试文件包含　　613\n21.8　 测试特殊功能方面的输入漏洞　　613\n21.8.1　 测试 SMTP 注入　　614\n21.8.2　 测试本地代码漏洞　　614\n21.8.3　 测试SOAP注入　　616\n21.8.4　 测试 LDAP 注入　　616\n21.8.5　 测试XPath注入　　617\n21.8.6　 测试后端请求注入　　617\n21.8.7　 测试XXE注入　　617\n21.9　 测试逻辑缺陷　　618\n21.9.1　 确定关键的受攻击面　　618\n21.9.2　 测试多阶段过程　　618\n21.9.3　 测试不完整的输入　　619\n21.9.4　 测试信任边界　　619\n21.9.5　 测试交易逻辑　　619\n21.10　 测试共享主机漏洞　　620\n21.10.1　 测试共享基础架构之间的隔离　　620\n21.10.2　 测试使用ASP主机的应用程序之间的隔离　　620\n21.11　 测试Web服务器漏洞　　621\n21.11.1　 测试默认证书　　621\n21.11.2　 测试默认内容　　621\n21.11.3　 测试危险的HTTP方法　　622\n21.11.4　 测试代理功能　　622\n21.11.5　 测试虚拟主机配置不当　　622\n21.11.6　 测试Web服务器软件漏洞　　622\n21.11.7　 测试Web应用程序防火墙　　623\n21.12　 其他检查　　623\n21.12.1　 测试基于 DOM 的攻击　　624\n21.12.2　 测试本地隐私漏洞　　624\n21.12.3　 测试脆弱的SSL加密算法　　625\n21.12.4　 检查同源策略配置　　625\n21.13　 检查信息泄露　　625\n",
        "pages": "625",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s10321223.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s10321223.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s10321223.jpg"
        },
        "alt": "https://book.douban.com/subject/10793814/",
        "id": "10793814",
        "publisher": "人民邮电出版社",
        "isbn10": "7115283923",
        "isbn13": "9787115283924",
        "title": "黑客攻防技术宝典（第2版）",
        "url": "https://api.douban.com/v2/book/10793814",
        "alt_title": "The Web Application Hacker’s Handbook",
        "author_intro": "作者简介：\nDafydd Stuttard 世界知名安全顾问、作家、软件开发人士。牛津大学博士，MDSec公司联合创始人，尤其擅长Web应用程序和编译软件的渗透测试。Dafydd以网名PortSwigger蜚声安全界，是众所周知的Web应用程序集成攻击平台Burp Suite的开发者。\nMarcus Pinto 资深渗透测试专家，剑桥大学硕士，MDSec公司联合创始人。Marcus为全球金融、政府、电信、博彩、零售等行业顶尖组织和机构提供Web应用程序渗透测试和安全防御的咨询与培训。",
        "summary": "内容简介：\nWeb应用无处不在，安全隐患如影随形。承载着丰富功能与用途的Web应用程序中布满了各种漏洞，攻击者能够利用这些漏洞盗取用户资料，实施诈骗，破坏其他系统等。近年来，一些公司的网络系统频频遭受攻击，导致用户信息泄露，造成不良影响。因此，如何确保Web应用程序的安全，已成为摆在人们眼前亟待解决的问题。\n本书是Web安全领域专家的经验结晶，系统阐述了如何针对Web应用程序展开攻击与反攻击，深入剖析了攻击时所使用的技巧、步骤和工具，条理清晰，内容详尽。第2版全面升级，涵盖了最新的攻击技巧与应对措施，此外，书中还列出了几百个“漏洞实验室”，以帮助读者对所学内容进行巩固和实战演习。",
        "series": {
          "id": "15610",
          "title": "黑客攻防技术宝典"
        },
        "price": "99.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "627ec7025446adddfc00512922bc4225a3b019a5a1b8d0d7fbc8d66ff022b048",
        "file": "黑客攻防技术宝典-web实战篇.epub"
      }
    ]
  },
  {
    "dir_name": "tools",
    "name": "工具",
    "books": [
      {
        "timestamp": "2016-05-01T11:38:44.164245+00:00",
        "publisher": "GitBook",
        "creator": "wizardforcel",
        "contributor": "GitBook",
        "description": "yangyangwithgnu@yeah.net2016-03-30 16:39:33",
        "language": "zh",
        "title": "像 IDE 一样使用 vim",
        "identifier": {
          "uuid": "d5e70717-6cb7-4a1f-89ca-f72c6067a75b"
        },
        "meta_type": "opf",
        "type": "epub",
        "sha_256": "9ab17fe27d4b0f051bc109273801fe25964b064b72bb588aae7b0faa4b95806d",
        "file": "use-vim-as-ide.epub"
      }
    ]
  },
  {
    "dir_name": "go",
    "name": "go",
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 459,
          "average": "7.1",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "许式伟"
        ],
        "pubdate": "2012-8",
        "tags": [
          {
            "count": 297,
            "name": "go语言",
            "title": "go语言"
          },
          {
            "count": 258,
            "name": "Go",
            "title": "Go"
          },
          {
            "count": 168,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 103,
            "name": "程序设计",
            "title": "程序设计"
          },
          {
            "count": 101,
            "name": "编程语言",
            "title": "编程语言"
          },
          {
            "count": 88,
            "name": "golang",
            "title": "golang"
          },
          {
            "count": 85,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 73,
            "name": "programming",
            "title": "programming"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/mpic/s11162016.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "序 为什么我们需要一门新的语言？\n第1章 初识Go语言\n1.1 Go语言简史\n1.2 语言特性\n1.3 “Hello, world!”\n1.4 编译环境\n1.5 开发工具\n1.6 工程管理\n1.7 问题追踪和调试\n1.8 如何寻求帮助\n本章小结\n第2章 顺序编程\n2.1 变量、常量和类型\n2.1.1 变量\n2.1.2 常量\n2.1.3 类型\n2.2 流程控制\n2.2.1 条件语句\n2.2.2 选择语句\n2.2.3 循环\n2.2.4 跳转语句\n2.3 函数\n2.3.1 函数调用\n2.3.2 不定参数\n2.3.3 多返回值\n2.3.4 匿名函数与闭包\n2.4 错误处理\n2.4.1 error接口\n2.4.2 defer\n2.4.3 panic和recover\n本章小结\n第3章 面向对象编程\n3.1 类型系统\n3.1.1 给类型添加方法\n3.1.2 值语义和引用语义\n3.2 结构体\n3.2.1 初始化\n3.2.2 匿名组合\n3.2.3 成员可访问性\n3.3 接口\n3.3.1 其他语言中的接口\n3.3.2 非侵入式接口\n3.3.3 接口赋值\n3.3.4 接口查询\n3.3.5 类型查询\n3.3.6 Any类型\n本章小结\n第4章 工程管理\n4.1 Go命令行工具\n4.2 代码风格\n4.3 工程组织\n4.4 单元测试\n4.5 文档管理\n4.6 工程构建\n4.7 包的管理与分发\n4.8 跨平台开发\n4.8.1 Go语言的跨平台能力\n4.8.2 交叉编译\n4.8.3 Android支持\n本章小结\n第5章 并发编程\n5.1 初识Goroutine\n5.1.1 基本用法\n5.1.2 Goroutine通信\n5.2 Channel\n5.2.1 基本用法\n5.2.2 关闭\n5.2.3 变量的传递\n5.2.4 单向Channel\n5.2.5 超时处理\n5.3 多核并行化\n5.4 同步机制\n5.4.1 sync包简介\n5.4.2 同步锁\n5.4.3 Once类型\n本章小结\n第6章 网络编程\n6.1 HTTP编程\n6.1.1 客户端编程\n6.1.2 开发HTTP服务器\n6.2 JSON\n6.2.1 JSON简介\n6.2.2 编码\n6.2.3 解码\n6.2.4 未知类型的解码\n6.2.5 流式读写\n6.3 网站开发\n6.3.1 一个最简单的网站\n6.3.2 开发一个相册网站\n6.3.2.1 新建工程\n6.3.2.2 实现网络服务\n6.3.2.3 网页模板渲染\n6.3.2.4 缓存\n6.3.2.5 错误处理\n6.3.2.6 防止程序崩溃\n6.3.2.7 资源分离\n6.3.2.8 重构\n6.4 更多资源\n本章小结\n第7章 进阶话题\n7.1 Go语言中的内存管理\n7.2 反射\n7.3 语言交互性CGO\n7.4 链接符号\n7.5 Goroutine实现机制\n7.6 接口的奥秘\n本章小结\n第8章 开发工具\n8.1 Go语言开发工具\n8.2 gEdit\n8.3 Goclipse - 使用Eclipse开发和调试Go程序\n8.4 VIM\n8.5 Nodepad++，Windows上的Go开发环境搭建\n8.6 GolangIDE\n本章小结\n附录 Go语言包参考",
        "pages": "300",
        "images": {
          "small": "https://img3.doubanio.com/spic/s11162016.jpg",
          "large": "https://img3.doubanio.com/lpic/s11162016.jpg",
          "medium": "https://img3.doubanio.com/mpic/s11162016.jpg"
        },
        "alt": "https://book.douban.com/subject/11577300/",
        "id": "11577300",
        "publisher": "人民邮电出版社",
        "isbn10": "7115290369",
        "isbn13": "9787115290366",
        "title": "Go语言圣经",
        "url": "https://api.douban.com/v2/book/11577300",
        "alt_title": "",
        "author_intro": "许式伟\n七牛云存储CEO，曾任盛大创新院资深研究员、金山软件技术总监、WPS Office 2005首席架构师。开源爱好者，发布过包括WINX、TPL等十余个C++开源项目，拥有超过15年的C/C++开发经验。在接触Go语言后即可被其大道至简、少即是多的设计哲学所倾倒。七牛云存储是国内第一个吃螃蟹的团队，核心服务完全采用Go语言实现。\n吕桂华\n七牛云存储联合创始人，曾在金山软件、盛大游戏等公司担任架构师和部门经理等职务，在企业级系统和大型网游平台领域有较多涉猎。拥有十余年的C/C++大型项目开发经验，也曾在Java和.NET平台上探索多年。同样被Go语言的魅力所吸引而不可自拔，希望能为推广这门优秀的语言尽自己的绵薄之力。",
        "summary": "这本书从整体的写作风格来说，会以介绍 Go 语言特性为主，示例则尽量采用作者平常的实践，而不是一个没有太大实际意义的语法示范样例。\n本书作者背景极强，许式伟为原金山WPS首席架构师、曾是盛大创新院研究员，目前是国内Go语言实践圈子公认的Go语言专家。参与本书写作的几位作者都是实际用Go语言开发的项目的开发人员，有较强的实战经验。\n本书以介绍Go语言特性为主，示例则尽量采用作者开发团队平常的实践，内容涉及内存管理（堆和栈）、错误处理、OOP、并发编程等关键话题。 这本书面向的读者是所有打算用Go语言的开发者，主要包括目前使用C、C++、Java、C#的开发人员，甚至一些Python、PHP开发人员也可能转为 Go 程序员。",
        "series": {
          "id": "13000",
          "title": "图灵原创"
        },
        "price": "49.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "ee5be2ee7d02706f8f8dc85999302577c7d5d3cc5c45db72c10725bf4e84f1a2",
        "file": "Go语言圣经-2018-01-12.epub"
      },
      {
        "title": "自己动手写Docker",
        "subtitle": "",
        "author": [
          "陈显鹭",
          "王炳燊",
          "秦妤嘉"
        ],
        "summary": "本书在详细分析Docker所依赖的技术栈的基础上，一步一步地通过代码实例，让读者可以自己循序渐进地用Go语言构建出一个容器的引擎。不同于其他Docker原理介绍或代码剖析的书籍，本书旨在提供给读者一条动手路线，一步一步地实现Docker的隔离性，构建Docker的镜像、容器的生命周期及Docker的网络等。本书涉及的代码都托管在GitHub上，读者可以对照书中的步骤从代码层面学习构建流程，从而精通整个容器技术栈。本书也对目前业界容器技术的方向和实现做了简单介绍，以加深读者对容器生态的认识和理解。\n本书适合对容器技术已经使用过或有一些了解，希望更深层次掌握容器技术原理和最佳实践的读者。",
        "publisher": "电子工业出版社",
        "isbn13": "9787121317866",
        "isbn10": "7121317869",
        "tags": [
          {
            "title": "docker",
            "name": "docker",
            "count": 88
          },
          {
            "title": "虚拟化",
            "name": "虚拟化",
            "count": 41
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 27
          },
          {
            "title": "go",
            "name": "go",
            "count": 24
          },
          {
            "title": "编程",
            "name": "编程",
            "count": 20
          },
          {
            "title": "Docker",
            "name": "Docker",
            "count": 20
          },
          {
            "title": "linux",
            "name": "linux",
            "count": 16
          },
          {
            "title": "计算机科学",
            "name": "计算机科学",
            "count": 11
          }
        ],
        "pubdate": "2017-7-1",
        "translator": [],
        "binding": "平装",
        "author_intro": "陈显鹭 阿里云高级研发工程师，对Docker有深入研究，是Docker多个项目的Contributor，专注于容器技术的编排与基础环境研究。爱好折腾源代码，热爱开源文化并积极参与社区开源项目的研发。\n王炳燊 阿里云研发工程师，具有丰富的Linux开发经验，对Docker有深入研究，多次提交Docker Patch。目前从事阿里云容器服务网络方案的设计与实现，专注于容器技术的基础环境研究。\n秦妤嘉阿里云高级研发工程师、DevOps工程师，有丰富的容器化持续集成和持续交付开发实战经验，进行过Jenkins源码分析改造和Jenkins插件开发。目前从事阿里云容器服务持续集成和持续交付方案的设计和实现。",
        "rating": {
          "average": 7.1,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 43.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "4a437118aee5eef675aacfbb12dd665b3eae72a65b66091286d8f18207cdff7f",
        "file": "自己动手写Docker.epub"
      }
    ]
  },
  {
    "dir_name": "ai",
    "name": "ai&ml",
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 10,
          "average": "9.5",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "Aurélien Géron"
        ],
        "pubdate": "2017-10-1",
        "tags": [
          {
            "count": 33,
            "name": "机器学习",
            "title": "机器学习"
          },
          {
            "count": 18,
            "name": "Python",
            "title": "Python"
          },
          {
            "count": 9,
            "name": "AI",
            "title": "AI"
          },
          {
            "count": 8,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 4,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 2,
            "name": "英语",
            "title": "英语"
          },
          {
            "count": 2,
            "name": "百科",
            "title": "百科"
          },
          {
            "count": 2,
            "name": "数据分析",
            "title": "数据分析"
          }
        ],
        "origin_title": "Hands-On Machine Learning with Scikit-Learn &TensorFlow",
        "image": "https://img3.doubanio.com/view/subject/m/public/s29559435.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "",
        "pages": "",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s29559435.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s29559435.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s29559435.jpg"
        },
        "alt": "https://book.douban.com/subject/27154347/",
        "id": "27154347",
        "publisher": "东南大学出版社",
        "isbn10": "7564173718",
        "isbn13": "9787564173715",
        "title": "Scikit-Learn与TensorFlow机器学习实用指南",
        "url": "https://api.douban.com/v2/book/27154347",
        "alt_title": "Hands-On Machine Learning with Scikit-Learn &TensorFlow",
        "author_intro": "Aurélien Géron，是一名机器学习顾问。作为一名前Google职员，在2013至2016年间，他领导了YouTube视频分类团队。在2002至2012年间，他身为法国主要的无线ISP Wifirst的创始人和CTO，在2001年他还是Polyconseil的创始人和CTO，这家公司现在管理着电动汽车共享服务Autolib'。",
        "summary": "通过具体的例子、很少的理论以及两款成熟的Python框架：Scikit-Learn和TensorFlow，作者Aurélien Géron会帮助你掌握构建智能系统所需要的概念和工具。你将会学习到各种技术，从简单的线性回归及发展到深度神经网络。每章的练习有助于你运用所学到的知识，你只需要有一些编程经验就行了。\n探索机器学习，尤其是神经网络\n使用Scikit-Learn全程跟踪一个机器学习项目的例子\n探索各种训练模型，包括：支持向量机、决策树、随机森林以及集成方法\n使用TensorFlow库构建和训练神经网络\n深入神经网络架构，包括卷积神经网络、循环神经网络和深度强化学习\n学习可用于训练和缩放深度神经网络的技术\n运用实际的代码示例，无需了解过多的机器学习理论或算法细节",
        "price": "98.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "28ee4cbad6e4dcaa68fe0263353d4e8146176735f51d59edd9ed64af4f267009",
        "file": "Hands-On Machine Learning with Scikit-Learn and TensorFlow.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 601,
          "average": "9.6",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "[美] 弗朗索瓦•肖莱"
        ],
        "pubdate": "2018-8",
        "tags": [
          {
            "count": 1124,
            "name": "深度学习",
            "title": "深度学习"
          },
          {
            "count": 933,
            "name": "Python",
            "title": "Python"
          },
          {
            "count": 683,
            "name": "人工智能",
            "title": "人工智能"
          },
          {
            "count": 619,
            "name": "机器学习",
            "title": "机器学习"
          },
          {
            "count": 525,
            "name": "python",
            "title": "python"
          },
          {
            "count": 353,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 350,
            "name": "Keras",
            "title": "Keras"
          },
          {
            "count": 342,
            "name": "神经网络",
            "title": "神经网络"
          }
        ],
        "origin_title": "Deep Learning with Python",
        "image": "https://img1.doubanio.com/view/subject/m/public/s29839337.jpg",
        "binding": "平装",
        "translator": [
          "张亮"
        ],
        "catalog": "第一部分　深度学习基础\n第1章　什么是深度学习　　2\n1.1　人工智能、机器学习与深度学习　　2\n1.1.1　人工智能　　3\n1.1.2　机器学习　　3\n1.1.3　从数据中学习表示　　4\n1.1.4　深度学习之“深度”　　6\n1.1.5　用三张图理解深度学习的工作原理　　7\n1.1.6　深度学习已经取得的进展　　9\n1.1.7　不要相信短期炒作　　9\n1.1.8　人工智能的未来　　10\n1.2　深度学习之前：机器学习简史　　11\n1.2.1　概率建模　　11\n1.2.2　早期神经网络　　11\n1.2.3　核方法　　12\n1.2.4　决策树、随机森林与梯度提升机　　13\n1.2.5　回到神经网络　　14\n1.2.6　深度学习有何不同　　14\n1.2.7　机器学习现状　　15\n1.3　为什么是深度学习，为什么是现在　　15\n1.3.1　硬件　　16\n1.3.2　数据　　17\n1.3.3　算法　　17\n1.3.4　新的投资热潮　　17\n1.3.5　深度学习的大众化　　18\n1.3.6　这种趋势会持续吗　　18\n第2章　神经网络的数学基础　　20\n2.1　初识神经网络　　20\n2.2　神经网络的数据表示　　23\n2.2.1　标量（0D张量）　　23\n2.2.2　向量（1D张量）　　24\n2.2.3　矩阵（2D张量）　　24\n2.2.4　3D张量与更高维张量　　24\n2.2.5　关键属性　　25\n2.2.6　在Numpy中操作张量　　26\n2.2.7　数据批量的概念　　27\n2.2.8　现实世界中的数据张量　　27\n2.2.9　向量数据　　27\n2.2.10　时间序列数据或序列数据　　28\n2.2.11　图像数据　　28\n2.2.12　视频数据　　29\n2.3　神经网络的“齿轮”：张量运算　　29\n2.3.1　逐元素运算　　30\n2.3.2　广播　　31\n2.3.3　张量点积　　32\n2.3.4　张量变形　　34\n2.3.5　张量运算的几何解释　　34\n2.3.6　深度学习的几何解释　　35\n2.4　神经网络的“引擎”：基于梯度的优化　　36\n2.4.1　什么是导数　　37\n2.4.2　张量运算的导数：梯度　　38\n2.4.3　随机梯度下降　　38\n2.4.4　链式求导：反向传播算法　　41\n2.5　回顾第一个例子　　41\n本章小结　　42\n第3章　神经网络入门　　43\n3.1　神经网络剖析　　43\n3.1.1　层：深度学习的基础组件　　44\n3.1.2　模型：层构成的网络　　45\n3.1.3　损失函数与优化器：配置学习过程的关键　　45\n3.2　Keras简介　　46\n3.2.1　Keras、TensorFlow、Theano 和CNTK　　47\n3.2.2　使用Keras 开发：概述　　48\n3.3　建立深度学习工作站　　49\n3.3.1　Jupyter笔记本：运行深度学习实验的首选方法　　49\n3.3.2　运行Keras：两种选择　　50\n3.3.3　在云端运行深度学习任务：优点和缺点　　50\n3.3.4　深度学习的最佳GPU　　50\n3.4　电影评论分类：二分类问题　　51\n3.4.1　IMDB 数据集　　51\n3.4.2　准备数据　　52\n3.4.3　构建网络　　52\n3.4.4　验证你的方法　　56\n3.4.5　使用训练好的网络在新数据上生成预测结果　　59\n3.4.6　进一步的实验　　59\n3.4.7　小结　　59\n3.5　新闻分类：多分类问题　　59\n3.5.1　路透社数据集　　60\n3.5.2　准备数据　　61\n3.5.3　构建网络　　61\n3.5.4　验证你的方法　　62\n3.5.5　在新数据上生成预测结果　　65\n3.5.6　处理标签和损失的另一种方法　　65\n3.5.7　中间层维度足够大的重要性　　65\n3.5.8　进一步的实验　　66\n3.5.9　小结　　66\n3.6　预测房价：回归问题　　66\n3.6.1　波士顿房价数据集　　67\n3.6.2　准备数据　　67\n3.6.3　构建网络　　68\n3.6.4　利用K折验证来验证你的方法　　68\n3.6.5　小结　　72\n本章小结　　73\n第4章　机器学习基础　　74\n4.1　机器学习的四个分支　　74\n4.1.1　监督学习　　74\n4.1.2　无监督学习　　75\n4.1.3　自监督学习　　75\n4.1.4　强化学习　　75\n4.2　评估机器学习模型　　76\n4.2.1　训练集、验证集和测试集　　77\n4.2.2　评估模型的注意事项　　80\n4.3　数据预处理、特征工程和特征学习　　80\n4.3.1　神经网络的数据预处理　　80\n4.3.2　特征工程　　81\n4.4　过拟合与欠拟合　　83\n4.4.1　减小网络大小　　83\n4.4.2　添加权重正则化　　85\n4.4.3　添加dropout正则化　　87\n4.5　机器学习的通用工作流程　　89\n4.5.1　定义问题，收集数据集　　89\n4.5.2　选择衡量成功的指标　　89\n4.5.3　确定评估方法　　90\n4.5.4　准备数据　　90\n4.5.5　开发比基准更好的模型　　90\n4.5.6　扩大模型规模：开发过拟合的模型　　91\n4.5.7　模型正则化与调节超参数　　92\n本章小结　　92\n第二部分　深度学习实践\n第5章　深度学习用于计算机视觉　　94\n5.1　卷积神经网络简介　　94\n5.1.1　卷积运算　　96\n5.1.2　最大池化运算　　101\n5.2　在小型数据集上从头开始训练一个卷积神经网络　　102\n5.2.1　深度学习与小数据问题的相关性　　103\n5.2.2　下载数据　　103\n5.2.3　构建网络　　106\n5.2.4　数据预处理　　107\n5.2.5　使用数据增强　　111\n5.3　使用预训练的卷积神经网络　　115\n5.3.1　特征提取　　116\n5.3.2　微调模型　　124\n5.3.3　小结　　130\n5.4　卷积神经网络的可视化　　130\n5.4.1　可视化中间激活　　131\n5.4.2　可视化卷积神经网络的过滤器　　136\n5.4.3　可视化类激活的热力图　　142\n本章小结　　146\n第6章　深度学习用于文本和序列　　147\n6.1　处理文本数据　　147\n6.1.1　单词和字符的one-hot编码　　149\n6.1.2　使用词嵌入　　151\n6.1.3　整合在一起：从原始文本到词嵌入　　155\n6.1.4　小结　　162\n6.2　理解循环神经网络　　162\n6.2.1　Keras中的循环层　　164\n6.2.2　理解LSTM层和GRU层　　168\n6.2.3　Keras中一个LSTM的具体例子　　170\n6.2.4　小结　　172\n6.3　循环神经网络的高级用法　　172\n6.3.1　温度预测问题　　172\n6.3.2　准备数据　　175\n6.3.3　一种基于常识的、非机器学习的基准方法　　177\n6.3.4　一种基本的机器学习方法　　178\n6.3.5　第一个循环网络基准　　180\n6.3.6　使用循环dropout来降低过拟合　　181\n6.3.7　循环层堆叠　　182\n6.3.8　使用双向RNN　　184\n6.3.9　更多尝试　　187\n6.3.10　小结　　187\n6.4　用卷积神经网络处理序列　　188\n6.4.1　理解序列数据的一维卷积　　188\n6.4.2　序列数据的一维池化　　189\n6.4.3　实现一维卷积神经网络　　189\n6.4.4　结合CNN和RNN来处理长序列　　191\n6.4.5　小结　　195\n本章总结　　195\n第7章　高级的深度学习最佳实践　　196\n7.1　不用Sequential模型的解决方案：Keras 函数式API　　196\n7.1.1　函数式API简介　　199\n7.1.2　多输入模型　　200\n7.1.3　多输出模型　　202\n7.1.4　层组成的有向无环图　　204\n7.1.5　共享层权重　　208\n7.1.6　将模型作为层　　208\n7.1.7　小结　　209\n7.2　使用Keras回调函数和TensorBoard来检查并监控深度学习模型　　210\n7.2.1　训练过程中将回调函数作用于模型　　210\n7.2.2　TensorBoard简介：TensorFlow的可视化框架　　212\n7.2.3　小结　　219\n7.3　让模型性能发挥到极致　　219\n7.3.1　高级架构模式　　219\n7.3.2　超参数优化　　222\n7.3.3　模型集成　　223\n7.3.4　小结　　224\n本章总结　　225\n第8章　生成式深度学习　　226\n8.1　使用LSTM生成文本　　227\n8.1.1　生成式循环网络简史　　227\n8.1.2　如何生成序列数据　　228\n8.1.3　采样策略的重要性　　229\n8.1.4　实现字符级的LSTM文本生成　　230\n8.1.5　小结　　234\n8.2　DeepDream　　235\n8.2.1　用Keras实现DeepDream　　236\n8.2.2　小结　　241\n8.3　神经风格迁移　　241\n8.3.1　内容损失　　242\n8.3.2　风格损失　　243\n8.3.3　用Keras实现神经风格迁移　　243\n8.3.4　小结　　249\n8.4　用变分自编码器生成图像　　249\n8.4.1　从图像的潜在空间中采样　　249\n8.4.2　图像编辑的概念向量　　250\n8.4.3　变分自编码器　　251\n8.4.4　小结　　256\n8.5　生成式对抗网络简介　　257\n8.5.1　GAN 的简要实现流程　　258\n8.5.2　大量技巧　　259\n8.5.3　生成器　　260\n8.5.4　判别器　　261\n8.5.5　对抗网络　　261\n8.5.6　如何训练DCGAN　　262\n8.5.7　小结　　264\n本章总结　　264\n第9章　总结　　265\n9.1　重点内容回顾　　265\n9.1.1　人工智能的各种方法　　265\n9.1.2　深度学习在机器学习领域中的特殊之处　　266\n9.1.3　如何看待深度学习　　266\n9.1.4　关键的推动技术　　267\n9.1.5　机器学习的通用工作流程　　268\n9.1.6　关键网络架构　　268\n9.1.7　可能性空间　　272\n9.2　深度学习的局限性　　273\n9.2.1　将机器学习模型拟人化的风险　　273\n9.2.2　局部泛化与极端泛化　　275\n9.2.3　小结　　276\n9.3　深度学习的未来　　277\n9.3.1　模型即程序　　277\n9.3.2　超越反向传播和可微层　　278\n9.3.3　自动化机器学习　　279\n9.3.4　终身学习与模块化子程序复用　　279\n9.3.5　长期愿景　　281\n9.4　了解一个快速发展领域的最新进展　　281\n9.4.1　使用Kaggle练习解决现实世界的问题　　281\n9.4.2　在arXiv阅读最新进展　　282\n9.4.3　探索Keras生态系统　　282\n9.5　结束语　　282\n附录A　在Ubuntu上安装Keras及其依赖　　283\n附录B　在EC2 GPU实例上运行Jupyter笔记本　　287",
        "pages": "292",
        "images": {
          "small": "https://img1.doubanio.com/view/subject/s/public/s29839337.jpg",
          "large": "https://img1.doubanio.com/view/subject/l/public/s29839337.jpg",
          "medium": "https://img1.doubanio.com/view/subject/m/public/s29839337.jpg"
        },
        "alt": "https://book.douban.com/subject/30293801/",
        "id": "30293801",
        "publisher": "人民邮电出版社",
        "isbn10": "7115488762",
        "isbn13": "9787115488763",
        "title": "Python深度学习",
        "url": "https://api.douban.com/v2/book/30293801",
        "alt_title": "Deep Learning with Python",
        "author_intro": "【作者简介】\n弗朗索瓦•肖莱（François Chollet）\nKeras之父，TensorFlow机器学习框架贡献者，Kaggle竞赛教练，个人Kaggle竞赛全球排名曾获得第17名。目前任职于Google，从事人工智能研究，尤其关注计算机视觉与机器学习在形式推理方面的应用。\n【译者简介】\n张亮（hysic）\n毕业于北京大学物理学院，爱好机器学习和数据分析的核安全工程师，译有《Python数据处理》《Python机器学习基础教程》等。",
        "summary": "本书由Keras之父、现任Google人工智能研究员的弗朗索瓦•肖莱（François Chollet）执笔，详尽介绍了用Python和Keras进行深度学习的探索实践，涉及计算机视觉、自然语言处理、生成式模型等应用。书中包含30多个代码示例，步骤讲解详细透彻。由于本书立足于人工智能的可达性和大众化，读者无须具备机器学习相关背景知识即可展开阅读。在学习完本书后，读者将具备搭建自己的深度学习环境、建立图像识别模型、生成图像和文字等能力。",
        "series": {
          "id": "660",
          "title": "图灵程序设计丛书"
        },
        "price": "119.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "eeb3131f3ea6fc4972aa40be8485397169f0d5ac4997b90658460454ac4b8c1c",
        "file": "Python深度学习.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 28,
          "average": "9.4",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "吴茂贵",
          "郁明敏",
          "杨本法",
          "李涛",
          "张粤磊"
        ],
        "pubdate": "2019-11-1",
        "tags": [
          {
            "count": 20,
            "name": "深度学习",
            "title": "深度学习"
          },
          {
            "count": 13,
            "name": "Pytorch",
            "title": "Pytorch"
          },
          {
            "count": 12,
            "name": "机器学习",
            "title": "机器学习"
          },
          {
            "count": 10,
            "name": "人工智能",
            "title": "人工智能"
          },
          {
            "count": 8,
            "name": "好书！",
            "title": "好书！"
          },
          {
            "count": 7,
            "name": "好书，值得一读",
            "title": "好书，值得一读"
          },
          {
            "count": 6,
            "name": "编程",
            "title": "编程"
          },
          {
            "count": 6,
            "name": "pytorch",
            "title": "pytorch"
          }
        ],
        "origin_title": "",
        "image": "https://img9.doubanio.com/view/subject/m/public/s33511165.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "Contents  目　　录\n前言\n第一部分　PyTorch基础\n第1章　Numpy基础2\n1.1　生成Numpy数组3\n1.1.1　从已有数据中创建数组3\n1.1.2　利用random模块生成数组4\n1.1.3　创建特定形状的多维数组5\n1.1.4　利用arange、linspace函数生成数组6\n1.2　获取元素7\n1.3　Numpy的算术运算9\n1.3.1　对应元素相乘9\n1.3.2　点积运算10\n1.4　数组变形11\n1.4.1　更改数组的形状11\n1.4.2　合并数组14\n1.5　批量处理16\n1.6　通用函数17\n1.7　广播机制19\n1.8　小结20\n第2章　PyTorch基础21\n2.1　为何选择PyTorch？21\n2.2　安装配置22\n2.2.1　安装CPU版PyTorch22\n2.2.2　安装GPU版PyTorch24\n2.3　Jupyter Notebook环境配置26\n2.4　Numpy与Tensor28\n2.4.1　Tensor概述28\n2.4.2　创建Tensor28\n2.4.3　修改Tensor形状30\n2.4.4　索引操作31\n2.4.5　广播机制32\n2.4.6　逐元素操作32\n2.4.7　归并操作33\n2.4.8　比较操作34\n2.4.9　矩阵操作35\n2.4.10　PyTorch与Numpy比较35\n2.5　Tensor与Autograd36\n2.5.1　自动求导要点36\n2.5.2　计算图37\n2.5.3　标量反向传播38\n2.5.4　非标量反向传播39\n2.6　使用Numpy实现机器学习41\n2.7　使用Tensor及Antograd实现机器学习44\n2.8　使用TensorFlow架构46\n2.9　小结48\n第3章　PyTorch神经网络工具箱49\n3.1　神经网络核心组件49\n3.2　实现神经网络实例50\n3.2.1　背景说明51\n3.2.2　准备数据52\n3.2.3　可视化源数据53\n3.2.4　构建模型53\n3.2.5　训练模型54\n3.3　如何构建神经网络？56\n3.3.1　构建网络层56\n3.3.2　前向传播57\n3.3.3　反向传播57\n3.3.4　训练模型58\n3.4　神经网络工具箱nn58\n3.4.1　nn.Module58\n3.4.2　nn.functional58\n3.5　优化器59\n3.6　动态修改学习率参数60\n3.7　优化器比较60\n3.8　小结62\n第4章　PyTorch数据处理工具箱63\n4.1　数据处理工具箱概述63\n4.2　utils.data简介64\n4.3　torchvision简介66\n4.3.1　transforms67\n4.3.2　ImageFolder67\n4.4　可视化工具69\n4.4.1　tensorboardX简介69\n4.4.2　用tensorboardX可视化神经网络71\n4.4.3　用tensorboardX可视化损失值72\n4.4.4　用tensorboardX可视化特征图73\n4.5　本章小结74\n第二部分　深度学习基础\n第5章　机器学习基础76\n5.1　机器学习的基本任务76\n5.1.1　监督学习77\n5.1.2　无监督学习77\n5.1.3　半监督学习78\n5.1.4　强化学习78\n5.2　机器学习一般流程78\n5.2.1　明确目标79\n5.2.2　收集数据79\n5.2.3　数据探索与预处理79\n5.2.4　选择模型及损失函数80\n5.2.5　评估及优化模型81\n5.3　过拟合与欠拟合81\n5.3.1　权重正则化82\n5.3.2　Dropout正则化83\n5.3.3　批量正则化86\n5.3.4　权重初始化88\n5.4　选择合适激活函数89\n5.5　选择合适的损失函数90\n5.6　选择合适优化器92\n5.6.1　传统梯度优化的不足93\n5.6.2　动量算法94\n5.6.3　AdaGrad算法96\n5.6.4　RMSProp算法97\n5.6.5　Adam算法98\n5.7　GPU加速99\n5.7.1　单GPU加速100\n5.7.2　多GPU加速101\n5.7.3　使用GPU注意事项104\n5.8　本章小结104\n第6章　视觉处理基础105\n6.1　卷积神经网络简介105\n6.2　卷积层107\n6.2.1　卷积核108\n6.2.2　步幅109\n6.2.3　填充111\n6.2.4　多通道上的卷积111\n6.2.5　激活函数113\n6.2.6　卷积函数113\n6.2.7　转置卷积114\n6.3　池化层115\n6.3.1　局部池化116\n6.3.2　全局池化117\n6.4　现代经典网络119\n6.4.1　LeNet-5模型119\n6.4.2　AlexNet模型120\n6.4.3　VGG模型121\n6.4.4　GoogleNet模型122\n6.4.5　ResNet模型123\n6.4.6　胶囊网络简介124\n6.5　PyTorch实现CIFAR-10多分类125\n6.5.1　数据集说明125\n6.5.2　加载数据125\n6.5.3　构建网络127\n6.5.4　训练模型128\n6.5.5　测试模型129\n6.5.6　采用全局平均池化130\n6.5.7　像Keras一样显示各层参数131\n6.6　模型集成提升性能133\n6.6.1　使用模型134\n6.6.2　集成方法134\n6.6.3　集成效果135\n6.7　使用现代经典模型提升性能136\n6.8　本章小结137\n第7章　自然语言处理基础138\n7.1　循环神经网络基本结构138\n7.2　前向传播与随时间反向传播140\n7.3　循环神经网络变种143\n7.3.1　LSTM144\n7.3.2　GRU145\n7.3.3　Bi-RNN146\n7.4　循环神经网络的PyTorch实现146\n7.4.1　RNN实现147\n7.4.2　LSTM实现149\n7.4.3　GRU实现151\n7.5　文本数据处理152\n7.6　词嵌入153\n7.6.1　Word2Vec原理154\n7.6.2　CBOW模型155\n7.6.3　Skip-Gram模型155\n7.7　PyTorch实现词性判别156\n7.7.1　词性判别主要步骤156\n7.7.2　数据预处理157\n7.7.3　构建网络157\n7.7.4　训练网络158\n7.7.5　测试模型160\n7.8　用LSTM预测股票行情160\n7.8.1　 导入数据160\n7.8.2　数据概览161\n7.8.3　预处理数据162\n7.8.4　定义模型163\n7.8.5　训练模型163\n7.8.6　测试模型164\n7.9　循环神经网络应用场景165\n7.10　小结166\n第8章　生成式深度学习167\n8.1　用变分自编码器生成图像167\n8.1.1　自编码器168\n8.1.2　变分自编码器168\n8.1.3　用变分自编码器生成图像169\n8.2　GAN简介173\n8.2.1　GAN架构173\n8.2.2　GAN的损失函数174\n8.3　用GAN生成图像175\n8.3.1　判别器175\n8.3.2　生成器175\n8.3.3　训练模型175\n8.3.4　可视化结果177\n8.4　VAE与GAN的优缺点178\n8.5　ConditionGAN179\n8.5.1　CGAN的架构179\n8.5.2　CGAN生成器180\n8.5.3　CGAN判别器180\n8.5.4　CGAN损失函数181\n8.5.5　CGAN可视化181\n8.5.6　查看指定标签的数据182\n8.5.7　可视化损失值182\n8.6　DCGAN183\n8.7　提升GAN训练效果的一些技巧184\n8.8　小结185\n第三部分　深度学习实践\n第9章　人脸检测与识别188\n9.1　人脸识别一般流程188\n9.2　人脸检测189\n9.2.1　目标检测189\n9.2.2　人脸定位191\n9.2.3　人脸对齐191\n9.2.4　MTCNN算法192\n9.3　特征提取193\n9.4　人脸识别198\n9.4.1　人脸识别主要原理198\n9.4.2　人脸识别发展198\n9.5　PyTorch实现人脸检测与识别199\n9.5.1　验证检测代码199\n9.5.2　检测图像200\n9.5.3　检测后进行预处理200\n9.5.4　查看经检测后的图像201\n9.5.5　人脸识别202\n9.6　小结202\n第10章　迁移学习实例203\n10.1　迁移学习简介203\n10.2　特征提取204\n10.2.1　PyTorch提供的预处理模块205\n10.2.2　特征提取实例206\n10.3　数据增强209\n10.3.1　按比例缩放209\n10.3.2　裁剪210\n10.3.3　翻转210\n10.3.4　改变颜色211\n10.3.5　组合多种增强方法211\n10.4　微调实例212\n10.4.1　数据预处理212\n10.4.2　加载预训练模型213\n10.4.3　修改分类器213\n10.4.4　选择损失函数及优化器213\n10.4.5　训练及验证模型214\n10.5　清除图像中的雾霾214\n10.6　小结217\n第11章　神经网络机器翻译实例218\n11.1　Encoder-Decoder模型原理218\n11.2　注意力框架220\n11.3　PyTorch实现注意力Decoder224\n11.3.1　构建Encoder224\n11.3.2　构建简单Decoder225\n11.3.3　构建注意力Decoder226\n11.4　用注意力机制实现中英文互译227\n11.4.1　导入需要的模块228\n11.4.2　数据预处理228\n11.4.3　构建模型231\n11.4.4　训练模型234\n11.4.5　随机采样，对模型进行测试235\n11.4.6　可视化注意力236\n11.5　小结237\n第12章　实战生成式模型238\n12.1　DeepDream模型238\n12.1.1　Deep Dream原理238\n12.1.2　DeepDream算法流程239\n12.1.3　用PyTorch实现Deep Dream240\n12.2　风格迁移243\n12.2.1　内容损失244\n12.2.2　风格损失245\n12.2.3　用PyTorch实现神经网络风格迁移247\n12.3　PyTorch实现图像修复252\n12.3.1　网络结构252\n12.3.2　损失函数252\n12.3.3　图像修复实例253\n12.4　PyTorch实现DiscoGAN255\n12.4.1　DiscoGAN架构256\n12.4.2　损失函数258\n12.4.3　DiscoGAN实现258\n12.4.4　用PyTorch实现从边框生成鞋子260\n12.5　小结262\n第13章　Caffe2模型迁移实例263\n13.1　Caffe2简介263\n13.2　Caffe如何升级到Caffe2264\n13.3　PyTorch如何迁移到Caffe2265\n13.4　小结268\n第14章　AI新方向：对抗攻击269\n14.1　对抗攻击简介269\n14.1.1　白盒攻击与黑盒攻击270\n14.1.2　无目标攻击与有目标攻击270\n14.2　常见对抗样本生成方式271\n14.2.1　快速梯度符号法271\n14.2.2　快速梯度算法271\n14.3　PyTorch实现对抗攻击272\n14.3.1　实现无目标攻击272\n14.3.2　实现有目标攻击274\n14.4　对抗攻击和防御措施276\n14.4.1　对抗攻击276\n14.4.2　常见防御方法分类276\n14.5　总结277\n第15章　强化学习278\n15.1　强化学习简介278\n15.2　Q-Learning原理281\n15.2.1　Q-Learning主要流程281\n15.2.2　Q函数282\n15.2.3　贪婪策略283\n15.3　用PyTorch实现Q-Learning283\n15.3.1　定义Q-Learing主函数283\n15.3.2　执行Q-Learing284\n15.4　SARSA算法285\n15.4.1　SARSA算法主要步骤285\n15.4.2　用PyTorch实现SARSA算法286\n15.5　小结287\n第16章　深度强化学习288\n16.1　DQN算法原理288\n16.1.1　Q-Learning方法的局限性289\n16.1.2　用DL处理RL需要解决的问题289\n16.1.3　用DQN解决方法289\n16.1.4　定义损失函数290\n16.1.5　DQN的经验回放机制290\n16.1.6　目标网络290\n16.1.7　网络模型291\n16.1.8　DQN算法291\n16.2　用PyTorch实现DQN算法292\n16.3　小结295\n附录A　PyTorch0.4版本变更296\n附录B　AI在各行业的最新应用301",
        "ebook_url": "https://read.douban.com/ebook/125619299/",
        "pages": "307",
        "images": {
          "small": "https://img9.doubanio.com/view/subject/s/public/s33511165.jpg",
          "large": "https://img9.doubanio.com/view/subject/l/public/s33511165.jpg",
          "medium": "https://img9.doubanio.com/view/subject/m/public/s33511165.jpg"
        },
        "alt": "https://book.douban.com/subject/34873001/",
        "id": "34873001",
        "publisher": "机械工业出版社",
        "isbn10": "7111637178",
        "isbn13": "9787111637172",
        "title": "Python深度学习：基于PyTorch",
        "url": "https://api.douban.com/v2/book/34873001",
        "alt_title": "",
        "author_intro": "★吴茂贵\n资深大数据和人工智能技术专家，就职于中国外汇交易中心，在BI、数据挖掘与分析、数据仓库、机器学习等领域工作超过20年。在基于Spark、TensorFlow、PyTorch、Keras等的机器学习和深度学习方面有大量的工程实践实践。著有《Python深度学习：基于TensorFlow》《深度实践Spark机器学习》《自己动手做大数据系统》等著作。\n★郁明敏\n资深商业分析师，从事互联网金融算法研究工作，专注于大数据、机器学习以及数据可视化的相关领域，擅长 Python、Hadoop、Spark 等技术，拥有丰富的实战经验。曾获“江苏省TI杯大学生电子竞技大赛”二等奖和“华为杯全国大学生数学建模大赛”二等奖。\n★杨本法\n高级算法工程师，在流程优化、数据分析、数据挖掘等领域有10余年实战经验，熟悉Hadoop和Spark技术栈。有大量工程实践经验，做过的项目包括：推荐系统、销售预测系统、舆情监控系统、拣货系统、报表可视化、配送路线优化系统等。\n★李涛\n资深AI技术工程师，对PyTorch、Caffe、TensorFlow等深度学习框架以及计算机视觉技术有深刻的理解和丰富的实践经验，曾经参与和主导过服务机器人、无人售后店、搜索排序等多个人工智能相关的项目。\n★张粤磊\n资深大数据技术专家，飞谷云创始人，有10余年一线数据数据挖掘与分析实战经验。先后在咨询、金融、互联网行业担任大数据平台的技术负责人或架构师。",
        "summary": "这是一本基于最新的Python和PyTorch版本的深度学习著作，旨在帮助读者低门槛进入深度学习领域，轻松速掌握深度学习的理论知识和实践方法，快速实现从入门到进阶的转变。\n本书是多位人工智能技术专家和大数据技术专家多年工作经验的结晶，从工具使用、技术原理、算法设计、案例实现等多个维度对深度学习进行了系统的讲解。内容选择上，广泛涉猎、重点突出、注重实战；内容安排上，实例切入、由浅入深、循序渐进；表达形式上，深度抽象、化繁为简、用图说话。\n本书共16章，分为三部分：\n第一部分（第1~4章） PyTorch基础\n首先讲解了机器学习和数据科学中必然会用到的工具Numpy的使用，然后从多个角度讲解了Pytorch的必备基础知识，最后详细讲解了Pytorch的神经网络工具箱和数据处理工具箱。\n第二部分（第5~8章） 深度学习基础\n\n这部分从技术原理、算法设计、实践技巧等维度讲解了机器学习和深度学习的经典理理论、算法以及提升深度学习模型性能的多种技巧，涵盖视觉处理、NLP和生成式深度学习等主题。\n第三部分（第9~16章） 深度学习实践\n这部分从工程实践的角度讲解了深度学习的工程方法和在一些热门领域的实践方案，具体包括人脸识别、图像修复、图像增强、风格迁移、中英文互译、生成式对抗网络、对抗攻击、强化学习、深度强化学习等内容。",
        "ebook_price": "45.00",
        "series": {
          "id": "42106",
          "title": "智能系统与技术丛书"
        },
        "price": "89元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "369b74280df361f5e00bf4d07ccfcd2a261d741c79a8a0cf164a8a118a78d47a",
        "file": "Python深度学习：基于TensorFlow.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 180,
          "average": "9.0",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "【美】Betsy Beyer（贝特西 拜尔）等"
        ],
        "pubdate": "2016-10-1",
        "tags": [
          {
            "count": 216,
            "name": "运维",
            "title": "运维"
          },
          {
            "count": 127,
            "name": "google",
            "title": "google"
          },
          {
            "count": 114,
            "name": "SRE",
            "title": "SRE"
          },
          {
            "count": 97,
            "name": "DevOps",
            "title": "DevOps"
          },
          {
            "count": 59,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 43,
            "name": "互联网",
            "title": "互联网"
          },
          {
            "count": 32,
            "name": "软件开发",
            "title": "软件开发"
          },
          {
            "count": 29,
            "name": "架构师",
            "title": "架构师"
          }
        ],
        "origin_title": "Site Reliability Engineering: How Google Runs Production Systems",
        "image": "https://img3.doubanio.com/view/subject/m/public/s29046070.jpg",
        "binding": "平装",
        "translator": [
          "孙宇聪"
        ],
        "catalog": "前言   xxxi\n序言   xxxv\n第Ⅰ部分　概览\n第1 章　介绍   2\n系统管理员模式   2\nGoogle 的解决之道：SRE   4\nSRE 方法论   6\n确保长期关注研发工作   6\n在保障服务SLO 的前提下最大化迭代速度   7\n监控系统   8\n应急事件处理   8\n变更管理   9\n需求预测和容量规划   9\n资源部署   10\n效率与性能   10\n小结   10\n第2 章　Google 生产环境：SRE 视角   11\n硬件   11\n管理物理服务器的系统管理软件   13\n管理物理服务器   13\n存储   14\n网络   15\n其他系统软件   16\n分布式锁服务   16\n监控与警报系统   16\n软件基础设施   17\n研发环境   17\n莎士比亚搜索：一个示范服务   18\n用户请求的处理过程   18\n任务和数据的组织方式   19\n第Ⅱ部分　指导思想\n第3 章　拥抱风险   23\n管理风险   23\n度量服务的风险   24\n服务的风险容忍度   25\n辨别消费者服务的风险容忍度   26\n基础设施服务的风险容忍度   28\n使用错误预算的目的   30\n错误预算的构建过程   31\n好处   32\n第4 章　服务质量目标   34\n服务质量术语   34\n指标   34\n目标   35\n协议   36\n指标在实践中的应用   37\n运维人员和最终用户各关心什么   37\n指标的收集   37\n汇总   38\n指标的标准化   39\n目标在实践中的应用   39\n目标的定义   40\n目标的选择   40\n控制手段   42\nSLO 可以建立用户预期   42\n协议在实践中的应用   43\n第5 章　减少琐事   44\n琐事的定义   44\n为什么琐事越少越好   45\n什么算作工程工作   46\n琐事繁多是不是一定不好   47\n小结   48\n第6 章　分布式系统的监控   49\n术语定义   49\n为什么要监控   50\n对监控系统设置合理预期   51\n现象与原因   52\n黑盒监控与白盒监控   53\n4 个黄金指标   53\n关于长尾问题   54\n度量指标时采用合适的精度   55\n简化，直到不能再简化   55\n将上述理念整合起来   56\n监控系统的长期维护   57\nBigtable SRE ：警报过多的案例   57\nGmail ：可预知的、可脚本化的人工干预   58\n长跑   59\n小结   59\n第7 章　Google 的自动化系统的演进   60\n自动化的价值   60\n一致性   60\n平台性   61\n修复速度更快   61\n行动速度更快   62\n节省时间   62\n自动化对Google SRE 的价值   62\n自动化的应用案例   63\nGoogle SRE 的自动化使用案例   63\n自动化分类的层次结构   64\n让自己脱离工作：自动化所有的东西   66\n舒缓疼痛：将自动化应用到集群上线中   67\n使用Prodtest 检测不一致情况   68\n幂等地解决不一致情况   69\n专业化倾向   71\n以服务为导向的集群上线流程   72\nBorg ：仓库规模计算机的诞生   73\n可靠性是最基本的功能   74\n建议   75\n第8 章　发布工程   76\n发布工程师的角色   76\n发布工程哲学   77\n自服务模型   77\n追求速度   77\n密闭性   77\n强调策略和流程   78\n持续构建与部署   78\n构建   78\n分支   79\n测试   79\n打包   79\nRapid 系统   80\n部署   81\n配置管理   81\n小结   82\n不仅仅只对Google 有用   83\n一开始就进行发布工程   83\n第9 章　简单化   85\n系统的稳定性与灵活性   85\n乏味是一种美德   86\n我绝对不放弃我的代码   86\n“负代码行”作为一个指标   87\n最小 API   87\n模块化   87\n发布的简单化   88\n小结   88\n第Ⅲ部分　具体实践\n第10 章　基于时间序列数据进行有效报警   93\nBorgmon 的起源   94\n应用软件的监控埋点   95\n监控指标的收集   96\n时间序列数据的存储   97\n标签与向量   98\nBorg 规则计算   99\n报警   104\n监控系统的分片机制   105\n黑盒监控   106\n配置文件的维护   106\n十年之后   108\n第11 章　on-call 轮值   109\n介绍   109\non-call 工程师的一天   110\non-call 工作平衡   111\n数量上保持平衡   111\n质量上保持平衡   111\n补贴措施   112\n安全感   112\n避免运维压力过大   114\n运维压力过大   114\n奸诈的敌人—运维压力不够   115\n小结   115\n第12 章　有效的故障排查手段   116\n理论   117\n实践   119\n故障报告   119\n定位   119\n检查   120\n诊断   122\n测试和修复   124\n神奇的负面结果   125\n治愈   126\n案例分析   127\n使故障排查更简单   130\n小结   130\n第13 章　紧急事件响应   131\n当系统出现问题时怎么办   131\n测试导致的紧急事故   132\n细节   132\n响应   132\n事后总结   132\n变更部署带来的紧急事故   133\n细节   133\n事故响应   134\n事后总结   134\n流程导致的严重事故   135\n细节   135\n灾难响应   136\n事后总结   136\n所有的问题都有解决方案   137\n向过去学习，而不是重复它   138\n为事故保留记录   138\n提出那些大的，甚至不可能的问题：假如……   138\n鼓励主动测试   138\n小结   138\n第14 章　紧急事故管理   140\n无流程管理的紧急事故   140\n对这次无流程管理的事故的剖析   141\n过于关注技术问题   141\n沟通不畅   141\n不请自来   142\n紧急事故的流程管理要素   142\n嵌套式职责分离   142\n控制中心   143\n实时事故状态文档   143\n明确公开的职责交接   143\n一次流程管理良好的事故   144\n什么时候对外宣布事故   144\n小结   145\n第15 章　事后总结：从失败中学习   146\nGoogle 的事后总结哲学   146\n协作和知识共享   148\n建立事后总结文化   149\n小结以及不断优化   151\n第16 章　跟踪故障   152\nEscalator   152\nOutalator   153\n聚合   154\n加标签   155\n分析   155\n未预料到的好处   156\n第17 章　测试可靠性   157\n软件测试的类型   158\n传统测试   159\n生产测试   160\n创造一个构建和测试环境   163\n大规模测试   165\n测试大规模使用的工具   166\n针对灾难的测试   167\n对速度的渴求   168\n发布到生产环境   170\n允许测试失败   170\n集成   172\n生产环境探针   173\n小结   175\n第18 章　SRE 部门中的软件工程实践   176\n为什么软件工程项目对SRE 很重要   176\nAuxon 案例分析：项目背景和要解决的问题   177\n传统的容量规划方法   177\n解决方案：基于意图的容量规划   179\n基于意图的容量规划   180\n表达产品意图的先导条件   181\nAuxon 简介   182\n需求和实现：成功和不足   183\n提升了解程度，推进采用率   185\n团队内部组成   187\n在SRE 团队中培养软件工程风气   187\n在SRE 团队中建立起软件工程氛围：招聘与开发时间   188\n做到这一点   189\n小结   190\n第19 章　前端服务器的负载均衡   191\n有时候硬件并不能解决问题   191\n使用DNS 进行负载均衡   192\n负载均衡：虚拟IP   194\n第20 章　数据中心内部的负载均衡系统   197\n理想情况   198\n识别异常任务：流速控制和跛脚鸭任务   199\n异常任务的简单应对办法：流速控制   199\n一个可靠的识别异常任务的方法：跛脚鸭状态   200\n利用划分子集限制连接池大小   201\n选择合适的子集   201\n子集选择算法一：随机选择   202\n子集选择算法二：确定性算法   204\n负载均衡策略   206\n简单轮询算法   206\n最闲轮询策略   209\n加权轮询策略   210\n第21 章　应对过载   212\nQPS 陷阱   213\n给每个用户设置限制   213\n客户端侧的节流机制   214\n重要性   216\n资源利用率信号   217\n处理过载错误   217\n决定何时重试   218\n连接造成的负载   220\n小结   221\n第22 章　处理连锁故障   223\n连锁故障产生的原因和如何从设计上避免   224\n服务器过载   224\n资源耗尽   225\n服务不可用   228\n防止软件服务器过载   228\n队列管理   229\n流量抛弃和优雅降级   230\n重试   231\n请求延迟和截止时间   234\n慢启动和冷缓存   236\n保持调用栈永远向下   238\n连锁故障的触发条件   238\n进程崩溃   239\n进程更新   239\n新的发布   239\n自然增长   239\n计划中或计划外的不可用   239\n连锁故障的测试   240\n测试直到出现故障，还要继续测试   240\n测试最常用的客户端   241\n测试非关键性后端   242\n解决连锁故障的立即步骤   242\n增加资源   242\n停止健康检查导致的任务死亡   242\n重启软件服务器   242\n丢弃流量   243\n进入降级模式   243\n消除批处理负载   244\n消除有害的流量   244\n小结   244\n第23 章　管理关键状态：利用分布式共识来提高可靠性   246\n使用共识系统的动力：分布式系统协调失败   248\n案例1 ：脑裂问题   249\n案例2 ：需要人工干预的灾备切换   249\n案例3 ：有问题的小组成员算法   249\n分布式共识是如何工作的   250\nPaxos 概要：协议示例   251\n分布式共识的系统架构模式   251\n可靠的复制状态机   252\n可靠的复制数据存储和配置存储   252\n使用领头人选举机制实现高可用的处理系统   253\n分布式协调和锁服务   253\n可靠的分布式队列和消息传递   254\n分布式共识系统的性能问题   255\n复合式Paxos ：消息流过程详解   257\n应对大量的读操作   258\n法定租约   259\n分布式共识系统的性能与网络延迟   259\n快速Paxos 协议：性能优化   260\n稳定的领头人机制   261\n批处理   262\n磁盘访问   262\n分布式共识系统的部署   263\n副本的数量   263\n副本的位置   265\n容量规划和负载均衡   266\n对分布式共识系统的监控   270\n小结   272\n第24 章　分布式周期性任务系统   273\nCron   273\n介绍   273\n可靠性   274\nCron 任务和幂等性   274\n大规模Cron 系统   275\n对基础设施的扩展   275\n对需求的扩展   276\nGoogle Cron 系统的构建过程   277\n跟踪Cron 任务的状态   277\nPaxos 协议的使用   277\n领头人角色和追随者角色   278\n保存状态   281\n运维大型Cron 系统   282\n小结   283\n第25 章　数据处理流水线   284\n流水线设计模式的起源   284\n简单流水线设计模式与大数据   284\n周期性流水线模式的挑战   285\n工作分发不均造成的问题   285\n分布式环境中周期性数据流水线的缺点   286\n监控周期性流水线的问题   287\n惊群效应   287\n摩尔负载模式   288\nGoogle Workflow 简介   289\nWorkflow 是模型—视图—控制器（MVC）模式   290\nWorkflow 中的执行阶段   291\nWorkflow 正确性保障   291\n保障业务的持续性   292\n小结   294\n第26 章　数据完整性：读写一致   295\n数据完整性的强需求   296\n提供超高的数据完整性的策略   297\n备份与存档   298\n云计算环境下的需求   299\n保障数据完整性和可用性：Google SRE 的目标   300\n数据完整性是手段，数据可用性是目标   300\n交付一个恢复系统，而非备份系统   301\n造成数据丢失的事故类型   301\n维护数据完整性的深度和广度的困难之处   303\nGoogle SRE 保障数据完整性的手段   304\n24 种数据完整性的事故组合   304\n第一层： 软删除   305\n第二层：备份和相关的恢复方法   306\n额外一层：复制机制   308\n1T vs. 1E ：存储更多数据没那么简单   309\n第三层：早期预警   310\n确保数据恢复策略可以正常工作   313\n案例分析   314\nGmail—2011 年2 月：从GTape 上恢复数据（ 磁带）   314\nGoogle Music—2012 年3 月：一次意外删除事故的检测过程   315\nSRE 的基本理念在数据完整性上的应用   319\n保持初学者的心态   319\n信任但要验证   320\n不要一厢情愿   320\n纵深防御   320\n小结   321\n第27 章　可靠地进行产品的大规模发布   322\n发布协调工程师   323\n发布协调工程师的角色   324\n建立发布流程   325\n发布检查列表   326\n推动融合和简化   326\n发布未知的产品   327\n起草一个发布检查列表   327\n架构与依赖   328\n集成   328\n容量规划   328\n故障模式   329\n客户端行为   329\n流程与自动化   330\n开发流程   330\n外部依赖   331\n发布计划   331\n可靠发布所需要的方法论   332\n灰度和阶段性发布   332\n功能开关框架   333\n应对客户端滥用行为   334\n过载行为和压力测试   335\nLCE 的发展   335\nLCE 检查列表的变迁   336\nLCE 没有解决的问题   337\n小结   338\n第Ⅳ部分　管理\n第28 章　迅速培养SRE 加入on-call   341\n新的SRE 已经招聘到了，接下来怎么办   341\n培训初期：重体系，而非混乱   344\n系统性、累积型的学习方式   345\n目标性强的项目工作，而非琐事   346\n培养反向工程能力和随机应变能力   347\n反向工程：弄明白系统如何工作   347\n统计学和比较性思维：在压力下坚持科学方法论   347\n随机应变的能力：当意料之外的事情发生时怎么办   348\n将知识串联起来：反向工程某个生产环境服务   348\n有抱负的on-call 工程师的5 个特点   349\n对事故的渴望：事后总结的阅读和书写   349\n故障处理分角色演习   350\n破坏真的东西，并且修复它们   351\n维护文档是学徒任务的一部分   352\n尽早、尽快见习on-call   353\non-call 之后：通过培训的仪式感，以及日后的持续教育   354\n小结   354\n第29 章　处理中断性任务   355\n管理运维负载   356\n如何决策对中断性任务的处理策略   356\n不完美的机器   357\n流状态   357\n将一件事情做好   358\n实际一点的建议   359\n减少中断   361\n第30 章　通过嵌入SRE 的方式帮助团队从运维过载中恢复   363\n第一阶段：了解服务，了解上下文   364\n确定最大的压力来源   364\n找到导火索   364\n第二阶段：分享背景知识   365\n书写一个好的事后总结作为示范   366\n将紧急事件按类型排序   366\n第三阶段：主导改变   367\n从基础开始   367\n获取团队成员的帮助   367\n解释你的逻辑推理过程   368\n提出引导性问题   368\n小结   369\n第 31 章　SRE 与其他团队的沟通与协作   370\n沟通：生产会议   371\n议程   372\n出席人员   373\nSRE 的内部协作   374\n团队构成   375\n高效工作的技术   375\nSRE 内部的协作案例分析：Viceroy   376\nViceroy 的诞生   376\n所面临的挑战   378\n建议   379\nSRE 与其他部门之间的协作   380\n案例分析：将DFP 迁移到F1   380\n小结   382\n第32 章　SRE 参与模式的演进历程   383\nSRE 参与模式：是什么、怎么样以及为什么   383\nPRR 模型   384\nSRE 参与模型   384\n替代性支持   385\nPRR ：简单PRR 模型   386\n参与   386\n分析   387\n改进和重构   387\n培训   388\n“接手”服务   388\n持续改进   388\n简单PRR 模型的演进：早期参与模型   389\n早期参与模型的适用对象   389\n早期参与模型的优势   390\n不断发展的服务：框架和SRE 平台   391\n经验教训   391\n影响SRE 的外部因素   392\n结构化的解决方案：框架   392\n新服务和管理优势   394\n小结   395\n第Ⅴ部分　结束语\n第33 章　其他行业的实践经验   398\n有其他行业背景的资深SRE   399\n灾难预案与演习   400\n从组织架构层面坚持不懈地对安全进行关注   401\n关注任何细节   401\n冗余容量   401\n模拟以及进行线上灾难演习   402\n培训与考核   402\n对详细的需求收集和系统设计的关注   402\n纵深防御   403\n事后总结的文化   403\n将重复性工作自动化，消除运维负载   404\n结构化和理性的决策   406\n小结   407\n第34 章　结语   408\n附录A　系统可用性   411\n附录B　生产环境运维过程中的最佳实践   412\n附录C　事故状态文档示范   417\n附录D　事后总结示范   419\n附录E　发布协调检查列表   423\n附录F　生产环境会议记录示范   425\n参考文献   427\n索引   439__",
        "pages": "480",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s29046070.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s29046070.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s29046070.jpg"
        },
        "alt": "https://book.douban.com/subject/26875239/",
        "id": "26875239",
        "publisher": "电子工业出版社",
        "isbn10": "7121297264",
        "isbn13": "9787121297267",
        "title": "SRE: Google运维解密",
        "url": "https://api.douban.com/v2/book/26875239",
        "alt_title": "Site Reliability Engineering: How Google Runs Production Systems",
        "author_intro": "Betsy Beyer 是Google 纽约负责SRE 的一名技术文档作家。她之前曾为遍布全球的Google 数据中心与Mountain View 硬件运维团队编写文档。在搬到纽约之前，Betsy 是Stanford 大学技术性写作课程的讲师。她曾经学习国际关系与英文文学，并在Stanford和Tulane 获得学历。\nChris Jones 是Google App Engine 的一名SRE。Google App Engine 是一个PaaS 服务，每天处理超过280 亿个请求。他的办公室在旧金山，他之前的工作包括Google 广告统计、数据仓库，以及用户支持系统的维护。在之前，Chris 曾经在学校IT 行业任职，同时参与过竞选数据分析，以及一些BSD 内核的修改。他有计算机工程、经济学，以及技术政策学的学位。同时他也是一名有执照的职业工程师。\nJennifer Petoff 是Google SRE 团队的一名项目经理，工作地点在都柏林，爱尔兰。她曾经负责管理大型全球项目，包括：科学研究、工程、人力资源，以及广告等。Jennifer在加入Google 之前，曾在化工行业任职八年。她获得了Stanford 大学的化学博士与学士学位，同时她还拥有Rochester 大学的心理学学位。\nNiall Murphy 是Google 爱尔兰团队广告SRE 的负责人。他拥有20 年互联网行业经验，目前是INEX（爱尔兰网络互联枢纽）的主席。他曾经写作以及参与写作很多科技文章与书籍，包括O’Reilly 出版的IPv6 Network Administration，以及很多RFC。他目前在参与书写爱尔兰互联网发展史。他拥有计算机科学、数学，以及诗歌学的学历（他当时一定是想错了！）。他目前与妻子和两个儿子居住在都柏林。\n译者\n孙宇聪，前Google SRE（2007-2015），山景城总部，曾参与构建运维Youtube 全球CDN网络，2008年奥运会直播项目，构建维护海量视频编码传输系统。后参与Google内部云平台运维工作，负责运维全球百万级别服务器集群，以及Borg、Omega等大规模集群理系统。2015年加入Coding，任CTO一职。回国后，积极推动国内容器化运维架构升级。目前是开放运维联盟之应用运维规范制定组，高可用运维规范制定者。",
        "summary": "大型软件系统生命周期的绝大部分都处于“使用”阶段，而非“设计”或“实现”阶段。那么为什么我们却总是认为软件工程应该首要关注设计和实现呢？在《SRE：Google运维解密》中，Google SRE的关键成员解释了他们是如何对软件进行生命周期的整体性关注的，以及为什么这样做能够帮助Google成功地构建、部署、监控和运维世界上现存最大的软件系统。通过阅读《SRE：Google运维解密》，读者可以学习到Google工程师在提高系统部署规模、改进可靠性和资源利用效率方面的指导思想与具体实践——这些都是可以立即直接应用的宝贵经验。\n任何一个想要创建、扩展大规模集成系统的人都应该阅读《SRE：Google运维解密》。《SRE：Google运维解密》针对如何构建一个可长期维护的系统提供了非常宝贵的实践经验。",
        "price": "CNY 108.00",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "dba7317197e43d22d066887ff45bde9c23902ab8c27e8ce99507bdce2d15db13",
        "file": "SRE-Google运维解密.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 156,
          "average": "8.3",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "郑泽宇",
          "顾思宇"
        ],
        "pubdate": "2017-2-10",
        "tags": [
          {
            "count": 161,
            "name": "深度学习",
            "title": "深度学习"
          },
          {
            "count": 90,
            "name": "tensorflow",
            "title": "tensorflow"
          },
          {
            "count": 79,
            "name": "机器学习",
            "title": "机器学习"
          },
          {
            "count": 68,
            "name": "TensorFlow",
            "title": "TensorFlow"
          },
          {
            "count": 66,
            "name": "人工智能",
            "title": "人工智能"
          },
          {
            "count": 44,
            "name": "机器学习深度学习",
            "title": "机器学习深度学习"
          },
          {
            "count": 34,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 27,
            "name": "计算机科学",
            "title": "计算机科学"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/view/subject/m/public/s29349250.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "第1章 深度学习简介 1\n1.1 人工智能、机器学习与深度学习 2\n1.2 深度学习的发展历程 7\n1.3 深度学习的应用 10\n1.3.1 计算机视觉 10\n1.3.2 语音识别 14\n1.3.3 自然语言处理 15\n1.3.4 人机博弈 18\n1.4 深度学习工具介绍和对比 19\n小结 23\n第2章 TensorFlow环境搭建 25\n2.1 TensorFlow的主要依赖包 25\n2.1.1 Protocol Buffer 25\n2.1.2 Bazel 27\n2.2 TensorFlow安装 29\n2.2.1 使用Docker安装 30\n2.2.2 使用pip安装 32\n2.2.3 从源代码编译安装 33\n2.3 TensorFlow测试样例 37\n小结 38\n第3章 TensorFlow入门 40\n3.1 TensorFlow计算模型——计算图 40\n3.1.1 计算图的概念 40\n3.1.2 计算图的使用 41\n3.2 TensorFlow数据模型——张量 43\n3.2.1 张量的概念 43\n3.2.2 张量的使用 45\n3.3 TensorFlow运行模型——会话 46\n3.4 TensorFlow实现神经网络 48\n3.4.1 TensorFlow游乐场及神经网络简介 48\n3.4.2 前向传播算法简介 51\n3.4.3 神经网络参数与TensorFlow变量 54\n3.4.4 通过TensorFlow训练神经网络模型 58\n3.4.5 完整神经网络样例程序 62\n小结 65\n第4章 深层神经网络 66\n4.1 深度学习与深层神经网络 66\n4.1.1 线性模型的局限性 67\n4.1.2 激活函数实现去线性化 70\n4.1.3 多层网络解决异或运算 73\n4.2 损失函数定义 74\n4.2.1 经典损失函数 75\n4.2.2 自定义损失函数 79\n4.3 神经网络优化算法 81\n4.4 神经网络进一步优化 84\n4.4.1 学习率的设置 85\n4.4.2 过拟合问题 87\n4.4.3 滑动平均模型 90\n小结 92\n第5章 MNIST数字识别问题 94\n5.1 MNIST数据处理 94\n5.2 神经网络模型训练及不同模型结果对比 97\n5.2.1 TensorFlow训练神经网络 97\n5.2.2 使用验证数据集判断模型效果 102\n5.2.3 不同模型效果比较 103\n5.3 变量管理 107\n5.4 TensorFlow模型持久化 112\n5.4.1 持久化代码实现 112\n5.4.2 持久化原理及数据格式 117\n5.5 TensorFlow最佳实践样例程序 126\n小结 132\n第6章 图像识别与卷积神经网络 134\n6.1 图像识别问题简介及经典数据集 135\n6.2 卷积神经网络简介 139\n6.3 卷积神经网络常用结构 142\n6.3.1 卷积层 142\n6.3.2 池化层 147\n6.4 经典卷积网络模型 149\n6.4.1 LeNet-5模型 150\n6.4.2 Inception-v3模型 156\n6.5 卷积神经网络迁移学习 160\n6.5.1 迁移学习介绍 160\n6.5.2 TensorFlow实现迁移学习 161\n小结 169\n第7章 图像数据处理 170\n7.1 TFRecord输入数据格式 170\n7.1.1 TFRecord格式介绍 171\n7.1.2 TFRecord样例程序 171\n7.2 图像数据处理 173\n7.2.1 TensorFlow图像处理函数 174\n7.2.2 图像预处理完整样例 183\n7.3 多线程输入数据处理框架 185\n7.3.1 队列与多线程 186\n7.3.2 输入文件队列 190\n7.3.3 组合训练数据（batching） 193\n7.3.4 输入数据处理框架 196\n小结 198\n第8章 循环神经网络 200\n8.1 循环神经网络简介 200\n8.2 长短时记忆网络（LTSM）结构 206\n8.3 循环神经网络的变种 212\n8.3.1 双向循环神经网络和深层循环神经网络 212\n8.3.2 循环神经网络的dropout 214\n8.4 循环神经网络样例应用 215\n8.4.1 自然语言建模 216\n8.4.2 时间序列预测 225\n小结 230\n第9章 TensorBoard可视化 232\n9.1 TensorBoard简介 232\n9.2 TensorFlow计算图可视化 234\n9.2.1 命名空间与TensorBoard图上节点 234\n9.2.2 节点信息 241\n9.3 监控指标可视化 246\n小结 252\n第10章 TensorFlow计算加速 253\n10.1 TensorFlow使用GPU 253\n10.2 深度学习训练并行模式 258\n10.3 多GPU并行 261\n10.4 分布式TensorFlow 268\n10.4.1 分布式TensorFlow原理 269\n10.4.2 分布式TensorFlow模型训练 272\n10.4.3 使用Caicloud运行分布式TensorFlow 282\n小结 287",
        "pages": "296",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s29349250.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s29349250.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s29349250.jpg"
        },
        "alt": "https://book.douban.com/subject/26976457/",
        "id": "26976457",
        "publisher": "电子工业出版社",
        "isbn10": "7121309599",
        "isbn13": "9787121309595",
        "title": "Tensorflow：实战Google深度学习框架",
        "url": "https://api.douban.com/v2/book/26976457",
        "alt_title": "",
        "author_intro": "郑泽宇，现为才云科技（Caicloud.io）联合创始人、首席大数据科学家。针对分布式TensorFlow上手难、管理难、监控难、上线难等问题，他带领团队成功开发了国内首个成熟的分布式TensorFlow深度学习平台（TensorFlow as a Service）。基于此平台，才云大数据团队为安防、电商、金融、物流等多个行业提供有针对性的人工智能解决方案。归国创业之前，郑泽宇曾任美国谷歌高级工程师。从2013 年加入谷歌，郑泽宇作为主要技术人员参与并领导了多个大数据项目。由他提出并主导的产品聚类项目用于衔接谷歌购物和谷歌知识图谱（knowledge graph）数据，使得知识卡片形式的广告逐步取代传统的产品列表广告，开启了谷歌购物广告在搜索页面投递的新纪元。郑泽宇于2011年5月获得北京大学计算机学士学位，并荣获北京大学信息科学技术学院十佳优秀毕业论文、北京大学优秀毕业生。2013年5月获得美国 Carnegie Mellon University（CMU）大学计算机硕士学位，并获得西贝尔奖学金 (Siebel Scholarship)。郑泽宇在机器学习、人工智能领域有多年研究经验，并在SIGIR、SIGKDD、ACL、ICDM、ICWSM等顶级国际会议上发表多篇学术论文。",
        "summary": "TensorFlow是谷歌2015年开源的主流深度学习框架，目前已在谷歌、优步（Uber）、京东、小米等科技公司广泛应用。《Tensorflow实战》为使用TensorFlow深度学习框架的入门参考书，旨在帮助读者以最快、最有效的方式上手TensorFlow和深度学习。书中省略了深度学习繁琐的数学模型推导，从实际应用问题出发，通过具体的TensorFlow样例程序介绍如何使用深度学习解决这些问题。《Tensorflow实战》包含了深度学习的入门知识和大量实践经验，是走进这个最新、最火的人工智能领域的首选参考书。",
        "price": "79",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "a9d3483e0162075051bf1d23656f1bc261d767aca78e3ee6a13051e8f2136cba",
        "file": "Tensorflow-实战Google深度学习框架.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 1704,
          "average": "8.1",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "项亮"
        ],
        "pubdate": "2012-6-1",
        "tags": [
          {
            "count": 2339,
            "name": "推荐系统",
            "title": "推荐系统"
          },
          {
            "count": 1186,
            "name": "数据挖掘",
            "title": "数据挖掘"
          },
          {
            "count": 762,
            "name": "算法",
            "title": "算法"
          },
          {
            "count": 714,
            "name": "机器学习",
            "title": "机器学习"
          },
          {
            "count": 583,
            "name": "数据分析",
            "title": "数据分析"
          },
          {
            "count": 573,
            "name": "互联网",
            "title": "互联网"
          },
          {
            "count": 393,
            "name": "人工智能",
            "title": "人工智能"
          },
          {
            "count": 349,
            "name": "计算机",
            "title": "计算机"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/view/subject/m/public/s10213357.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "目　 　 录\n第1章　 好的推荐系统　 　 1\n1.1　 什么是推荐系统　 　 1\n1.2　 个性化推荐系统的应用　 　 4\n1.2.1　 电子商务　 　 4\n1.2.2　 电影和视频网站　 　 8\n1.2.3　 个性化音乐网络电台　 　 10\n1.2.4　 社交网络　 　 12\n1.2.5　 个性化阅读　 　 15\n1.2.6　 基于位置的服务　 　 16\n1.2.7　 个性化邮件　 　 17\n1.2.8　 个性化广告　 　 18\n1.3　 推荐系统评测　 　 19\n1.3.1　 推荐系统实验方法　 　 20\n1.3.2　 评测指标　 　 23\n1.3.3　 评测维度　 　 34\n第2章　 利用用户行为数据　 　 35\n2.1　 用户行为数据简介　 　 36\n2.2　 用户行为分析　 　 39\n2.2.1　 用户活跃度和物品流行度的分布　 　 39\n2.2.2　 用户活跃度和物品流行度的关系　 　 41\n2.3　 实验设计和算法评测　 　 41\n2.3.1　 数据集　 　 42\n2.3.2　 实验设计　 　 42\n2.3.3　 评测指标　 　 42\n2.4　 基于邻域的算法　 　 44\n2.4.1　 基于用户的协同过滤算法　 　 44\n2.4.2　 基于物品的协同过滤算法　 　 51\n2.4.3　 UserCF和ItemCF的综合比较　 　 59\n2.5　 隐语义模型　 　 64\n2.5.1　 基础算法　 　 64\n2.5.2　 基于LFM的实际系统的例子　 　 70\n2.5.3　 LFM和基于邻域的方法的比较　 　 72\n2.6　 基于图的模型　 　 73\n2.6.1　 用户行为数据的二分图表示　 　 73\n2.6.2　 基于图的推荐算法　 　 73\n第3章　 推荐系统冷启动问题　 　 78\n3.1　 冷启动问题简介　 　 78\n3.2　 利用用户注册信息　 　 79\n3.3　 选择合适的物品启动用户的兴趣　 　 85\n3.4　 利用物品的内容信息　 　 89\n3.5　 发挥专家的作用　 　 94\n第4章　 利用用户标签数据　 　 96\n4.1　 UGC标签系统的代表应用　 　 97\n4.1.1　 Delicious　 　 97\n4.1.2　 CiteULike　 　 98\n4.1.3　 Last.fm　 　 98\n4.1.4　 豆瓣　 　 99\n4.1.5　 Hulu　 　 99\n4.2　 标签系统中的推荐问题　 　 100\n4.2.1　 用户为什么进行标注　 　 100\n4.2.2　 用户如何打标签　 　 101\n4.2.3　 用户打什么样的标签　 　 102\n4.3　 基于标签的推荐系统　 　 103\n4.3.1　 实验设置　 　 104\n4.3.2　 一个最简单的算法　 　 105\n4.3.3　 算法的改进　 　 107\n4.3.4　 基于图的推荐算法　 　 110\n4.3.5　 基于标签的推荐解释　 　 112\n4.4　 给用户推荐标签　 　 115\n4.4.1　 为什么要给用户推荐标签　 　 115\n4.4.2　 如何给用户推荐标签　 　 115\n4.4.3　 实验设置　 　 116\n4.4.4　 基于图的标签推荐算法　 　 119\n4.5　 扩展阅读　 　 119\n第5章　 利用上下文信息　 　 121\n5.1　 时间上下文信息　 　 122\n5.1.1　 时间效应简介　 　 122\n5.1.2　 时间效应举例　 　 123\n5.1.3　 系统时间特性的分析　 　 125\n5.1.4　 推荐系统的实时性　 　 127\n5.1.5　 推荐算法的时间多样性　 　 128\n5.1.6　 时间上下文推荐算法　 　 130\n5.1.7　 时间段图模型　 　 134\n5.1.8　 离线实验　 　 136\n5.2　 地点上下文信息　 　 139\n5.3　 扩展阅读　 　 143\n第6章　 利用社交网络数据　 　 144\n6.1　 获取社交网络数据的途径　 　 144\n6.1.1　 电子邮件　 　 145\n6.1.2　 用户注册信息　 　 146\n6.1.3　 用户的位置数据　 　 146\n6.1.4　 论坛和讨论组　 　 146\n6.1.5　 即时聊天工具　 　 147\n6.1.6　 社交网站　 　 147\n6.2　 社交网络数据简介　 　 148社交网络数据中的长尾分布　 　 149\n6.3　 基于社交网络的推荐　 　 150\n6.3.1　 基于邻域的社会化推荐算法　 　 151\n6.3.2　 基于图的社会化推荐算法　 　 152\n6.3.3　 实际系统中的社会化推荐算法　 　 153\n6.3.4　 社会化推荐系统和协同过滤推荐系统　 　 155\n6.3.5　 信息流推荐　 　 156\n6.4　 给用户推荐好友　 　 159\n6.4.1　 基于内容的匹配　 　 161\n6.4.2　 基于共同兴趣的好友推荐　 　 161\n6.4.3　 基于社交网络图的好友推荐　 　 161\n6.4.4　 基于用户调查的好友推荐算法对比　 　 164\n6.5　 扩展阅读　 　 165\n第7章　 推荐系统实例　 　 166\n7.1　 外围架构　 　 166\n7.2　 推荐系统架构　 　 167\n7.3　 推荐引擎的架构　 　 171\n7.3.1　 生成用户特征向量　 　 172\n7.3.2　 特征?物品相关推荐　 　 173\n7.3.3　 过滤模块　 　 174\n7.3.4　 排名模块　 　 174\n7.4　 扩展阅读　 　 178\n第8章　 评分预测问题　 　 179\n8.1　 离线实验方法　 　 180\n8.2　 评分预测算法　 　 180\n8.2.1　 平均值　 　 180\n8.2.2　 基于邻域的方法　 　 184\n8.2.3　 隐语义模型与矩阵分解模型　 　 186\n8.2.4　 加入时间信息　 　 192\n8.2.5　 模型融合　 　 193\n8.2.6　 Netflix Prize的相关实验结果　 　 195\n后记　 　 196\n",
        "pages": "200",
        "images": {
          "small": "https://img1.doubanio.com/view/subject/s/public/s10213357.jpg",
          "large": "https://img1.doubanio.com/view/subject/l/public/s10213357.jpg",
          "medium": "https://img1.doubanio.com/view/subject/m/public/s10213357.jpg"
        },
        "alt": "https://book.douban.com/subject/10769749/",
        "id": "10769749",
        "publisher": "人民邮电出版社",
        "isbn10": "7115281580",
        "isbn13": "9787115281586",
        "title": "推荐系统实践",
        "url": "https://api.douban.com/v2/book/10769749",
        "alt_title": "",
        "author_intro": "项亮，毕业于中国科学技术大学和中国科学院自动化所，研究方向为机器学习和推荐系统，现任职于北京Hulu软件技术开发有限公司，从事视频推荐的研究和开发。2009年参加Netflix Prize推荐系统比赛获得团体第二名，且于当年发起创建了Resys China推 荐系统社区。",
        "summary": "内容简介：\n随着信息技术和互联网的发展，人们逐渐从信息匮乏的时代走入了信息过载（information overload）的时代 。在这个时代，无论是信息消费者还是信息生产者都遇到了很大的挑战：对于信息消费者，从大量信息中找到自己感兴趣的信息是一件非常困难的事情；对于信息生产者，让自己生产的信息脱颖而出，受到广大用户的关注，也是一件非常困难的事情。推荐系统就是解决这一矛盾的重要工具。推荐系统的任务就是联系用户和信息，一方面帮助用户发现对自己有价值的信息，另一方面让信息能够展现在对它感兴趣的用户面前，从而实现信息消费者和信息生产者的双赢。",
        "series": {
          "id": "13000",
          "title": "图灵原创"
        },
        "price": "49.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "a9b406e616e35917fa9b1a5205b1c836d8fe9f5380cbcbe510d90af3958fb76d",
        "file": "推荐系统实战.pdf"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 22,
          "average": "8.9",
          "min": 0
        },
        "subtitle": "基于Python的理论与实现",
        "author": [
          "[ 日］  斋藤康毅"
        ],
        "pubdate": "2018-7",
        "tags": [
          {
            "count": 39,
            "name": "深度学习",
            "title": "深度学习"
          },
          {
            "count": 21,
            "name": "Python",
            "title": "Python"
          },
          {
            "count": 11,
            "name": "机器学习",
            "title": "机器学习"
          },
          {
            "count": 10,
            "name": "人工智能",
            "title": "人工智能"
          },
          {
            "count": 10,
            "name": "python",
            "title": "python"
          },
          {
            "count": 9,
            "name": "神经网络",
            "title": "神经网络"
          },
          {
            "count": 8,
            "name": "计算机科学",
            "title": "计算机科学"
          },
          {
            "count": 6,
            "name": "计算机",
            "title": "计算机"
          }
        ],
        "origin_title": "Deep Learning from Scratch",
        "image": "https://img3.doubanio.com/view/subject/m/public/s29815955.jpg",
        "binding": "平装",
        "translator": [
          "陆宇杰"
        ],
        "catalog": "译者序　　xiii\n前言　　xv\n第1章　Python入门　　1\n1.1 Python是什么　　1\n1.2 Python的安装　　2\n1.2.1　Python版本　　2\n1.2.2　使用的外部库　　2\n1.2.3　Anaconda发行版　　3\n1.3 Python解释器　　4\n1.3.1　算术计算　　4\n1.3.2　数据类型　　5\n1.3.3　变量　　5\n1.3.4　列表　　6\n1.3.5　字典　　7\n1.3.6　布尔型　　7\n1.3.7　if 语句　　8\n1.3.8　for 语句　　8\n1.3.9　函数　　9\n1.4 Python脚本文件　　9\n1.4.1　保存为文件　　9\n1.4.2　类　　10\n1.5 NumPy　　11\n1.5.1　导入NumPy　　11\n1.5.2　生成NumPy数组　　12\n1.5.3　NumPy 的算术运算　　12\n1.5.4　NumPy的N维数组　　13\n1.5.5　广播　　14\n1.5.6　访问元素　　15\n1.6 Matplotlib　　16\n1.6.1　绘制简单图形　　16\n1.6.2　pyplot 的功能　　17\n1.6.3　显示图像　　18\n1.7 小结　　19\n第2章　感知机　　21\n2.1 感知机是什么　　21\n2.2 简单逻辑电路　　23\n2.2.1　与门　　23\n2.2.2　与非门和或门　　23\n2.3 感知机的实现　　25\n2.3.1　简单的实现　　25\n2.3.2　导入权重和偏置　　26\n2.3.3　使用权重和偏置的实现　　26\n2.4 感知机的局限性　　28\n2.4.1　异或门　　28\n2.4.2　线性和非线性　　30\n2.5 多层感知机　　31\n2.5.1　已有门电路的组合　　31\n2.5.2　异或门的实现　　33\n2.6 从与非门到计算机　　35\n2.7 小结　　36\n第3章　神经网络　　37\n3.1 从感知机到神经网络　　37\n3.1.1　神经网络的例子　　37\n3.1.2　复习感知机　　38\n3.1.3　激活函数登场　　40\n3.2 激活函数　　42\n3.2.1　sigmoid 函数　　42\n3.2.2　阶跃函数的实现　　43\n3.2.3　阶跃函数的图形　　44\n3.2.4　sigmoid 函数的实现　　45\n3.2.5　sigmoid 函数和阶跃函数的比较　　46\n3.2.6　非线性函数　　48\n3.2.7　ReLU函数　　49\n3.3 多维数组的运算　　50\n3.3.1　多维数组　　50\n3.3.2　矩阵乘法　　51\n3.3.3　神经网络的内积　　55\n3.4　　3 层神经网络的实现　　56\n3.4.1　符号确认　　57\n3.4.2　各层间信号传递的实现　　58\n3.4.3　代码实现小结　　62\n3.5 输出层的设计　　63\n3.5.1　恒等函数和softmax 函数　　64\n3.5.2　实现softmax 函数时的注意事项　　66\n3.5.3　softmax 函数的特征　　67\n3.5.4　输出层的神经元数量　　68\n3.6 手写数字识别　　69\n3.6.1　MNIST数据集　　70\n3.6.2　神经网络的推理处理　　73\n3.6.3　批处理　　75\n3.7 小结　　79\n第4章　神经网络的学习　　81\n4.1 从数据中学习　　81\n4.1.1　数据驱动　　82\n4.1.2　训练数据和测试数据　　84\n4.2 损失函数　　85\n4.2.1　均方误差　　85\n4.2.2　交叉熵误差　　87\n4.2.3　mini-batch 学习　　88\n4.2.4　mini-batch 版交叉熵误差的实现　　91\n4.2.5　为何要设定损失函数　　92\n4.3 数值微分　　94\n4.3.1　导数　　94\n4.3.2　数值微分的例子　　96\n4.3.3　偏导数　　98\n4.4 梯度　　100\n4.4.1　梯度法　　102\n4.4.2　神经网络的梯度　　106\n4.5 学习算法的实现　　109\n4.5.1　2 层神经网络的类　　110\n4.5.2　mini-batch 的实现　　114\n4.5.3　基于测试数据的评价　　116\n4.6 小结　　118\n第5章　误差反向传播法　　121\n5.1 计算图　　121\n5.1.1　用计算图求解　　122\n5.1.2　局部计算　　124\n5.1.3　为何用计算图解题　　125\n5.2 链式法则　　126\n5.2.1　计算图的反向传播　　127\n5.2.2　什么是链式法则　　127\n5.2.3　链式法则和计算图　　129\n5.3 反向传播　　130\n5.3.1　加法节点的反向传播　　130\n5.3.2　乘法节点的反向传播　　132\n5.3.3　苹果的例子　　133\n5.4 简单层的实现　　135\n5.4.1　乘法层的实现　　135\n5.4.2　加法层的实现　　137\n5.5 激活函数层的实现　　139\n5.5.1　ReLU层　　139\n5.5.2　Sigmoid 层　　141\n5.6 AffineSoftmax层的实现　　144\n5.6.1　Affine层　　144\n5.6.2　批版本的Affine层　　148\n5.6.3　Softmax-with-Loss 层　　150\n5.7 误差反向传播法的实现　　154\n5.7.1　神经网络学习的全貌图　　154\n5.7.2　对应误差反向传播法的神经网络的实现　　155\n5.7.3　误差反向传播法的梯度确认　　158\n5.7.4　使用误差反向传播法的学习　　159\n5.8 小结　　161\n第6章　与学习相关的技巧　　163\n6.1 参数的更新　　163\n6.1.1　探险家的故事　　164\n6.1.2　SGD　　164\n6.1.3　SGD的缺点　　166\n6.1.4　Momentum　　168\n6.1.5　AdaGrad　　170\n6.1.6　Adam　　172\n6.1.7　使用哪种更新方法呢　　174\n6.1.8　基于MNIST数据集的更新方法的比较　　175\n6.2 权重的初始值　　176\n6.2.1　可以将权重初始值设为0 吗　　176\n6.2.2　隐藏层的激活值的分布　　177\n6.2.3　ReLU的权重初始值　　181\n6.2.4　基于MNIST数据集的权重初始值的比较　　183\n6.3 Batch Normalization　　184\n6.3.1　Batch Normalization 的算法　　184\n6.3.2　Batch Normalization 的评估　　186\n6.4 正则化　　188\n6.4.1　过拟合　　189\n6.4.2　权值衰减　　191\n6.4.3　Dropout　　192\n6.5 超参数的验证　　195\n6.5.1　验证数据　　195\n6.5.2　超参数的最优化　　196\n6.5.3　超参数最优化的实现　　198\n6.6 小结　　200\n第7章　卷积神经网络　　201\n7.1 整体结构　　201\n7.2 卷积层　　202\n7.2.1　全连接层存在的问题　　203\n7.2.2　卷积运算　　203\n7.2.3　填充　　206\n7.2.4　步幅　　207\n7.2.5　3 维数据的卷积运算　　209\n7.2.6　结合方块思考　　211\n7.2.7　批处理　　213\n7.3 池化层　　214\n7.4 卷积层和池化层的实现　　216\n7.4.1　4 维数组　　216\n7.4.2　基于im2col 的展开　　217\n7.4.3　卷积层的实现　　219\n7.4.4　池化层的实现　　222\n7.5 CNN的实现　　224\n7.6 CNN的可视化　　228\n7.6.1　第1 层权重的可视化　　228\n7.6.2　基于分层结构的信息提取　　230\n7.7 具有代表性的CNN　　231\n7.7.1　LeNet　　231\n7.7.2　AlexNet　　232\n7.8 小结　　233\n第8章　深度学习　　235\n8.1 加深网络　　235\n8.1.1　向更深的网络出发　　235\n8.1.2　进一步提高识别精度　　238\n8.1.3　加深层的动机　　240\n8.2 深度学习的小历史　　242\n8.2.1　ImageNet　　243\n8.2.2　VGG　　244\n8.2.3　GoogLeNet　　245\n8.2.4　ResNet　　246\n8.3 深度学习的高速化　　248\n8.3.1　需要努力解决的问题　　248\n8.3.2　基于GPU的高速化　　249\n8.3.3　分布式学习　　250\n8.3.4　运算精度的位数缩减　　252\n8.4 深度学习的应用案例　　253\n8.4.1　物体检测　　253\n8.4.2　图像分割　　255\n8.4.3　图像标题的生成　　256\n8.5 深度学习的未来　　258\n8.5.1　图像风格变换　　258\n8.5.2　图像的生成　　259\n8.5.3　自动驾驶　　261\n8.5.4　Deep Q-Network（强化学习）　　262\n8.6 小结　　264\n附录A　Softmax-with-Loss 层的计算图　　267\nA.1 正向传播　　268\nA.2 反向传播　　270\nA.3 小结　　277\n参考文献　　279",
        "pages": "285",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s29815955.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s29815955.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s29815955.jpg"
        },
        "alt": "https://book.douban.com/subject/30270959/",
        "id": "30270959",
        "publisher": "人民邮电出版社",
        "isbn10": "7115485585",
        "isbn13": "9787115485588",
        "title": "深度学习入门",
        "url": "https://api.douban.com/v2/book/30270959",
        "alt_title": "Deep Learning from Scratch",
        "author_intro": "作者简介：\n斋藤康毅\n东京工业大学毕业，并完成东京大学研究生院课程。现从事计算机视觉与机器学习相关的研究和开发工作。是Introducing Python、Python in Practice、The Elements of Computing Systems、Building Machine Learning Systems with Python的日文版译者。\n译者简介：\n陆宇杰\n众安科技NLP算法工程师。主要研究方向为自然语言处理及其应用，对图像识别、机器学习、深度学习等领域有密切关注。Python爱好者。",
        "summary": "本书是深度学习真正意义上的入门书，深入浅出地剖析了深度学习的原理和相关技术。书中使用Python3，尽量不依赖外部库或工具，从基本的数学知识出发，带领读者从零创建一个经典的深度学习网络，使读者在此过程中逐步理解深度学习。书中不仅介绍了深度学习和神经网络的概念、特征等基础知识，对误差反向传播法、卷积神经网络等也有深入讲解，此外还介绍了深度学习相关的实用技巧，自动驾驶、图像生成、强化学习等方面的应用，以及为什么加深层可以提高识别精度等“为什么”的问题。",
        "series": {
          "id": "660",
          "title": "图灵程序设计丛书"
        },
        "price": "59.00元",
        "type": "pdf",
        "meta_type": "douban",
        "sha_256": "008613efc8660a18595f6e0794d791bf17af6e887f49fd6621722c94acade064",
        "file": "深度学习入门-基于Python的理论与实现.pdf"
      }
    ]
  },
  {
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 64,
          "average": "8.3",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "徐郡明"
        ],
        "pubdate": "2017-5",
        "tags": [
          {
            "count": 79,
            "name": "Kafka",
            "title": "Kafka"
          },
          {
            "count": 53,
            "name": "源码解析",
            "title": "源码解析"
          },
          {
            "count": 40,
            "name": "消息队列",
            "title": "消息队列"
          },
          {
            "count": 19,
            "name": "kafka",
            "title": "kafka"
          },
          {
            "count": 14,
            "name": "Apache",
            "title": "Apache"
          },
          {
            "count": 11,
            "name": "大数据",
            "title": "大数据"
          },
          {
            "count": 10,
            "name": "码农",
            "title": "码农"
          },
          {
            "count": 9,
            "name": "计算机科学",
            "title": "计算机科学"
          }
        ],
        "origin_title": "",
        "image": "https://img1.doubanio.com/view/subject/m/public/s29444479.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "第1章　快速入门\n1.1　Kafka简介\n1.2　以Kafka为中心的解决方案\n1.3　Kafka核心概念\n1.4　搭建Kafka源码环境\n本章小结\n第2章　生产者\n2.1　 KafkaProducer使用示例\n2.2　KafkaProducer分析\n2.2.1　ProducerInterceptors&ProducerInterceptor\n2.2.2　Kafka集群元数据\n2.2.3　Serializer&Deserializer\n2.2.4　Partitioner\n2.3　RecordAccumulator分析\n2.3.1　MemoryRecords\n2.3.2　RecordBatch\n2.3.3　BufferPool\n2.3.4　RecordAccumulator\n2.4　Sender分析\n2.4.1　创建请求\n2.4.2　KSelector\n2.4.3　InFlightRequests\n2.4.4　MetadataUpdater\n2.4.5　NetworkClient\n本章小结\n第3章　消费者\n3.1　KafkaConsumer使用示例\n3.2　传递保证语义（Delivery guarantee semantic）\n3.3　Consumer Group Rebalance设计\n3.4　KafkaConsumer分析\n3.4.1　ConsumerNetworkClient\n3.4.2　SubscriptionState\n3.4.3　ConsumerCoordinator\n3.4.4　PartitionAssignor分析\n3.4.5　Heartbeat分析\n3.4.6　Rebalance实现\n3.4.7　offset操作\n3.4.8　Fetcher\n3.4.9　KafkaConsumer分析总结\n本章小结\n第4章　Kafka服务端\n4.1　网络层\n4.1.1　Reactor模式\n4.1.2　SocketServer\n4.1.3　AbstractServerThread\n4.1.4　Acceptor\n4.1.5　Processor\n4.1.6　RequestChannel\n4.2　API层\n4.2.1　KafkaRequestHandler\n4.2.2　KafkaApis\n4.3　日志存储\n4.3.1　基本概念\n4.3.2　FileMessageSet\n4.3.3　ByteBufferMessageSet\n4.3.4　OffsetIndex\n4.3.5　LogSegment\n4.3.6　Log\n4.3.7　LogManager\n4.4　DelayedOperationPurgatory组件\n4.4.1　TimingWheel\n4.4.2　SystemTimer\n4.4.3　DelayedOperation\n4.4.4　DelayedOperationPurgatory\n4.4.5　DelayedProduce\n4.4.6　DelayedFetch\n4.5　副本机制\n4.5.1　副本\n4.5.2　分区\n4.5.3　ReplicaManager\n4.6　KafkaController\n4.6.1　ControllerChannelManager\n4.6.2　ControllerContext\n4.6.3　ControllerBrokerRequestBatch\n4.6.4　PartitionStateMachine\n4.6.5　PartitionLeaderSelector\n4.6.6　ReplicaStateMachine\n4.6.7　ZooKeeper Listener\n4.6.8　KafkaController初始化与故障转移\n4.6.9　处理ControlledShutdownRequest\n4.7　GroupCoordinator\n4.7.1　GroupMetadataManager\n4.7.2　GroupCoordinator分析\n4.8　身份认证与权限控制\n4.8.1　配置SASL/PLAIN认证\n4.8.2　身份认证\n4.8.3　权限控制\n4.9　Kafka监控\n4.9.1　JMX简介\n4.9.2　Metrics简介\n4.9.3　Kafka中的Metrics\n4.9.4　Kafka的监控功能\n4.9.5　监控KSelector的指标\n第5章　Kafka Tool\n5.1　kafka-server-start脚本\n5.2　kafka-topics脚本\n5.2.1　创建Topic\n5.2.2　修改Topic\n5.3　kafka-preferred-replica-election脚本\n5.4　kafka-reassign-partitions脚本\n5.5　kafka-console-producer脚本\n5.6　kafka-console-consumer脚本\n5.7　kafka-consumer-groups脚本\n5.8　DumpLogSegments\n5.9　kafka-producer-perf-test脚本\n5.10　kafka-consumer-perf-test脚本\n5.11　kafka-mirror-maker脚本\n本章小结",
        "ebook_url": "https://read.douban.com/ebook/47991374/",
        "pages": "604",
        "images": {
          "small": "https://img1.doubanio.com/view/subject/s/public/s29444479.jpg",
          "large": "https://img1.doubanio.com/view/subject/l/public/s29444479.jpg",
          "medium": "https://img1.doubanio.com/view/subject/m/public/s29444479.jpg"
        },
        "alt": "https://book.douban.com/subject/27038473/",
        "id": "27038473",
        "publisher": "电子工业出版社",
        "isbn10": "7121313456",
        "isbn13": "9787121313455",
        "title": "Apache Kafka源码剖析",
        "url": "https://api.douban.com/v2/book/27038473",
        "alt_title": "",
        "author_intro": "",
        "summary": "《Apache Kafka源码剖析》以Kafka 0.10.0版本源码为基础，针对Kafka的架构设计到实现细节进行详细阐述。《Apache Kafka源码剖析》共5章，从Kafka的应用场景、源码环境搭建开始逐步深入，不仅介绍Kafka的核心概念，而且对Kafka生产者、消费者、服务端的源码进行深入的剖析，最后介绍Kafka常用的管理脚本实现，让读者不仅从宏观设计上了解Kafka，而且能够深入到Kafka的细节设计之中。在源码分析的过程中，还穿插了笔者工作积累的经验和对Kafka设计的理解，希望读者可以举一反三，不仅知其然，而且知其所以然。\n《Apache Kafka源码剖析》旨在为读者阅读Kafka源码提供帮助和指导，让读者更加深入地了解Kafka的运行原理、设计理念，让读者在设计分布式系统时可以参考Kafka的优秀设计。《Apache Kafka源码剖析》的内容对于读者全面提升自己的技术能力有很大帮助。",
        "ebook_price": "53.40",
        "price": "89",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "9f23ba313ea3caeb378169bdeb147dbe33db4d5a6d7c6d0cfa1a55e81f90c78e",
        "file": "Apache-Kafka源码剖析.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 114,
          "average": "8.9",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "Neha Narkhede",
          "Gwen Shapira",
          "Todd Palino"
        ],
        "pubdate": "2017-12-26",
        "tags": [
          {
            "count": 126,
            "name": "Kafka",
            "title": "Kafka"
          },
          {
            "count": 69,
            "name": "消息队列",
            "title": "消息队列"
          },
          {
            "count": 38,
            "name": "大数据",
            "title": "大数据"
          },
          {
            "count": 38,
            "name": "分布式",
            "title": "分布式"
          },
          {
            "count": 34,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 27,
            "name": "架构",
            "title": "架构"
          },
          {
            "count": 25,
            "name": "大数据流",
            "title": "大数据流"
          },
          {
            "count": 11,
            "name": "计算机科学",
            "title": "计算机科学"
          }
        ],
        "origin_title": "Kafka: The Definitive Guide",
        "image": "https://img3.doubanio.com/view/subject/m/public/s29665582.jpg",
        "binding": "平装",
        "translator": [
          "薛命灯"
        ],
        "catalog": "序 xiii\n前言 xv\n第 1 章　初识Kafka 1\n1.1　发布与订阅消息系统 1\n1.1.1　如何开始 2\n1.1.2　独立的队列系统 3\n1.2　Kafka登场 4\n1.2.1　消息和批次 4\n1.2.2　模式 4\n1.2.3　主题和分区 5\n1.2.4　生产者和消费者 5\n1.2.5　broker和集群 6\n1.2.6　多集群 7\n1.3　为什么选择Kafka 8\n1.3.1　多个生产者 8\n1.3.2　多个消费者 8\n1.3.3　基于磁盘的数据存储 9\n1.3.4　伸缩性 9\n1.3.5　高性能 9\n1.4　数据生态系统 9\n1.5　起源故事 11\n1.5.1　LinkedIn的问题 11\n1.5.2　Kafka的诞生 12\n1.5.3　走向开源 12\n1.5.4　命名 13\n1.6　开始Kafka之旅 13\n第 2 章　安装Kafka 14\n2.1　要事先行 14\n2.1.1　选择操作系统 14\n2.1.2　安装Java 14\n2.1.3　安装Zookeeper 15\n2.2　安装Kafka Broker 17\n2.3　broker配置 18\n2.3.1　常规配置 18\n2.3.2　主题的默认配置 19\n2.4　硬件的选择 23\n2.4.1　磁盘吞吐量 23\n2.4.2　磁盘容量 23\n2.4.3　内存 23\n2.4.4　网络 24\n2.4.5　CPU 24\n2.5　云端的Kafka 24\n2.6　Kafka集群 24\n2.6.1　需要多少个broker 25\n2.6.2　broker 配置 25\n2.6.3　操作系统调优 26\n2.7　生产环境的注意事项 28\n2.7.1　垃圾回收器选项 28\n2.7.2　数据中心布局 29\n2.7.3　共享Zookeeper 29\n2.8　总结 30\n第 3 章　Kafka生产者——向Kafka写入数据 31\n3.1　生产者概览 32\n3.2　创建Kafka生产者 33\n3.3　发送消息到Kafka 34\n3.3.1　同步发送消息 35\n3.3.2　异步发送消息 35\n3.4　生产者的配置 36\n3.5　序列化器 39\n3.5.1　自定义序列化器 39\n3.5.2　使用Avro序列化 41\n3.5.3　在Kafka里使用Avro 42\n3.6　分区 45\n3.7　旧版的生产者API 46\n3.8　总结 47\n第 4 章　Kafka消费者——从Kafka读取数据 48\n4.1　KafkaConsumer概念 48\n4.1.1　消费者和消费者群组 48\n4.1.2　消费者群组和分区再均衡 51\n4.2　创建Kafka消费者 52\n4.3　订阅主题 53\n4.4　轮询 53\n4.5　消费者的配置 55\n4.6　提交和偏移量 57\n4.6.1　自动提交 58\n4.6.2　提交当前偏移量 59\n4.6.3　异步提交 59\n4.6.4　同步和异步组合提交 61\n4.6.5　提交特定的偏移量 61\n4.7　再均衡监听器 62\n4.8　从特定偏移量处开始处理记录 64\n4.9　如何退出 66\n4.10　反序列化器 67\n4.11　独立消费者——为什么以及怎样使用没有群组的消费者 71\n4.12　旧版的消费者API 71\n4.13　总结 72\n第 5 章　深入Kafka 73\n5.1　集群成员关系 73\n5.2　控制器 74\n5.3　复制 74\n5.4　处理请求 76\n5.4.1　生产请求 78\n5.4.2　获取请求 78\n5.4.3　其他请求 80\n5.5　物理存储 81\n5.5.1　分区分配 81\n5.5.2　文件管理 82\n5.5.3　文件格式 83\n5.5.4　索引 84\n5.5.5　清理 84\n5.5.6　清理的工作原理 84\n5.5.7　被删除的事件 86\n5.5.8　何时会清理主题 86\n5.9　总结 86\n第 6 章　可靠的数据传递 87\n6.1　可靠性保证 87\n6.2　复制 88\n6.3　broker配置 89\n6.3.1　复制系数 89\n6.3.2　不完全的首领选举 90\n6.3.3　最少同步副本 91\n6.4　在可靠的系统里使用生产者 92\n6.4.1　发送确认 92\n6.4.2　配置生产者的重试参数 93\n6.4.3　额外的错误处理 94\n6.5　在可靠的系统里使用消费者 94\n6.5.1　消费者的可靠性配置 95\n6.5.2　显式提交偏移量 95\n6.6　验证系统可靠性 97\n6.6.1　配置验证 98\n6.6.2　应用程序验证 98\n6.6.3　在生产环境监控可靠性 99\n6.7　总结 100\n第 7 章　构建数据管道 101\n7.1　构建数据管道时需要考虑的问题 102\n7.1.1　及时性 102\n7.1.2　可靠性 102\n7.1.3　高吞吐量和动态吞吐量 103\n7.1.4　数据格式 103\n7.1.5　转换 104\n7.1.6　安全性 104\n7.1.7　故障处理能力 104\n7.1.8　耦合性和灵活性 105\n7.2　如何在Connect API和客户端API之间作出选择 105\n7.3　Kafka Connect 106\n7.3.1　运行Connect 106\n7.3.2　连接器示例——文件数据源和文件数据池 107\n7.3.3　连接器示例——从MySQL到ElasticSearch 109\n7.3.4　深入理解Connect 114\n7.4　Connect之外的选择 116\n7.4.1　用于其他数据存储的摄入框架 116\n7.4.2　基于图形界面的ETL工具 117\n7.4.3　流式处理框架 117\n7.5　总结 117\n第 8 章　跨集群数据镜像 118\n8.1　跨集群镜像的使用场景 118\n8.2　多集群架构 119\n8.2.1　跨数据中心通信的一些现实情况 119\n8.2.2　Hub和Spoke架构 120\n8.2.3　双活架构 121\n8.2.4　主备架构 123\n8.2.5　延展集群 127\n8.3　Kafka的MirrorMaker 128\n8.3.1　如何配置 129\n8.3.2　在生产环境部署MirrorMaker 130\n8.3.3　MirrorMaker调优 132\n8.4　其他跨集群镜像方案 134\n8.4.1　优步的uReplicator 134\n8.4.2　Confluent的Replicator 135\n8.5　总结 135\n第 9 章　管理Kafka 136\n9.1　主题操作 136\n9.1.1　创建主题 137\n9.1.2　增加分区 138\n9.1.3　删除主题 138\n9.1.4　列出集群里的所有主题 139\n9.1.5　列出主题详细信息 139\n9.2　消费者群组 140\n9.2.1　列出并描述群组 140\n9.2.2　删除群组 142\n9.2.3　偏移量管理 142\n9.3　动态配置变更 143\n9.3.1　覆盖主题的默认配置 143\n9.3.2　覆盖客户端的默认配置 145\n9.3.3　列出被覆盖的配置 145\n9.3.4　移除被覆盖的配置 146\n9.4　分区管理 146\n9.4.1　首选的首领选举 146\n9.4.2　修改分区副本 147\n9.4.3　修改复制系数 150\n9.4.4　转储日志片段 151\n9.4.5　副本验证 152\n9.5　消费和生产 153\n9.5.1　控制台消费者 153\n9.5.2　控制台生产者 155\n9.6　客户端ACL 157\n9.7　不安全的操作 157\n9.7.1　移动集群控制器 157\n9.7.2　取消分区重分配 157\n9.7.3　移除待删除的主题 158\n9.7.4　手动删除主题 158\n9.8　总结 159\n第 10 章　监控Kafka 160\n10.1　度量指标基础 160\n10.1.1　度量指标在哪里 160\n10.1.2　内部或外部度量 161\n10.1.3　应用程序健康检测 161\n10.1.4　度量指标的覆盖面 161\n10.2　broker的度量指标 162\n10.2.1　非同步分区 162\n10.2.2　broker度量指标 166\n10.2.3　主题和分区的度量指标 173\n10.2.4　Java虚拟机监控 174\n10.2.5　操作系统监控 175\n10.2.6　日志 176\n10.3　客户端监控 177\n10.3.1　生产者度量指标 177\n10.3.2　消费者度量指标 179\n10.3.3　配额 181\n10.4　延时监控 182\n10.5　端到端监控 183\n10.6　总结 183\n第 11 章　流式处理 184\n11.1　什么是流式处理 185\n11.2　流式处理的一些概念 186\n11.2.1　时间 187\n11.2.2　状态 188\n11.2.3　流和表的二元性 188\n11.2.4　时间窗口 189\n11.3　流式处理的设计模式 190\n11.3.1　单个事件处理 191\n11.3.2　使用本地状态 191\n11.3.3　多阶段处理和重分区 193\n11.3.4　使用外部查找——流和表的连接 193\n11.3.5　流与流的连接 195\n11.3.6　乱序的事件 195\n11.3.7　重新处理 196\n11.4　Streams示例 197\n11.4.1　字数统计 197\n11.4.2　股票市场统计 199\n11.4.3　填充点击事件流 201\n11.5　Kafka Streams的架构概览 202\n11.5.1　构建拓扑 202\n11.5.2　对拓扑进行伸缩 203\n11.5.3　从故障中存活下来 205\n11.6　流式处理使用场景 205\n11.7　如何选择流式处理框架 206\n11.8　总结 208\n附录A　在其他操作系统上安装Kafka 209\n作者介绍 214\n封面介绍 214",
        "pages": "214",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s29665582.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s29665582.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s29665582.jpg"
        },
        "alt": "https://book.douban.com/subject/27665114/",
        "id": "27665114",
        "publisher": "人民邮电出版社",
        "isbn10": "7115473277",
        "isbn13": "9787115473271",
        "title": "Kafka权威指南",
        "url": "https://api.douban.com/v2/book/27665114",
        "alt_title": "Kafka: The Definitive Guide",
        "author_intro": "Neha Narkhede， Confluent联合创始人、CTO，曾在LinkedIn主导基于Kafka和Apache Samza构建流式基础设施，是Kafka作者之一。\nGwen Shapira， Confluent系统架构师，帮助客户构建基于Kafka的系统，在可伸缩数据架构方面拥有十余年经验；曾任Cloudera公司解决方案架构师。另著有《Hadoop应用架构》。\nTodd Palino， LinkedIn主任级SRE，负责部署管理大型的Kafka、Zookeeper和Samza集群。\n【译者简介】\n薛命灯，毕业于厦门大学软件学院，十余年软件开发和架构经验，InfoQ高级社区编辑。译有《硅谷革命》《生产微服务》等书。微信公众号CodeDeep。",
        "summary": "每个应用程序都会产生数据，包括日志消息、度量指标、用户活动记录、响应消息等。如何移动数据，几乎变得与数据本身一样重要。如果你是架构师、开发者或者产品工程师，同时也是Apache Kafka新手，那么这本实践指南将会帮助你成为流式平台上处理实时数据的专家。\n本书由出身于LinkedIn的Kafka核心作者和一线技术人员共同执笔，详细介绍了如何部署Kafka集群、开发可靠的基于事件驱动的微服务，以及基于Kafka平台构建可伸缩的流式应用程序。通过详尽示例，你将会了解到Kafka的设计原则、可靠性保证、关键API，以及复制协议、控制器和存储层等架构细节。\n● 了解发布和订阅消息模型以及该模型如何被应用在大数据生态系统中\n● 学习使用Kafka生产者和消费者来生成消息和读取消息\n● 了解Kafka保证可靠性数据传递的模式和场景需求\n● 使用Kafka构建数据管道和应用程序的最佳实践\n● 在生产环境中管理Kafka，包括监控、调优和维护\n● 了解Kafka的关键度量指标\n● 探索Kafka如何成为流式处理利器",
        "series": {
          "id": "660",
          "title": "图灵程序设计丛书"
        },
        "price": "69.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "298020f97c63bdc4a046f04a2d157ee75dcc77fde4be4ee6c5d6ac03f1ca4432",
        "file": "Kafka权威指南.epub"
      },
      {
        "title": "MySQL技术内幕",
        "subtitle": "InnoDB存储引擎",
        "author": [
          "姜承尧"
        ],
        "summary": "《MySQL技术内幕:InnoDB存储引擎(第2版)》由国内资深MySQL专家亲自执笔，国内外多位数据库专家联袂推荐。作为国内唯一一本关于InnoDB的专著，《MySQL技术内幕:InnoDB存储引擎(第2版)》的第1版广受好评，第2版不仅针对最新的MySQL 5.6对相关内容进行了全面的补充，还根据广大读者的反馈意见对第1版中存在的不足进行了完善，《MySQL技术内幕:InnoDB存储引擎(第2版)》大约重写了50％的内容。《MySQL技术内幕:InnoDB存储引擎(第2版)》从源代码的角度深度解析了InnoDB的体系结构、实现原理、工作机制，并给出了大量最佳实践，能帮助你系统而深入地掌握InnoDB，更重要的是，它能为你设计管理高性能、高可用的数据库系统提供绝佳的指导。\n《MySQL技术内幕:InnoDB存储引擎(第2版)》一共10章，首先宏观地介绍了MySQL的体系结构和各种常见的存储引擎以及它们之间的比较；接着以InnoDB的内部实现为切入点，逐一详细讲解了InnoDB存储引擎内部的各个功能模块的实现原理，包括InnoDB存储引擎的体系结构、内存中的数据结构、基于InnoDB存储引擎的表和页的物理存储、索引与算法、文件、锁、事务、备份与恢复，以及InnoDB的性能调优等重要的知识；最后对InnoDB存储引擎源代码的编译和调试做了介绍，对大家阅读和理解InnoDB的源代码有重要的指导意义。\n《MySQL技术内幕:InnoDB存储引擎(第2版)》适合所有希望构建和管理高性能、高可用性的MySQL数据库系统的开发者和DBA阅读。",
        "publisher": "机械工业出版社",
        "isbn13": "9787111422068",
        "isbn10": "7111422066",
        "tags": [
          {
            "title": "MySQL",
            "name": "MySQL",
            "count": 307
          },
          {
            "title": "数据库",
            "name": "数据库",
            "count": 204
          },
          {
            "title": "InnoDB",
            "name": "InnoDB",
            "count": 126
          },
          {
            "title": "MySQL技术内幕",
            "name": "MySQL技术内幕",
            "count": 79
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 71
          },
          {
            "title": "mysql",
            "name": "mysql",
            "count": 27
          },
          {
            "title": "技术",
            "name": "技术",
            "count": 24
          },
          {
            "title": "经典",
            "name": "经典",
            "count": 20
          }
        ],
        "pubdate": "2013-5",
        "translator": [],
        "binding": null,
        "author_intro": null,
        "rating": {
          "average": 8.5,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 240.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "2f3a75758a0876c081a08b44029991fde0ca8c9351cdd979cb48494e2c69f50e",
        "file": "MySQL技术内幕.epub"
      },
      {
        "title": "Redis实战",
        "subtitle": "",
        "author": [
          "Josiah L. Carlson"
        ],
        "summary": "【内容简介】\n本书深入浅出地介绍了Redis的5种数据类型，并通过多个实用示例展示了Redis的用法。除此之外，书中还讲述了Redis的优化方法以及扩展方法，是一本对于学习和使用 Redis 来说不可多得的参考书籍。\n本书一共由三个部分组成。第一部分对Redis进行了介 绍，说明了Redis的基本使用方法、它拥有的5种数据结构以及操作这5种数据结构的命令，并讲解了如何使用Redis去构建文章展示网站、cookie、购物车、网页缓存、数据库行缓存等一系列程序。第二部分对Redis命令进行了更详细的介绍，并展示了如何使用Redis去构建更为复杂的辅助工具和应用程序，并在最后展示了如何使用Redis去构建一个简单的社交网站。第三部分对Redis用户经常会遇到的一些问题进行了介绍，讲解了降低Redis内存占用的方法、扩展Redis性能的方法以及使用Lua语言进行脚本编程的方法。\n综上所述， 本书将是一本对于学习和使用 Redis 来说不可多得的参考书籍， 无论是 Redis 新手还是有一定经验的 Redis 使用者， 应该都能从本书中获益。\n【读者支持网站】\n查看试读章样，下载中文注释源码或者了解更多关于《Redis实战》的相关信息，请访问《Redis实战》的读者支持网站： redisinaction.com",
        "publisher": "人民邮电出版社",
        "isbn13": "9787115402844",
        "isbn10": "7115402841",
        "tags": [
          {
            "title": "Redis",
            "name": "Redis",
            "count": 341
          },
          {
            "title": "数据库",
            "name": "数据库",
            "count": 189
          },
          {
            "title": "NoSQL",
            "name": "NoSQL",
            "count": 157
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 102
          },
          {
            "title": "缓存",
            "name": "缓存",
            "count": 88
          },
          {
            "title": "redis",
            "name": "redis",
            "count": 73
          },
          {
            "title": "编程",
            "name": "编程",
            "count": 72
          },
          {
            "title": "技术",
            "name": "技术",
            "count": 56
          }
        ],
        "pubdate": "2015-10",
        "translator": [
          "黄健宏"
        ],
        "binding": "平装",
        "author_intro": "【作者简介】\n在大学毕业之后， Josiah Carlson 博士继续在加州大学欧文分校学习理论计算机科学。 在学习之余， Josiah 还断断续续地做过一些助教工作， 并偶尔承接一些编程方面的工作。 在 Josiah 即将要研究生毕业的时候， 他发现教职方面的工作机会 并不多， 于是 他加入了 Networks in Motion 公司， 开始了自己的职业生涯。 在 Networks in Motion 公司期间， Josiah 负责开发实时 GPS 导航软件， 以及交通事故通知系统。\n在离开 Networks in Motion 公司之后， Josiah 加入了 Google 公司， 之后他又到了 Adly 公司工作， 并开始学习和使用 Redis 来构建内容定向广告系统（content-targeting advertising）和 Twitter 分析平台。 几个月之后， Josiah 加入了 Redis 邮件列表， 并在那里回答了数百个关于使用和配置 Redis 的问题。 在离开 Adly 公司并成为 ChowNow 公司的首席架构师兼联合创始人之后不久， Josiah 开始创作这本《Redis 实战》。\n【译者简介】\n黄健宏（huangz）在 2011 年开始接触 Redis 以来就一直在学习和研究 Redis ， 他从 Redis 2.4 开始阅读并追踪 Redis 的源码， 对 Redis 2.6 以及 Redis 3.0 的源码进行了详细的注释， 并通过分析源码创作了《Redis 设计与实现》一书。\n除此之外， 黄健宏还是 Redis 中文文档《Redis 命令参考》的译者。\n要了解关于《Redis 实战》译者黄健宏的更多信息， 请访问他的个人主页 huangz.me ，或者他的豆瓣主页 http://www.douban.com/people/i_m_huangz/",
        "rating": {
          "average": 8.0,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 316.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "1f1141d15ce8089a3fc422f6bfef2c87fc95bb89011a46536195300ebfc5b4c6",
        "file": "Redis实战.epub"
      },
      {
        "title": "Redis开发与运维",
        "subtitle": "",
        "author": [
          "付磊",
          "张益军"
        ],
        "summary": "本书全面讲解Redis基本功能及其应用，并结合线上开发与运维监控中的实际使用案例，深入分析并总结了实际开发运维中遇到的“陷阱”，以及背后的原因， 包含大规模集群开发与管理的场景、应用案例与开发技巧，为高效开发运维提供了大量实际经验和建议。本书不要求读者有任何Redis使用经验,对入门与进阶DevOps的开发者提供有价值的帮助。主要内容包括：Redis的安装配置、API、各种高效功能、客户端、持久化、复制、高可用、内存、哨兵、集群、缓存设计等，Redis高可用集群解决方案，Redis设计和使用中的问题，最后提供了一个开源工具：Redis监控运维云平台CacheCloud。",
        "publisher": "机械工业出版社",
        "isbn13": "9787111557975",
        "isbn10": "7111557972",
        "tags": [
          {
            "title": "Redis",
            "name": "Redis",
            "count": 251
          },
          {
            "title": "redis",
            "name": "redis",
            "count": 89
          },
          {
            "title": "数据库",
            "name": "数据库",
            "count": 76
          },
          {
            "title": "运维",
            "name": "运维",
            "count": 58
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 58
          },
          {
            "title": "redis集群",
            "name": "redis集群",
            "count": 43
          },
          {
            "title": "开发",
            "name": "开发",
            "count": 38
          },
          {
            "title": "NoSQL",
            "name": "NoSQL",
            "count": 35
          }
        ],
        "pubdate": "2017-3-1",
        "translator": [],
        "binding": "平装",
        "author_intro": "付磊 搜狐视频高级研发工程师，CacheCloud项目联合创始人。拥有多年Redis开发运维经验，为公司多个核心业务提供Redis服务，同时热衷于技术传播和分享，撰写了大量关于Redis开发运维的技术文章。微博号carlosfl，博客地址是http://carlosfu.iteye.com。\n张益军 搜狐视频资深研发工程师，CacheCloud项目联合创始人，曾就职于美团、阿里巴巴等公司。搜狐视频投放组负责人，目前从事投放平台、反作弊等系统的架构设计和优化工作。研究兴趣包括海量峰值访问、分布式存储等。微博号益军YJ, 博客地址是http://hot66hot.iteye.com。",
        "rating": {
          "average": 9.0,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 192.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "f000b480e57f12f93fc61c5c807f6873baa930ce51343af26a19a5c402d3ce5c",
        "file": "Redis开发与运维.epub"
      },
      {
        "title": "Redis设计与实现",
        "subtitle": "",
        "author": [
          "黄健宏"
        ],
        "summary": "【官方网站】\n本书的官方网站 www.RedisBook.com 提供了书本试读、相关源码下载和勘误回报等服务，欢迎读者浏览和使用。\n【编辑推荐】\n系统而全面地描述了 Redis 内部运行机制\n图示丰富，描述清晰，并给出大量参考信息，是NoSQL数据库开发人员案头必备\n包括大部分Redis单机特征，以及所有多机特性\n【读者评价】\n这本书描述的知识点很丰富，覆盖很全，里面提到特性较多，有不少我们也没用过 :) 每个命令内部的机制的介绍很不错，很多估计也是首次有详细文档介绍。\n——杨卫华（@TimYang）新浪微博技术总监\n近几年Redis以其高性能、高灵活性的优点，变得越来越流行。但很多人在使用Redis时，仅仅还是停留在比较表层的功能性认识，缺乏对内部机制原理的深入理解。本书是huangz同学长期对Redis源码的阅读心得结晶，书中对Redis的各个方面都进行了详细且深入的讲解，将复杂的原理用最简单的方式为大家解构和讲解，强烈推荐给每一位Redis的使用者阅读。\n—— iammutex，NoSQLFan站长，乐视网技术经理\nRedis 是近些年来特别火爆的 NoSQL 之一。纵观中外各种书籍还没有一本能对 Redis 内部进行深入剖析，《Redis 设计与实现》可谓开此先河。常和作者在网上交流，知道作者为这本书付出了大量的心血。这本书行文流畅，思路清晰，详细地介绍了 Redis 源码的方方面面。无论是想学习 NoSQL、网络编程的初学者，还是源码控的进阶者，本书都会有很大的帮助。\n—— 阮若夷，支付宝高级专家\n【内容简介】\n本书全面而完整地讲解了Redis的内部机制与实现方式，对Redis的大多数单机功能以及所有多机功能的实现原理进行了介绍，展示了这些功能的核心数据结构以及关键的算法思想,图示丰富，描述清晰，并给出大量参考信息。通过阅读本书，读者可以快速、有效地了解Redis的内部构造以及运作机制，更好、更高效地使用Redis。\n本书主要分为四大部分。第一部分“数据结构与对象”介绍了Redis中的各种对象及其数据结构，并说明这些数据结构如何影响对象的功能和性能。第二部分“单机数据库的实现”对Redis实现单机数据库的方法进行了介绍，包括数据库、RDB持久化、AOF持久化、事件等。第三部分“多机数据库的实现”对Redis的Sentinel、复制、集群三个多机功能进行了介绍。第四部分“独立功能的实现”对Redis中各个相对独立的功能模块进行了介绍，涉及发布与订阅、事务、Lua脚本、排序、二进制位数组、慢查询日志、监视器等。本书作者专门维护了www.redisbook.com网站，提供带有详细注释的Redis源代码，以及本书相关的更新内容。",
        "publisher": "机械工业出版社",
        "isbn13": "9787111464747",
        "isbn10": "7111464745",
        "tags": [
          {
            "title": "Redis",
            "name": "Redis",
            "count": 793
          },
          {
            "title": "数据库",
            "name": "数据库",
            "count": 430
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 236
          },
          {
            "title": "源码分析",
            "name": "源码分析",
            "count": 225
          },
          {
            "title": "redis",
            "name": "redis",
            "count": 148
          },
          {
            "title": "编程",
            "name": "编程",
            "count": 128
          },
          {
            "title": "NoSQL",
            "name": "NoSQL",
            "count": 123
          },
          {
            "title": "database",
            "name": "database",
            "count": 77
          }
        ],
        "pubdate": "2014-6",
        "translator": [],
        "binding": "平装",
        "author_intro": "黄健宏 软件开发者，他喜欢函数式编程，热爱开源软件。出于对数据库的强烈兴趣，他开始阅读和分析 Redis 源代码，并对 Redis 2.6 和 Redis 3.0 的源代码进行了详细注释。他翻译并维护着 Redis 中文文档网站 www.RedisDoc .com ，编写 了 OORedis 库。除此之外，他还是《Redis in Action》一书的译者。\n作者的豆瓣主页：douban.com/people/i_m_huangz/",
        "rating": {
          "average": 8.5,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 743.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "cd3f6ec597f29ea9239fb70945c63c83b564c198ff8e7d6f10aa583fab37f22f",
        "file": "Redis设计与实现.epub"
      },
      {
        "title": "SQL基础教程（第2版）",
        "subtitle": "",
        "author": [
          "MICK"
        ],
        "summary": "本书是畅销书《SQL基础教程》第2版，介绍了关系数据库以及用来操作关系数据库的SQL语言的使用方法。书中通过丰富的图示、大量示例程序和详实的操作步骤说明，让读者循序渐进地掌握SQL的基础知识和使用技巧，切实提高编程能力。每章结尾设置有练习题，帮助读者检验对各章内容的理解程度。另外，本书还将重要知识点总结为“法则”，方便读者随时查阅。第2版除了将示例程序更新为对应新版本的DB的SQL之外，还新增了一章，介绍如何从应用程序执行SQL。",
        "publisher": "人民邮电出版社",
        "isbn13": "9787115455024",
        "isbn10": "7115455023",
        "tags": [
          {
            "title": "SQL",
            "name": "SQL",
            "count": 124
          },
          {
            "title": "数据库",
            "name": "数据库",
            "count": 75
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 44
          },
          {
            "title": "数据分析",
            "name": "数据分析",
            "count": 28
          },
          {
            "title": "MySQL",
            "name": "MySQL",
            "count": 24
          },
          {
            "title": "计算机科学",
            "name": "计算机科学",
            "count": 22
          },
          {
            "title": "基础",
            "name": "基础",
            "count": 21
          },
          {
            "title": "自学",
            "name": "自学",
            "count": 20
          }
        ],
        "pubdate": "2017-6-1",
        "translator": [
          "孙淼",
          "罗勇"
        ],
        "binding": "平装",
        "author_intro": "作者简介：\nMICK\n日本资深数据库工程师，就职于SI企业，致力于商业智能和数据仓库的开发。为CodeZine（http://codezine.jp）及IT杂志WEB+DB PRESS撰写技术文章。著作有《跟达人学SQL》《跟达人学DB设计》，是Joe Celko's SQL Puzzles and Answers,Second Edition、Joe Celko's SQL for Smarties,Fourth Edition: Advanced SQL Programming的日文版的译者。\n译者简介：\n孙淼\n从事对日软件设计和研发工作十余年，曾于2007年至2009年赴日学习工作，2015年至今再次长期赴日工作。精通应用Java、PHP进行Web框架的设计开发，并且有Oracle、Teradata、MySQL、NoSQL等多种数据库的设计开发经验。乐于品味生活细微的点滴，热衷于品尝和制作美食。译有《SQL基础教程》等。\n罗勇\n从事对日软件设计和研发工作十余年，曾多次赴日学习工作，目前就职于日本某大型企业。痴迷于技术和框架的研究，多次参与项目的需求分析、概要设计，精通多语言的Web框架和数据库的设计开发。业余爱好足球，和家人旅行。译有《SQL基础教程》《NoSQL数据库入门》《明解C语言》等。",
        "rating": {
          "average": 8.8,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 127.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "311e9a3b9a73c6b6b80c9ffd480f4708fcf81ac487c3780912ce3384aefd638a",
        "file": "SQL基础教程-第二版.epub"
      },
      {
        "title": "SQL进阶教程",
        "subtitle": "",
        "author": [
          "［ 日］ MICK"
        ],
        "summary": "本书是《SQL基础教程》作者MICK为志在向中级进阶的数据库工程师编写的一本SQL技能提升指南。全书可分为两部分，第一部分介绍了SQL语言不同寻常的使用技巧，带领读者从SQL常见技术，比如CASE表达式、自连接、HAVING子句、外连接、关联子查询、EXISTS……去探索新发现。这部分不仅穿插讲解了这些技巧背后的逻辑和相关知识，而且辅以丰富的示例程序，旨在帮助读者提升编程水平；第二部分着重介绍关系数据库的发展史，把实践与理论结合起来，旨在帮助读者加深对关系数据库和SQL语言的理解。此外，每节末尾均设置有练习题，并在书末提供了解答，方便读者检验自己对书中知识点的掌握程度。",
        "publisher": "人民邮电出版社",
        "isbn13": "9787115470522",
        "isbn10": "7115470529",
        "tags": [
          {
            "title": "SQL",
            "name": "SQL",
            "count": 79
          },
          {
            "title": "数据库",
            "name": "数据库",
            "count": 52
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 21
          },
          {
            "title": "数据分析",
            "name": "数据分析",
            "count": 12
          },
          {
            "title": "Database",
            "name": "Database",
            "count": 12
          },
          {
            "title": "进阶",
            "name": "进阶",
            "count": 10
          },
          {
            "title": "编程",
            "name": "编程",
            "count": 10
          },
          {
            "title": "mysql",
            "name": "mysql",
            "count": 9
          }
        ],
        "pubdate": "2017-11",
        "translator": [
          "吴炎昌"
        ],
        "binding": "平装",
        "author_intro": "作者简介：\nMICK\n日本知名数据库工程师，就职于SI企业，致力于数据仓库和商业智能的开发。日常除了在其个人主页“关系数据库的世界”中分享数据库和SQL的相关技术信息外，还为CodeZine（http://codezine.jp）及IT技术杂志WEB+DB PRESS撰写相关技术文章。同时还是《SQL解惑（第2版）》《SQL权威指南（第4版）》日文版的译者。\n译者简介：\n吴炎昌\n毕业于西北工业大学软件工程专业。曾供职于日本多家软件公司，从事系统开发工作。2015年回国后加入美团点评，现任系统研发工程师。爱好旅行、电影，以及品尝各种美食，有一位志趣相投的伴侣。",
        "rating": {
          "average": 9.6,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 47.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "9239bbffe5858fc47d7973fdbbbf06d20f1df76b880a4df4345f191eeb150d09",
        "file": "SQL进阶教程.epub"
      },
      {
        "title": "高性能MySQL",
        "subtitle": "第3版",
        "author": [
          "施瓦茨 (Baron Schwartz)",
          "扎伊采夫 (Peter Zaitsev)",
          "特卡琴科 (Vadim Tkachenko)"
        ],
        "summary": "《高性能mysql(第3版)》是mysql 领域的经典之作，拥有广泛的影响力。第3 版更新了大量的内容，不但涵盖了最新mysql 5.5版本的新特性，也讲述了关于固态盘、高可扩展性设计和云计算环境下的数据库相关的新内容，原有的基准测试和性能优化部分也做了大量的扩展和补充。全书共分为16 章和6 个附录，内容涵盖mysql 架构和历史，基准测试和性能剖析，数据库软硬件性能优化，复制、备份和恢复，高可用与高可扩展性，以及云端的mysql 和mysql相关工具等方面的内容。每一章都是相对独立的主题，读者可以有选择性地单独阅读。\n《高性能mysql(第3版)》不但适合数据库管理员（dba）阅读，也适合开发人员参考学习。不管是数据库新手还是专家，相信都能从本书有所收获。",
        "publisher": "电子工业出版社",
        "isbn13": "9787121198854",
        "isbn10": "7121198851",
        "tags": [
          {
            "title": "MySQL",
            "name": "MySQL",
            "count": 950
          },
          {
            "title": "数据库",
            "name": "数据库",
            "count": 632
          },
          {
            "title": "高性能MySQL",
            "name": "高性能MySQL",
            "count": 320
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 230
          },
          {
            "title": "mysql",
            "name": "mysql",
            "count": 150
          },
          {
            "title": "编程",
            "name": "编程",
            "count": 120
          },
          {
            "title": "计算机科学",
            "name": "计算机科学",
            "count": 116
          },
          {
            "title": "软件开发",
            "name": "软件开发",
            "count": 80
          }
        ],
        "pubdate": "2013-5-1",
        "translator": [
          "宁海元",
          "周振兴",
          "彭立勋",
          "翟卫祥,刘辉"
        ],
        "binding": "平装",
        "author_intro": "关于作者\nBaron Schwartz 是一位软件工程师，居住在弗吉尼亚州的Charlottesville，网络常用名是Xaprb，这是按照QWERTY 键盘的顺序在Dvorak 键盘上打出来的名字。在不忙于解决有趣的编程挑战时，Baron 会和他的妻子Lynn 以及小狗Carbon 一起享受闲暇的时光。他有一个软件工程方面的博客，地址是http://www.xaprb.com/blog/\nPeter Zaitsev 曾经是MySQL AB 公司高性能组的经理，目前在运作mysqlperformance\nblog.com 网站。他擅长于帮助那些每天有数以百万计访问量的网站的管理员解决问题，这些网站通常需要几百台机器来处理TB 级的数据。他常常为了解决一个问题而不停地升级硬件和软件（比如查询优化）。Peter 还经常在各种会议上演讲。\nVadim Tkachenko 曾经是MySQL AB 公司的性能工程师。作为一名在多线程编程和同步方面的专家，他的主要工作是基准测试、性能剖析，以及找出系统的性能瓶颈。他还在性能监控和调优方面做了一些工作，使得MySQL 在多核机器上有更好的可扩展性。\n================================================================\n译者简介\n宁海元 有超过十年的数据库管理经验，从最初到SQL Server 2000到Oracle到MySQL，擅长数据库高可用架构，性能优化和故障诊断。2007年加入淘宝，带领淘宝DBA团队支撑了淘宝业务的快速增长，完成了数据库的垂直拆分、水平拆分，迁移到MySQL体系等主要工作。目前专注于无线数据领域。网络常用名NinGoo，个人博客：http://www.ningoo.net\n周振兴 毕业于北京师范大学数学系，09年加入淘宝数据库团队负责MySQL运维管理工作，有丰富的MySQL性能优化、Troubleshooting经验，对MySQL主要模块的实现和原理有深入的研究，经历淘宝MySQL实例从30到3000的发展，对系统架构、高可用环境规划都有深入理解。个人博客：http://orczhou.com\n彭立勋 2010年大学毕业后加入阿里巴巴运维部。作为一名MySQL DBA，在运维MySQL的过程中，对MySQL和InnoDB的一些功能和缺陷就进行了补充，编写了多主复制和数据闪回等补丁。目前在阿里集团核心系统研发部数据库组，专注于MySQL数据库相关的开发工作。后来一些补丁被MySQL之父Mony看中，成为MariaDB提交组（Maria-captains）成员，并且把多主复制，线程内存监控等补丁合并到了MariaDB 10.0版本。\n翟卫祥 毕业于武汉大学，研究生阶段从事数据库相关研究。毕业后就职于阿里巴巴集团数据库技术团队至今，主要负责阿里内部MySQL代码分支维护，包括MySQL Bug Fix及新特性开发。对MySQL内核有一定的研究。\n刘辉 2008年毕业于西安电子科技大学计算机系，硕士学位。2011年加入阿里巴巴集团数据库技术团队，花名希羽，MySQL内核开发工程师。",
        "rating": {
          "average": 9.3,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 531.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "ce560b994e817d7fa7e7b5d48dbfcca351e57b1b4f0904706aa552bd84d5b72c",
        "file": "高性能MySQL.epub"
      }
    ],
    "dir_name": "data",
    "name": "数据"
  },
  {
    "dir_name": "rust",
    "name": "rust",
    "books": [
      {
        "title": "深入浅出Rust",
        "subtitle": "",
        "author": [
          "范长春"
        ],
        "summary": "本书详细描述了Rust语言的基本语法，穿插讲解一部分高级使用技巧，并以更容易理解的方式解释其背后的设计思想。全书总共分五个部分。\n第一部分介绍Rust基本语法，因为对任何程序设计语言来说，语法都是基础，学习这部分是理解其他部分的前提。\n第二部分介绍属于Rust独一无二的内存管理方式。它设计了一组全新的机制，既保证了安全性，又保持了强大的内存布局控制力，而且没有额外性能损失。这部分是本书的重点和核心所在，也是Rust语言的思想内核精髓之处。\n第三部分介绍Rust的抽象表达能力。它支持多种编程范式，以及较为强大的抽象表达能力。\n第四部分介绍并发模型。在目前这个阶段，对并行编程的支持是新一代编程语言不可绕过的重要话题。Rust也吸收了业界最新的发展成果，对并发有良好支持。\n第五部分介绍一些实用设施。Rust语言有许多创新，但它绝不是高高在上孤芳自赏的类型，设计者在设计过程中充分考虑了语言的工程实用性。众多在其他语言中被证明过的优秀实践被吸收了进来，有利于提升实际工作效率。\n通过此书，读者能够深入透彻地理解Rust的高阶特性，比如代数类型系统、生命周期、借用检查、内部可变性、线程安全、泛型、闭包、迭代器、生成器等。可作为参考书供学生、软件工程师、研究人员以及其他对Rust语言感兴趣的读者参考。本书所揭示的Rust编程语言的设计思想对于理解其他系统编程语言，如C++，也非常有帮助。",
        "publisher": "机械工业出版社",
        "isbn13": "9787111606420",
        "isbn10": "7111606426",
        "tags": [
          {
            "title": "Rust",
            "name": "Rust",
            "count": 38
          },
          {
            "title": "编程",
            "name": "编程",
            "count": 20
          },
          {
            "title": "计算机",
            "name": "计算机",
            "count": 13
          },
          {
            "title": "Programming",
            "name": "Programming",
            "count": 10
          },
          {
            "title": "计算机科学",
            "name": "计算机科学",
            "count": 9
          },
          {
            "title": "编程语言",
            "name": "编程语言",
            "count": 6
          },
          {
            "title": "rust",
            "name": "rust",
            "count": 6
          },
          {
            "title": "programming",
            "name": "programming",
            "count": 4
          }
        ],
        "pubdate": "2018-8-21",
        "translator": [],
        "binding": "平装",
        "author_intro": "范长春，中国科学院自动化研究所博士，Rust开源项目贡献者，前微软员工。目前就职于synopsys公司参与源代码静态检查工具coverity软件的开发工作。喜欢研究编译器以及源代码静态检查。在网上撰写了大量关于Rust语言的技术文章，得到了不错的反响。",
        "rating": {
          "average": 8.0,
          "max": 10.0,
          "min": 0.0,
          "numRaters": 51.0
        },
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "b889a14f832fe46d882e90860458487a578be7c2ad646d3119313a92d6c20f41",
        "file": "深入浅出Rust.epub"
      }
    ]
  },
  {
    "dir_name": "cloud",
    "name": "云",
    "books": [
      {
        "rating": {
          "max": 10,
          "numRaters": 138,
          "average": "9.3",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "【美】Marko Luksa"
        ],
        "pubdate": "2019-1",
        "tags": [
          {
            "count": 151,
            "name": "Kubernetes",
            "title": "Kubernetes"
          },
          {
            "count": 82,
            "name": "k8s",
            "title": "k8s"
          },
          {
            "count": 66,
            "name": "容器",
            "title": "容器"
          },
          {
            "count": 52,
            "name": "云计算",
            "title": "云计算"
          },
          {
            "count": 49,
            "name": "docker",
            "title": "docker"
          },
          {
            "count": 41,
            "name": "DevOps",
            "title": "DevOps"
          },
          {
            "count": 39,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 34,
            "name": "容器调度",
            "title": "容器调度"
          }
        ],
        "origin_title": "",
        "image": "https://img9.doubanio.com/view/subject/m/public/s29965036.jpg",
        "binding": "",
        "translator": [
          "七牛容器云团队"
        ],
        "catalog": "1  Kubernetes 介绍  1\n1.1  Kubernetes 系统的需求  2\n1.1.1  从单体应用到微服务  2\n1.1.2  为应用程序提供一个一致的环境  5\n1.1.3  迈向持续交付 ：DevOps 和无运维  6\n1.2  介绍容器技术  7\n1.2.1  什么是容器  7\n1.2.2  Docker 容器平台介绍  11\n1.2.3  rkt——一个 Docker 的替代方案  14\n1.3  Kubernetes 介绍  15\n1.3.1  初衷  15\n1.3.2  深入浅出地了解 Kubernetes  15\n1.3.3  Kubernetes 集群架构  17\n1.3.4  在 Kubernetes 中运行应用  18\n1.3.5  使用 Kubernetes 的好处  20\n1.4  本章小结  22\n2  开始使用 Kubernetes 和 Docker  23\n2.1  创建、运行及共享容器镜像  23\n2.1.1  安装 Docker 并运行 Hello World 容器  24\n2.1.2  创建一个简单的 Node.js 应用  26\n2.1.3  为镜像创建 Dockerfile  27\n2.1.4  构建容器镜像  27\n2.1.5  运行容器镜像  30\n2.1.6  探索运行容器的内部  31\n2.1.7  停止和删除容器  32\n2.1.8  向镜像仓库推送镜像  33\n2.2  配置 Kubernetes 集群  34\n2.2.1  用 Minikube 运行一个本地单节点 Kubernetes 集群  34\n2.2.2  使用 Google Kubernetes Engine 托管 Kubernetes 集群  36\n2.2.3  为 kubectl 配置别名和命令行补齐  39\n2.3  在 Kubernetes 上运行第一个应用  40\n2.3.1  部署 Node.js 应用  40\n2.3.2  访问 Web 应用  43\n2.3.3  系统的逻辑部分  45\n2.3.4  水平伸缩应用  46\n2.3.5  查看应用运行在哪个节点上  49\n2.3.6  介绍 Kubernetes dashboard  50\n2.4  本章小结  51\n3  pod ：运行于 Kubernetes 中的容器  53\n3.1  介绍 pod  53\n3.1.1  为何需要 pod  54\n3.1.2  了解 pod  55\n3.1.3  通过 pod 合理管理容器  56\n3.2  以 YAML 或 JSON 描述文件创建 pod  58\n3.2.1  检查现有 pod 的 YAML 描述文件  59\n3.2.2  为 pod 创建一个简单的 YAML 描述文件  61\n3.2.3  使用 kubectl create 来创建 pod  63\n3.2.4  查看应用程序日志  64\n3.2.5  向 pod 发送请求  65\n3.3  使用标签组织 pod  66\n3.3.1  介绍标签  66\n3.3.2  创建 pod 时指定标签  67\n3.3.3  修改现有 pod 的标签  68\n3.4  通过标签选择器列出 pod 子集  69\n3.4.1  使用标签选择器列出 pod  69\n3.4.2  在标签选择器中使用多个条件  71\n3.5  使用标签和选择器来约束 pod 调度  71\n3.5.1  使用标签分类工作节点  72\n3.5.2  将 pod 调度到特定节点  72\n3.5.3  调度到一个特定节点  73\n3.6  注解 pod  73\n3.6.1  查找对象的注解  74\n3.6.2  添加和修改注解  74\n3.7  使用命名空间对资源进行分组  75\n3.7.1  了解对命名空间的需求  75\n3.7.2  发现其他命名空间及其 pod  75\n3.7.3  创建一个命名空间  76\n3.7.4  管理其他命名空间中的对象  77\n3.7.5  命名空间提供的隔离  78\n3.8  停止和移除 pod  78\n3.8.1  按名称删除 pod  78\n3.8.2  使用标签选择器删除 pod  79\n3.8.3  通过删除整个命名空间来删除 pod  80\n3.8.4  删除命名空间中的所有 pod，但保留命名空间  80\n3.8.5  删除命名空间中的（几乎）所有资源  80\n3.9  本章小结  81\n4  副本机制和其他控制器 ：部署托管的 pod  83\n4.1  保持 pod 健康  84\n4.1.1  介绍存活探针  84\n4.1.2  创建基于 HTTP 的存活探针  85\n4.1.3  使用存活探针  86\n4.1.4  配置存活探针的附加属性  87\n4.1.5  创建有效的存活探针  88\n4.2  了解 ReplicationController  89\n4.2.1  ReplicationController 的操作  90\n4.2.2  创建一个 ReplicationController  92\n4.2.3  使用 ReplicationController  94\n4.2.4  将 pod 移入或移出 ReplicationController 的作用域  97\n4.2.5  修改 pod 模板  100\n4.2.6  水平缩放 pod  101\n4.2.7  删除一个 ReplicationController  103\n4.3  使用 ReplicaSet 而不是 ReplicationController  104\n4.3.1  比较 ReplicaSet 和 ReplicationController  104\n4.3.2  定义 ReplicaSet  105\n4.3.3  创建和检查 ReplicaSet  106\n4.3.4  使用 ReplicaSet 的更富表达力的标签选择器  106\n4.3.5  ReplicaSet 小结  107\n4.4  使用 DaemonSet 在每个节点上运行一个 pod  107\n4.4.1  使用 DaemonSet 在每个节点上运行一个 pod  108\n4.4.2  使用 DaemonSet 只在特定的节点上运行 pod  109\n4.5  运行执行单个任务的 pod  112\n4.5.1  介绍 Job 资源  112\n4.5.2  定义 Job 资源  113\n4.5.3  看 Job 运行一个 pod  114\n4.5.4  在 Job 中运行多个 pod 实例  114\n4.5.5  限制 Job pod 完成任务的时间  116\n4.6  安排 Job 定期运行或在将来运行一次  116\n4.6.1  创建一个 CronJob  116\n4.6.2  了解计划任务的运行方式  118\n4.7  本章小结  118\n5  服务 ：让客户端发现 pod 并与之通信  121\n5.1  介绍服务  122\n5.1.1  创建服务  123\n5.1.2  服务发现  129\n5.2  连接集群外部的服务  132\n5.2.1  介绍服务 endpoint  133\n5.2.2  手动配置服务的 endpoint  133\n5.2.3  为外部服务创建别名  135\n5.3  将服务暴露给外部客户端  136\n5.3.1  使用 NodePort 类型的服务  137\n5.3.2  通过负载均衡器将服务暴露出来  140\n5.3.3  了解外部连接的特性  142\n5.4  通过 Ingress 暴露服务  143\n5.4.1  创建 Ingress 资源  145\n5.4.2  通过 Ingress 访问服务  146\n5.4.3  通过相同的 Ingress 暴露多个服务  147\n5.4.4  配置 Ingress 处理 TLS 传输  149\n5.5  pod 就绪后发出信号  150\n5.5.1  介绍就绪探针  151\n5.5.2  向 pod 添加就绪探针  152\n5.5.3  了解就绪探针的实际作用  154\n5.6  使用 headless 服务来发现独立的 pod  155\n5.6.1  创建 headless 服务  156\n5.6.2  通过 DNS 发现 pod  156\n5.6.3  发现所有的 pod——包括未就绪的 pod  157\n5.7  排除服务故障  158\n5.8  本章小结  159\n6  卷 ：将磁盘挂载到容器  161\n6.1  介绍卷  162\n6.1.1  卷的应用示例  162\n6.1.2  介绍可用的卷类型  164\n6.2  通过卷在容器之间共享数据  165\n6.2.1  使用 emptyDir 卷  165\n6.2.2  使用 Git 仓库作为存储卷  168\n6.3  访问工作节点文件系统上的文件  171\n6.3.1  介绍 hostPath 卷  171\n6.3.2  检查使用 hostPath 卷的系统 pod  172\n6.4  使用持久化存储  173\n6.4.1  使用 GCE 持久磁盘作为 pod 存储卷  174\n6.4.2  通过底层持久化存储使用其他类型的卷  177\n6.5  从底层存储技术解耦 pod  179\n6.5.1  介绍持久卷和持久卷声明  179\n6.5.2  创建持久卷  180\n6.5.3  通过创建持久卷声明来获取持久卷  182\n6.5.4  在 pod 中使用持久卷声明  184\n6.5.5  了解使用持久卷和持久卷声明的好处  185\n6.5.6  回收持久卷  186\n6.6  持久卷的动态卷配置  187\n6.6.1  通过 StorageClass 资源定义可用存储类型  188\n6.6.2  请求持久卷声明中的存储类  188\n6.6.3  不指定存储类的动态配置  190\n6.7  本章小结  193\n7  ConfigMap 和 Secret ：配置应用程序  195\n7.1  配置容器化应用程序  195\n7.2  向容器传递命令行参数  196\n7.2.1  在 Docker 中定义命令与参数  196\n7.2.2  在 Kubernetes 中覆盖命令和参数  199\n7.3  为容器设置环境变量  200\n7.3.1  在容器定义中指定环境变量  201\n7.3.2  在环境变量值中引用其他环境变量  201\n7.3.3  了解硬编码环境变量的不足之处  202\n7.4  利用 ConfigMap 解耦配置  202\n7.4.1  ConfigMap 介绍  202\n7.4.2  创建 ConfigMap  203\n7.4.3  给容器传递 ConfigMap 条目作为环境变量  206\n7.4.4  一次性传递 ConfigMap 的所有条目作为环境变量  208\n7.4.5  传递 ConfigMap 条目作为命令行参数  209\n7.4.6  使用 configMap 卷将条目暴露为文件  210\n7.4.7  更新应用配置且不重启应用程序  216\n7.5  使用 Secret 给容器传递敏感数据  218\n7.5.1  介绍 Secret  218\n7.5.2  默认令牌 Secret 介绍  218\n7.5.3  创建 Secret  220\n7.5.4  对比 ConfigMap 与 Secret  221\n7.5.5  在 pod 中使用 Secret  222\n7.6  本章小结  228\n8  从应用访问 pod 元数据以及其他资源  229\n8.1  通过 Downward API 传递元数据  229\n8.1.1  了解可用的元数据  230\n8.1.2  通过环境变量暴露元数据  231\n8.1.3  通过 downwardAPI 卷来传递元数据  234\n8.2  与 Kubernetes API 服务器交互  237\n8.2.1  探究 Kubernetes REST API  238\n8.2.2  从 pod 内部与 API 服务器进行交互  242\n8.2.3  通过 ambassador 容器简化与 API 服务器的交互  248\n8.2.4  使用客户端库与 API 服务器交互  251\n8.3  本章小结  253\n9  Deployment: 声明式地升级应用  255\n9.1  更新运行在 pod 内的应用程序  256\n9.1.1  删除旧版本 pod，使用新版本 pod 替换  257\n9.1.2  先创建新 pod 再删除旧版本 pod  257\n9.2  使用 ReplicationController 实现自动的滚动升级  259\n9.2.1  运行第一个版本的应用  259\n9.2.2  使用 kubectl 来执行滚动式升级  261\n9.2.3  为什么 kubectl rolling-update 已经过时  265\n9.3  使用 Deployment 声明式地升级应用  266\n9.3.1  创建一个 Deployment  267\n9.3.2  升级 Deployment  269\n9.3.3  回滚 Deployment  273\n9.3.4  控制滚动升级速率  276\n9.3.5  暂停滚动升级  278\n9.3.6  阻止出错版本的滚动升级  279\n9.4  本章小结  284\n10  StatefulSet ：部署有状态的多副本应用  285\n10.1  复制有状态 pod  285\n10.1.1  运行每个实例都有单独存储的多副本  286\n10.1.2  每个 pod 都提供稳定的标识  287\n10.2  了解 Statefulset  289\n10.2.1  对比 Statefulset 和 ReplicaSet  289\n10.2.2  提供稳定的网络标识  290\n10.2.3  为每个有状态实例提供稳定的专属存储  292\n10.2.4  Statefulset 的保障  294\n10.3  使用 Statefulset  295\n10.3.1  创建应用和容器镜像  295\n10.3.2  通过 Statefulset 部署应用  296\n10.3.3  使用你的 pod  301\n10.4  在 Statefulset 中发现伙伴节点  305\n10.4.1  通过 DNS 实现伙伴间彼此发现  306\n10.4.2  更新 Statefulset  308\n10.4.3  尝试集群数据存储  309\n10.5  了解 Statefulset 如何处理节点失效  310\n10.5.1  模拟一个节点的网络断开  310\n10.5.2  手动删除 pod  312\n10.6  本章小结  313\n11  了解 Kubernetes 机理  315\n11.1  了解架构  315\n11.1.1  Kubernetes 组件的分布式特性  316\n11.1.2  Kubernetes 如何使用 etcd  318\n11.1.3  API 服务器做了什么  322\n11.1.4  API 服务器如何通知客户端资源变更  324\n11.1.5  了解调度器  325\n11.1.6  介绍控制器管理器中运行的控制器  327\n11.1.7  Kubelet 做了什么  331\n11.1.8  Kubernetes Service Proxy 的作用  332\n11.1.9  介绍 Kubernetes 插件  333\n11.1.10  总结概览  335\n11.2  控制器如何协作  335\n11.2.1  了解涉及哪些组件  335\n11.2.2  事件链  336\n11.2.3  观察集群事件  337\n11.3  了解运行中的 pod 是什么  339\n11.4  跨 pod 网络  340\n11.4.1  网络应该是什么样的  340\n11.4.2  深入了解网络工作原理  341\n11.4.3  引入容器网络接口  343\n11.5  服务是如何实现的  344\n11.5.1  引入 kube-proxy  344\n11.5.2  kube-proxy 如何使用 iptables  344\n11.6  运行高可用集群  346\n11.6.1  让你的应用变得高可用  346\n11.6.2  让 Kubernetes 控制平面变得高可用  347\n11.7  本章小结  350\n12  Kubernetes API 服务器的安全防护  351\n12.1  了解认证机制  351\n12.1.1  用户和组  352\n12.1.2  ServiceAccount 介绍  353\n12.1.3  创建 ServiceAccount  354\n12.1.4  将 ServiceAccount 分配给 pod  356\n12.2  通过基于角色的权限控制加强集群安全  358\n12.2.1  介绍 RBAC 授权插件  359\n12.2.2  介绍 RBAC 资源  360\n12.2.3  使用 Role 和 RoleBinding  363\n12.2.4  使用 ClusterRole 和 ClusterRoleBinding  367\n12.2.5  了解默认的 ClusterRole 和 ClusterRoleBinding  376\n12.2.6  理性地授予授权权限  379\n12.3  本章小结  379\n13  保障集群内节点和网络安全  381\n13.1  在 pod 中使用宿主节点的 Linux 命名空间  381\n13.1.1  在 pod 中使用宿主节点的网络命名空间  382\n13.1.2  绑定宿主节点上的端口而不使用宿主节点的网络命名空间  383\n13.1.3  使用宿主节点的 PID 与 IPC 命名空间  385\n13.2  配置节点的安全上下文  386\n13.2.1  使用指定用户运行容器  387\n13.2.2  阻止容器以 root 用户运行  388\n13.2.3  使用特权模式运行 pod  389\n13.2.4  为容器单独添加内核功能  390\n13.2.5  在容器中禁用内核功能  391\n13.2.6  阻止对容器根文件系统的写入  392\n13.2.7  容器使用不同用户运行时共享存储卷  394\n13.3  限制 pod 使用安全相关的特性  396\n13.3.1  PodSecurityPolicy 资源介绍  396\n13.3.2  了解 runAsUser、 fsGroup 和 supplementalGroup 策略  398\n13.3.3  配置允许、默认添加、禁止使用的内核功能  400\n13.3.4  限制 pod 可以使用的存储卷类型  402\n13.3.5  对不同的用户与组分配不同的 PodSecurityPolicy  402\n13.4  隔离 pod 的网络  406\n13.4.1  在一个命名空间中启用网络隔离  406\n13.4.2  允许同一命名空间中的部分 pod 访问一个服务端 pod  407\n13.4.3  在不同 Kubernetes 命名空间之间进行网络隔离  408\n13.4.4  使用 CIDR 隔离网络  409\n13.4.5  限制 pod 的对外访问流量  409\n13.5  本章小结  410\n14  计算资源管理  411\n14.1  为 pod 中的容器申请资源  411\n14.1.1  创建包含资源 requests 的 pod  412\n14.1.2  资源 requests 如何影响调度  413\n14.1.3  CPU requests 如何影响 CPU 时间分配  418\n14.1.4  定义和申请自定义资源  418\n14.2  限制容器的可用资源  419\n14.2.1  设置容器可使用资源量的硬限制  419\n14.2.2  超过 limits  421\n14.2.3  容器中的应用如何看待 limits  422\n14.3  了解 pod QoS 等级  423\n14.3.1  定义 pod 的 QoS 等级  424\n14.3.2  内存不足时哪个进程会被杀死  426\n14.4  为命名空间中的 pod 设置默认的 requests 和 limits  427\n14.4.1  LimitRange 资源简介  428\n14.4.2  LimitRange 对象的创建  428\n14.4.3  强制进行限制  430\n14.4.4  应用资源 requests 和 limits 的默认值  430\n14.5  限制命名空间中的可用资源总量  431\n14.5.1  ResourceQuota 资源介绍  431\n14.5.2  为持久化存储指定配额  434\n14.5.3  限制可创建对象的个数  434\n14.5.4  为特定的 pod 状态或者 QoS 等级指定配额  435\n14.6  监控 pod 的资源使用量  436\n14.6.1  收集、获取实际资源使用情况  437\n14.6.2  保存并分析历史资源的使用统计信息  439\n14.7  本章小结  442\n15  自动横向伸缩 pod 与集群节点  443\n15.1  pod 的横向自动伸缩  444\n15.1.1  了解自动伸缩过程  444\n15.1.2  基于 CPU 使用率进行自动伸缩  447\n15.1.3  基于内存使用进行自动伸缩  453\n15.1.4  基于其他自定义度量进行自动伸缩  453\n15.1.5  确定哪些度量适合用于自动伸缩  456\n15.1.6  缩容到 0 个副本  456\n15.2  pod 的纵向自动伸缩  456\n15.2.1  自动配置资源请求  457\n15.2.2  修改运行中 pod 的资源请求  457\n15.3  集群节点的横向伸缩  457\n15.3.1  Cluster Autoscaler 介绍  457\n15.3.2  启用 Cluster Autoscaler  459\n15.3.3  限制集群缩容时的服务干扰  460\n15.4  本章小结  461\n16  高级调度  463\n16.1  使用污点和容忍度阻止节点调度到特定节点  463\n16.1.1  介绍污点和容忍度  464\n16.1.2  在节点上添加自定义污点  466\n16.1.3  在 pod 上添加污点容忍度  467\n16.1.4  了解污点和污点容忍度的使用场景  467\n16.2  使用节点亲缘性将 pod 调度到特定节点上  469\n16.2.1  指定强制性节点亲缘性规则  470\n16.2.2  调度 pod 时优先考虑某些节点  472\n16.3  使用 pod 亲缘性与非亲缘性对 pod 进行协同部署  475\n16.3.1  使用 pod 间亲缘性将多个 pod 部署在同一个节点上  475\n16.3.2  将 pod 部署在同一机柜、可用性区域或者地理地域  478\n16.3.3  表达 pod 亲缘性优先级取代强制性要求  479\n16.3.4  利用 pod 的非亲缘性分开调度 pod  481\n16.4  本章小结  483\n17  开发应用的最佳实践  485\n17.1  集中一切资源  486\n17.2  了解 pod 的生命周期  487\n17.2.1  应用必须预料到会被杀死或者重新调度  487\n17.2.2  重新调度死亡的或者部分死亡的 pod  490\n17.2.3  以固定顺序启动 pod  491\n17.2.4  增加生命周期钩子  493\n17.2.5  了解 pod 的关闭  497\n17.3  确保所有的客户端请求都得到了妥善处理  500\n17.3.1  在 pod 启动时避免客户端连接断开  500\n17.3.2  在 pod 关闭时避免客户端连接断开  501\n17.4  让应用在 Kubernetes 中方便运行和管理  505\n17.4.1  构建可管理的容器镜像  505\n17.4.2  合理地给镜像打标签，正确地使用 ImagePullPolicy  506\n17.4.3  使用多维度而不是单维度的标签  506\n17.4.4  通过注解描述每个资源  506\n17.4.5  给进程终止提供更多的信息  507\n17.4.6  处理应用日志  508\n17.5  开发和测试的最佳实践  510\n17.5.1  开发过程中在 Kubernetes 之外运行应用  510\n17.5.2  在开发过程中使用 Minikube  512\n17.5.3  发布版本和自动部署资源清单  513\n17.5.4  使用 Ksonnet 作为编写 YAML/JSON manifest文件的额外选择  513\n17.5.5  利用持续集成和持续交付  514\n17.6  本章小结  515\n18  Kubernetes 应用扩展  517\n18.1  定义自定义 API 对象  517\n18.1.1  CustomResourceDefinitions 介绍  518\n18.1.2  使用自定义控制器自动定制资源  522\n18.1.3  验证自定义对象  526\n18.1.4  为自定义对象提供自定义 API 服务器  527\n18.2  使用 Kubernetes 服务目录扩展 Kubernetes  528\n18.2.1  服务目录介绍  529\n18.2.2  服务目录 API 服务器与控制器管理器介绍  530\n18.2.3  Service 代理和 OpenServiceBroker API  530\n18.2.4  提供服务与使用服务  533\n18.2.5  解除绑定与取消配置  535\n18.2.6  服务目录给我们带来了什么  535\n18.3  基于 Kubernetes 搭建的平台  536\n18.3.1  红帽 OpenShift 容器平台  536\n18.3.2  Deis Workflow 与 Helm  539\n18.4  本章小结  541\nA  在多个集群中使用 kubectl  543\nB  使用 kubeadm 配置多节点集群  549\nC  使用其他容器运行时  563\nD  Cluster Federation  567",
        "pages": "592",
        "images": {
          "small": "https://img9.doubanio.com/view/subject/s/public/s29965036.jpg",
          "large": "https://img9.doubanio.com/view/subject/l/public/s29965036.jpg",
          "medium": "https://img9.doubanio.com/view/subject/m/public/s29965036.jpg"
        },
        "alt": "https://book.douban.com/subject/30418855/",
        "id": "30418855",
        "publisher": "电子工业出版社",
        "isbn10": "7121349957",
        "isbn13": "9787121349959",
        "title": "Kubernetes in Action中文版",
        "url": "https://api.douban.com/v2/book/30418855",
        "alt_title": "",
        "author_intro": "Marko Luksa是一位拥有20年以上专业开发经验的软件工程师，经手项目小到简单的Web应用，大到ERP系统、框架和中间件软件，应有尽有。在为Red Hat工作期间，他从Google App Engine API实现的开发起步, 这些API将基于Red Hat的JBoss中间件产品，之后他一直在为CDI/Weld、Infinispan/JBoss DataGrid等项目贡献力量。2014后, 他加入Red Hat的Cloud Enablement团队，负责 Kubernetes和相关技术开发的更新，保障公司的中间件软件能将Kubernetes与OpenShift特性的潜能用到极致。\n译者简介\n七牛容器云 （KIRK）团队，是负责七牛云基于自身公有云业务在容器方面的多年实践经验，针对企业应用快速部署、便捷运维打造的容器云计算平台。提供持续集成、弹性伸缩、应用市场等功能特性，使企业专注于业务逻辑开发，缩短业务上线周期，优化资源利用率，提高服务响应效率的一支技术团队。",
        "summary": "《Kubernetes in Action中文版》主要讲解如何在 Kubernetes 中部署分布式容器应用。《Kubernetes in Action中文版》开始部分概要介绍了 Docker 和Kubernetes 的由来和发展，然后通过在 Kubernetes 中部署一个应用程序，一点点增加功能，逐步加深我们对于Kubernetes架构的理解和操作的实践。在本书的后面部分，也可以学习一些高阶的主题，比如监控、调试及伸缩。\nKubernetes是希腊文，意思是“舵手”，带领我们安全地到达未知水域。Kubernetes这样的容器编排系统，会帮助我们妥善地管理分布式应用的部署结构和线上流量，高效地组织容器和服务。Kubernetes 作为数据中心操作系统，在设计软件系统时，能够尽量降低在底层网络和硬件设施上的负担。",
        "price": "148",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "10f49fc9962f3daebff24d852c0752b21e81ba8d87bdbc3d513ca352b595a2ae",
        "file": "Kubernetes in Action-中文版.epub"
      },
      {
        "rating": {
          "max": 10,
          "numRaters": 19,
          "average": "8.7",
          "min": 0
        },
        "subtitle": "",
        "author": [
          "张超盟，章鑫，徐中虎，徐飞"
        ],
        "pubdate": "2019-7",
        "tags": [
          {
            "count": 19,
            "name": "service-mesh",
            "title": "service-mesh"
          },
          {
            "count": 17,
            "name": "微服务",
            "title": "微服务"
          },
          {
            "count": 14,
            "name": "云原生",
            "title": "云原生"
          },
          {
            "count": 10,
            "name": "云计算",
            "title": "云计算"
          },
          {
            "count": 9,
            "name": "Kubernetes",
            "title": "Kubernetes"
          },
          {
            "count": 8,
            "name": "计算机",
            "title": "计算机"
          },
          {
            "count": 6,
            "name": "IT",
            "title": "IT"
          },
          {
            "count": 3,
            "name": "K8s",
            "title": "K8s"
          }
        ],
        "origin_title": "",
        "image": "https://img3.doubanio.com/view/subject/m/public/s33301812.jpg",
        "binding": "平装",
        "translator": [],
        "catalog": "原理篇\n第1章 你好，Istio\n第2章 Istio架构概述\n第3章 非侵入的流量治理\n第4章 可扩展的策略和遥测\n第5章 可插拔的服务安全\n第6章 透明的Sidecar机制\n第7章 多集群服务治理\n实践篇\n第8章 环境准备\n第9章 流量监控\n第10章 灰度发布\n第11章 流量治理\n第12章 服务保护\n第13章 多集群管理\n架构篇\n第14章 司令官Pilot\n第15章 守护神Mixer\n第16章 安全碉堡Citadel\n第17章 高性能代理Envoy\n第18章 代理守护进程Pilot-agent\n第19章 配置中心Galley\n源码篇\n第20章 Pilot源码解析\n第21章 Mixer源码解析\n第22章 Citadel源码解析\n第23章 Envoy源码解析\n第24章 Galley源码解析\n结语\n附录A 源码仓库介绍\n附录B 实践经验和总结",
        "pages": "606",
        "images": {
          "small": "https://img3.doubanio.com/view/subject/s/public/s33301812.jpg",
          "large": "https://img3.doubanio.com/view/subject/l/public/s33301812.jpg",
          "medium": "https://img3.doubanio.com/view/subject/m/public/s33301812.jpg"
        },
        "alt": "https://book.douban.com/subject/34438220/",
        "id": "34438220",
        "publisher": "电子工业出版社",
        "isbn10": "7121366533",
        "isbn13": "9787121366536",
        "title": "云原生服务网格Istio：原理、实践、架构与源码解析",
        "url": "https://api.douban.com/v2/book/34438220",
        "alt_title": "",
        "author_intro": "",
        "summary": "本书分为原理篇、实践篇、架构篇和源码篇，由浅入深地将Istio项目庖丁解牛并呈现给读者。\n原理篇介绍了服务网格技术与Istio项目的技术背景、设计理念与功能原理，能够帮助读者了解服务网格这一云原生领域的标志性技术，掌握Istio流量治理、策略与邀测和安全功能的使用方法。\n实践篇从零开始搭建Istio运行环境并完成一个真实应用的开发、交付、上线监控与治理的完整过程，能够帮助读者熟悉Istio的功能并加深对Istio的理解。\n架构篇剖析了Istio项目的三大核心子项目Pilot、Mixer、Citadel的详细架构，帮助读者熟悉Envoy、Galley、Pilot-agent等相关项目，并挖掘Istio代码背后的设计与实现思想。\n源码篇对Istio各个项目的代码结构、文件组织、核心流程、主要数据结构及各主要代码片段等关键内容都进行了详细介绍，读者只需具备一定的Go语言基础，便可快速掌握Istio各部分的实现原理，并根据自己的兴趣深入了解某一关键机制的完整实践。\n本书提供源代码下载，参见 http://github.com/cloudnativebooks/cloud-native-istio。\n无论是对于刚入门Istio的读者，还是对于已经在产品中使用Istio的读者，本书都极具参考价值。",
        "price": "139.00元",
        "type": "epub",
        "meta_type": "douban",
        "sha_256": "c0e7e5e983bea4b8792a3d1db95e565b3fd714edf6c0640d6294ef1a36e799c9",
        "file": "云原生服务网格Istio.epub"
      }
    ]
  }
]